/******************************************\|**| PsuedoColumn_LDEF.c\******************************************/#pragma mark ¥¥INCLUDES¥¥/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#include <MacTypes.h>#include <Lists.h>#include <Sound.h> // beep#include <TextUtils.h> // numtostring#include <Resources.h>#include <AERegistry.h>#include <AEPackObject.h>#include <AEObjects.h>#include <Gestalt.h>#include <LowMem.h>#include <ToolUtils.h>#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#pragma mark _this library includes_/* - this project*******************************************/#include "PsuedoColumn_LDEF.h"#pragma mark ¥¥DEFINITIONS¥¥/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kMinRowHeight	21#pragma mark _macros_/* - macros*******************************************/#define require(x,y) do { if (!(x)) goto y; } while (0)#pragma mark ¥¥TYPEDEFS¥¥/******************************************\|**| typedefs\******************************************/typedef struct{	PenState				oldPen;	GrafPtr					oldPort;	RgnHandle				oldClip;	RgnHandle				newClip;	ControlFontStyleRec		oldFont;	RGBColor				rgbFgColor;	RGBColor				rgbBkColor;	PixPatHandle			pnPixPat;	PixPatHandle			bkPixPat;} stateType;typedef struct{	long					size;	long					style;	long					refCon;	long					columnWidth[kPC_LDEF_MaxColumnNumber];	Str255					name;} nlPCType;#pragma mark ¥¥EXTERNAL GLOBALS¥¥/******************************************\|**| external globals\******************************************/#pragma mark ¥¥PRIVATE GLOBALS¥¥/******************************************\|**| private globals\******************************************/#pragma mark ¥¥PRIVATE PROTOTYPES¥¥/******************************************\|**| private function prototypes\******************************************/void MyLDEFHighlight ( Rect *cellRect, ListHandle theList, Boolean selected);#pragma mark ¥¥PRIVATE FUNCTIONS¥¥/******************************************\|**| private functions\******************************************/pascal void main( short message, Boolean selected, Rect *cellRect,	Cell theCell, short dataOffset, short dataLen, ListHandle theList);void DrawCell( short selected, Cell theCell, Rect *cellRect, ListHandle theList);void SaveState( stateType *oldState, Rect *cellRect, ListHandle theList);void RestoreState( stateType *oldState, ListHandle theList);short GetMostDepth( Rect *localBounds, Boolean *isColor);void ShortenStringToWidth( StringPtr s, short width);Rect *CU_GetControlBounds( ControlHandle aControl, Rect *bounds);#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/pascal void main( short message, Boolean selected, Rect *cellRect,	Cell theCell, short dataOffset, short dataLen, ListHandle theList){	PsuedoColumnLDEFDataType	**d = (PsuedoColumnLDEFDataType **)(*theList)->userHandle;	switch ( message)	{		case lInitMsg:/*			{				stateType				oldState;				Rect					controlRect;				Str255					s;				Handle					nlPCHandle = nil;				nlPCType				*nlPCData = nil;				short					fontNum, i;				//				(*theList)->refCon = 130;				d = (PsuedoColumnLDEFDataType **)NewHandle( sizeof( PsuedoColumnLDEFDataType));				if ( d == nil)				{					DebugStr("\pcouldn't allocate memory for list data");					(*theList)->refCon = nil;					return;				}								nlPCHandle = GetResource( 'nlPC', (*theList)->refCon);				if ( nlPCHandle == nil)				{					NumToString( (*theList)->refCon, s);					DebugStr("\pcouldn't find nlPC resource; id follows...");					DebugStr( s);					(*theList)->refCon = nil;					return;				}								HLock( nlPCHandle);				nlPCData = (nlPCType *)*nlPCHandle;				(*d)->fontStyle.size = nlPCData->size;				(*d)->fontStyle.style = nlPCData->style;				if ( nlPCData->name[0] == 0)				{					fontNum = 0;				} else				{					GetFNum( nlPCData->name, &fontNum);				}				(*d)->fontStyle.font = fontNum;								for ( i = 0; i < kPC_LDEF_MaxColumnNumber; i++)				{									(*d)->columnWidth[i] = nlPCData->columnWidth[i];				}								ReleaseResource( nlPCHandle);				(*theList)->userHandle = (Handle)d;								SaveState( &oldState, cellRect, theList);				GetFontInfo( &(*d)->fInfo);				(*d)->rowHeight = (*d)->fInfo.ascent + (*d)->fInfo.descent +					(*d)->fInfo.leading + 2;				(*d)->baseLine = (*d)->rowHeight - ( (*d)->fInfo.ascent);				if ( (*d)->rowHeight < kMinRowHeight)				{					(*d)->rowHeight = kMinRowHeight;					// center text in row					(*d)->baseLine = (((((*d)->rowHeight-2) - ((*d)->fInfo.ascent						))						 / 2) + (*d)->fInfo.ascent);									}								RestoreState( &oldState);				LCellSize( (Point){ (*d)->rowHeight,					( (*(*theList)->vScroll)->contrlRect.left -						(*theList)->rView.left)},						theList);			}*/			break;				case lDrawMsg:			if ( d == nil)			{				stateType				oldState;				Rect					controlRect;				Str255					s;				Handle					nlPCHandle = nil;				nlPCType				*nlPCData = nil;				short					fontNum, i;								SysBeep( 20);				//				(*theList)->refCon = 130;				d = (PsuedoColumnLDEFDataType **)NewHandle( sizeof( PsuedoColumnLDEFDataType));				if ( d == nil)				{					DebugStr("\pcouldn't allocate memory for list data");					(*theList)->refCon = nil;					return;				}								nlPCHandle = GetResource( 'nlPC', (*theList)->refCon);				if ( nlPCHandle == nil)				{					NumToString( (*theList)->refCon, s);					DebugStr("\pcouldn't find nlPC resource; id follows...");					DebugStr( s);					(*theList)->refCon = nil;					return;				}								HLock( nlPCHandle);				nlPCData = (nlPCType *)*nlPCHandle;				(*d)->fontStyle.size = nlPCData->size;				(*d)->fontStyle.style = nlPCData->style;				if ( nlPCData->name[0] == 0)				{					fontNum = 0;				} else				{					GetFNum( nlPCData->name, &fontNum);				}				(*d)->fontStyle.font = fontNum;								for ( i = 0; i < kPC_LDEF_MaxColumnNumber; i++)				{									(*d)->columnWidth[i] = nlPCData->columnWidth[i];				}								ReleaseResource( nlPCHandle);				(*theList)->userHandle = (Handle)d;								SaveState( &oldState, cellRect, theList);				GetFontInfo( &(*d)->fInfo);				(*d)->rowHeight = (*d)->fInfo.ascent + (*d)->fInfo.descent +					(*d)->fInfo.leading + 2;				(*d)->baseLine = (*d)->rowHeight - ( (*d)->fInfo.ascent);				if ( (*d)->rowHeight < kMinRowHeight)				{					(*d)->rowHeight = kMinRowHeight;					// center text in row					(*d)->baseLine = (((((*d)->rowHeight-2) - ((*d)->fInfo.ascent						))						 / 2) + (*d)->fInfo.ascent);									}								RestoreState( &oldState, theList);				{					Rect	controlBounds;										CU_GetControlBounds( (*theList)->vScroll, &controlBounds);										LCellSize( (Point){ (*d)->rowHeight,						( controlBounds.left -							(*theList)->rView.left)},							theList);				}			}			if ( d == nil) return;			DrawCell( selected, theCell, cellRect, theList);			break;				case lHiliteMsg:			if ( d == nil) return;			DrawCell( selected, theCell, cellRect, theList);			break;				case lCloseMsg:			if ( d == nil) return;			DisposeHandle( (Handle)d);			break;	}}void DrawCell( short selected, Cell theCell, Rect *cellRect, ListHandle theList){	stateType	oldState;	short		dataLength = sizeof( PsuedoColumnLDEFCellDataType), i, sl, x,				tabNum = 0;	Rect		tRect;	PsuedoColumnLDEFDataType	**d = (PsuedoColumnLDEFDataType **)(*theList)->userHandle;	PsuedoColumnLDEFCellDataType cellData;	Boolean		isColor;		Str255		s;		SaveState( &oldState, cellRect, theList);	PenNormal();		LGetCell( &cellData, &dataLength, theCell, theList);	SetThemeBackground(kThemeListViewBackgroundBrush,		GetMostDepth( cellRect, &isColor), isColor);	tRect = *cellRect;	tRect.bottom = cellRect->top + (*d)->rowHeight - 1;	EraseRect( cellRect);		SetThemePen( kThemeListViewSeparatorBrush,		GetMostDepth( cellRect, &isColor), isColor);	MoveTo( tRect.left, tRect.bottom);	LineTo( tRect.right -1, tRect.bottom);		SetThemeTextColor( kThemeListViewTextColor,		GetMostDepth( cellRect, &isColor), isColor);			i = 0;	x = 4;	tabNum = 0;	i += 4;		while ( i <= ( dataLength))	{		MoveTo( cellRect->left + x,			cellRect->top + (*d)->baseLine);				s[0] = 0;		sl = 0;		while (( cellData.name[i] != '\t') && ( i < dataLength))		{			sl++;			s[0] = sl;			s[sl] = cellData.name[i];			i++;		}		if (( tabNum < kPC_LDEF_MaxColumnNumber) &&			((*d)->columnWidth[tabNum] > 0))		{			ShortenStringToWidth( s, (*d)->columnWidth[tabNum]);		}				DrawString( s);		x += (*d)->columnWidth[tabNum];		tabNum++;		if ( i <= dataLength) i++;	}			if ( selected)	{		MyLDEFHighlight( cellRect, theList, selected);	}	RestoreState( &oldState, theList);}void MyLDEFHighlight ( Rect *cellRect, ListHandle theList, Boolean selected){	stateType	oldState;	RGBColor	c = {65535,65535,65535};	Boolean		isColor;	  	if ( selected)  	{		RGBForeColor( &c);		SetThemeBackground(kThemeListViewBackgroundBrush,			GetMostDepth( cellRect, &isColor), isColor);		LMSetHiliteMode(hiliteBit);		InvertRect(cellRect);	}}void SaveState( stateType *oldState, Rect *cellRect, ListHandle theList){	PsuedoColumnLDEFDataType	**d = (PsuedoColumnLDEFDataType **)(*theList)->userHandle;	GrafPtr						port = nil;		GetPenState( &oldState->oldPen);	GetPort( &oldState->oldPort);#ifndef TARGET_API_MAC_CARBON					if ( (*theList)->port != nil)		SetPort( (*theList)->port);		if ( (*theList)->port != nil)	{		oldState->oldFont.font = (*theList)->port->txFont;		oldState->oldFont.style = (*theList)->port->txFace;		oldState->oldFont.mode = (*theList)->port->txMode;		oldState->oldFont.size = (*theList)->port->txSize;		oldState->rgbFgColor = ((CGrafPtr)(*theList)->port)->rgbFgColor;		oldState->rgbBkColor = ((CGrafPtr)(*theList)->port)->rgbBkColor;	}#else	port = GetListPort( theList);		if ( port != nil)		SetPort( port);		if ( port != nil)	{				if ( port != nil)		{			oldState->oldFont.font = GetPortTextFont( port);			oldState->oldFont.style = GetPortTextFace( port);			oldState->oldFont.mode = GetPortTextMode( port);			oldState->oldFont.size = GetPortTextSize( port);			// foreground & background color not available		}#endif TARGET_API_MAC_CARBON//		oldState->bkPixPat = ((CGrafPtr)(*theList)->port)->bkPixPat;//		oldState->pnPixPat = ((CGrafPtr)(*theList)->port)->pnPixPat;	}		oldState->oldClip = nil;	oldState->newClip = nil;//	oldState->oldClip = NewRgn();//	oldState->newClip = NewRgn();		TextFont( (*d)->fontStyle.font);	TextSize( (*d)->fontStyle.size);	if ( oldState->oldClip != nil)		GetClip( oldState->oldClip);		if ( oldState->newClip != nil)		RectRgn( oldState->newClip, cellRect);		if ( oldState->oldClip != nil)		SectRgn( oldState->oldClip, oldState->newClip, oldState->newClip);		if ( oldState->newClip != nil)		SetClip( oldState->newClip);}	void RestoreState( stateType *oldState, ListHandle theList){	if ( oldState->oldClip != nil)		SetClip( oldState->oldClip);	SetPenState( &oldState->oldPen);#ifndef TARGET_API_MAC_CARBON	if ( (*theList)->port != nil)#else	if ( GetListPort( theList) != nil)#endif TARGET_API_MAC_CARBON	{		TextFont( oldState->oldFont.font);		TextFace( oldState->oldFont.style);		TextMode( oldState->oldFont.mode);		TextSize( oldState->oldFont.size);//		if ( oldState->pnPixPat != nil)//			PenPixPat( oldState->pnPixPat);#ifndef TARGET_API_MAC_CARBON		RGBForeColor( &oldState->rgbFgColor);		RGBBackColor( &oldState->rgbBkColor);#endif TARGET_API_MAC_CARBON//		if ( oldState->bkPixPat != nil)//			BackPixPat( oldState->bkPixPat);	}		if ( oldState->oldPort != nil)		SetPort( oldState->oldPort);	if ( oldState->oldClip != nil)		DisposeRgn( oldState->oldClip);	if ( oldState->newClip != nil)		DisposeRgn( oldState->newClip);}short GetMostDepth( Rect *localBounds, Boolean *isColor){	GDHandle		aDevice = nil, mostDevice = nil;	GrafPtr			oldPort = nil;	Rect			globalBounds = *localBounds, intersectRect;	long			area = 0, greatestArea = 0;	PixMapHandle	pmap = nil;//	*isColor = false;//	return 1;				LocalToGlobal( (Point *)&(globalBounds.top));	LocalToGlobal( (Point *)&(globalBounds.bottom));	*isColor = false;	aDevice = GetDeviceList();	while ( aDevice != nil)	{		if (( TestDeviceAttribute( aDevice, screenDevice)) && ( TestDeviceAttribute( aDevice, screenActive)))		{			if ( SectRect( &globalBounds, &((*aDevice)->gdRect), &intersectRect))			{				area = (long)(intersectRect.right - intersectRect.left) *						(long)(intersectRect.bottom - intersectRect.top);			} else area = 0;			if ( area > greatestArea)			{				greatestArea = area;				mostDevice = aDevice;			}		}		aDevice = GetNextDevice( aDevice);	}	if ( mostDevice != nil)	{		pmap = (**mostDevice).gdPMap;		if ( (**pmap).pixelSize > 1) *isColor = true;		return( (**pmap).pixelSize);	} else return ( 1);}void ShortenStringToWidth( StringPtr s, short width){	while ( StringWidth( s) > width)	{		s[0] = s[0] - 1;		if ( s[0] > 0)			s[s[0]] = 'É';	}}Rect *CU_GetControlBounds( ControlHandle aControl, Rect *bounds){#ifndef TARGET_API_MAC_CARBON	*bounds = (**aControl)->contrlRect;#else	GetControlBounds( aControl, bounds);#endif	return bounds;}