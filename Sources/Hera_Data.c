/******************************************\|**| Hera_Data.c\******************************************/#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Assert.h"#include "str_bp.h"#include "strlist.h"#include "BPMacOutput.h"#pragma mark _this library includes_/* - this project*******************************************/// ares#include "Space Object.h"#include "Scenario.h"#include "Scenario_Data.h"// hera#include "Hera_Global.h"#include "Hera_Utilities.h"#include "Hera_Data.h"#include "Hera_ResourceTracker.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kHD_Temporary_Flag_IsBeingChecked	0x8#pragma mark _macros_/* - macros*******************************************/#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/#pragma mark 본EXTERNAL GLOBALS본/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark 본PRIVATE GLOBALS본/******************************************\|**| private globals\******************************************/#pragma mark 본PRIVATE PROTOTYPES본/******************************************\|**| private function prototypes\******************************************/static OSErr AddOriginalBaseObjectDiscreteData( heraScenarioFileType *heraFile,	Handle baseObjectData, short *index,	Handle *discreteData, Handle *acillaryData);static void HD_CompileDiscreteData_Walker_CallBack( Handle discreteObjectData,	Handle discreteActionData, unsigned long userData);static long HD_GetDiscreteRealIndex( heraScenarioFileType *heraFile,	Handle originalData, long id, OSType dataType);static void Hack_CheckInitialData( Handle initialData, Handle baseObjectData,	Boolean assert);unsigned long Get_CheckSum( Handle data, unsigned long checkSum);#pragma mark 본PRIVATE FUNCTIONS본/******************************************\|**| private functions\******************************************/static OSErr AddOriginalBaseObjectDiscreteData( heraScenarioFileType *heraFile,	Handle baseObjectData, short *index,	Handle *discreteData, Handle *ancillaryData){	short						d, n;	OSErr						error = noErr;	Handle						tempAncillaryData = nil;	heraBaseObjectStringsType	baseObjectStrings;	Str255						s;		d = *index;	n = 1;	*discreteData = HD_Create_Discrete_Data( heraFile,		baseObjectData, d, n, d,		kHera_Object_Type);	if ( *discreteData != nil)	{		*index = ((heraDataHeaderType *)**discreteData)->id;	}	// we have to manually create ancillary string data	// for all discrete base objects	if ( *discreteData != nil)	{		tempAncillaryData = NewHandle( sizeof(									heraBaseObjectStringsType));				if ( tempAncillaryData != nil)		{			GetIndString( s, 5000, *index + 1);			if ( s[0] > kObjectNameLength) s[0] = kObjectNameLength;			pstrcpy( baseObjectStrings.longName, s);						GetIndString( s, 5001, *index + 1);			if ( s[0] > kObjectShortNameLength) s[0] = kObjectShortNameLength;			pstrcpy( baseObjectStrings.shortName, s);			GetIndString( s, 5002, *index + 1);			pstrcpy( baseObjectStrings.devNote, s);			BlockMove( &baseObjectStrings, *tempAncillaryData,				sizeof( heraBaseObjectStringsType));							*ancillaryData = HD_Create_Discrete_Data( heraFile,				tempAncillaryData, 0, 1, d, kHera_ObjectStrings_Type);			if ( *ancillaryData == nil)			{				error = memFullErr;				goto AddOriginalBaseObjectDiscreteData_error;			} else			{				if ( ((heraDataHeaderType *)**ancillaryData)->id					!= d)				{					error = 1;					goto AddOriginalBaseObjectDiscreteData_error;				}			}		} else		{			error = memFullErr;			goto AddOriginalBaseObjectDiscreteData_error;		}	}AddOriginalBaseObjectDiscreteData_error:	if ( tempAncillaryData != nil) DisposeHandle( tempAncillaryData);	mAssert( error == noErr);	return error;}static void HD_CompileDiscreteData_Walker_CallBack( Handle discreteObjectData,	Handle discreteActionData, unsigned long userData){	heraScenarioFileType		*heraFile = nil;#pragma unused( discreteActionData)	if ( discreteObjectData == nil) return;	//	BPMOWritePString("\pappending object:\t");//	BPMOWriteLong( ((heraDataHeaderType *)*discreteObjectData)->id);//	BPMOWritePString("\p\r");//	BPMOKeyWait();	//	if ( ((heraDataHeaderType *)*discreteObjectData)->flags) return;	heraFile = (heraScenarioFileType *)userData;	HD_AppendDiscrete( heraFile, heraFile->callBack_baseObjectData,		((heraDataHeaderType *)*discreteObjectData)->id, kHera_Object_Type);}static long HD_GetDiscreteRealIndex( heraScenarioFileType *heraFile,	Handle originalData, long id, OSType dataType){	Handle	discreteData = HD_Find_Discrete_Data( heraFile, id, -1, nil, dataType);		mAssert( originalData != nil);		if ( discreteData == nil) return -1;	if ( ((heraDataHeaderType *)*discreteData)->realIndex >= 0)		return ((heraDataHeaderType *)*discreteData)->realIndex;	//	mAssert( 1 != 1);	return -1;}static void Hack_CheckInitialData( Handle initialData, Handle baseObjectData,	Boolean assert){	long	max = GetHandleSize( initialData) / sizeof( scenarioInitialType);	long	k = GetHandleSize( baseObjectData) / sizeof(baseObjectType);	long	i, d;		for ( i = 0; i < max; i++)	{		scenarioInitialType *initial = ((scenarioInitialType *)*initialData) + i;						d = initial->type;		if ( assert)		{			mAssert( d >= 0);			mAssert( d < max);		}		if ( d < 0)		{			BPMOWritePString("\p>>> LOW  Initial Type: \t");			BPMOWriteLong( i);			BPMOWritePString("\p =\t");			BPMOWriteLong( d);			BPMOWritePString("\p/");			BPMOWriteLong( k);			BPMOWritePString("\p\t <<<\r");		}		if ( d >= k)		{			BPMOWritePString("\p>>> HIGH Initial Type \t");			BPMOWriteLong( i);			BPMOWritePString("\p =\t");			BPMOWriteLong( d);			BPMOWritePString("\p/");			BPMOWriteLong( k);			BPMOWritePString("\p\t <<<\r");		}	}}unsigned long Get_CheckSum( Handle data, unsigned long checkSum){	long			l, shiftCount = 0;	unsigned char	*c;		if ( data == nil) return checkSum;	l = GetHandleSize( data);	c = (unsigned char *)*data;	while ( l > 0)	{		checkSum ^= ((unsigned long)*c) << shiftCount;		shiftCount += 8;		c++;		if ( shiftCount >= 32) shiftCount = 0;		l--;	}	return checkSum;}#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/OSErr HD_InitDiscreteData( heraScenarioFileType *heraFile){	short					oldResFile, i, j, k, max, d, n;	baseObjectType			*base;	Handle					initialData = nil, actionData = nil,							conditionData = nil, briefPointData = nil,							discreteData = nil, data = nil, baseObjectData = nil;	OSErr					error = noErr;	scenarioConditionType	*condition;	objectActionType		*action;	scenarioType			*scenario;		HU_UseResFile( heraFile->fileRefNum, &oldResFile);	// first do objects	baseObjectData = HRT_Resource_GetEZ( heraFile, kHera_Object_Type, 500);	if ( baseObjectData == nil)	{		error = resNotFound;		goto HD_InitDiscreteData_error;	} 	actionData = HRT_Resource_GetEZ( heraFile, kHera_Action_Type, 500);	if ( actionData == nil)	{		error = resNotFound;		goto HD_InitDiscreteData_error;	}		initialData = HRT_Resource_GetEZ( heraFile, kHera_Initial_Type, 500);	if ( initialData == nil)	{		error = resNotFound;		goto HD_InitDiscreteData_error;	}		if ( heraFile->scenarioData == nil)	{		heraFile->scenarioData = HRT_Resource_GetEZ( heraFile, kHera_Scenario_Type, 500);		if ( heraFile->scenarioData == nil)		{			error = resNotFound;			goto HD_InitDiscreteData_error;		}		DetachResource( heraFile->scenarioData);		max = GetHandleSize( heraFile->scenarioData) / sizeof( scenarioType);/*		for ( i = 0; i < max; i++)		{			scenario = (scenarioType *)*heraFile->scenarioData + i;			for ( j = 0; j < kScenarioPlayerNum; j++)			{				scenario->player[j].netRaceFlags = scenario->netRaceFlags;			}		}*/	}		if ( heraFile->scenarioInfo == nil)	{		heraFile->scenarioInfo = HRT_Resource_GetEZ( heraFile, kScenario_Data_ResType,			kScenario_Data_ResID);				if ( heraFile->scenarioInfo == nil)		{			error = resNotFound;			goto HD_InitDiscreteData_error;		}		DetachResource( heraFile->scenarioInfo);	}		// first, go through and change all action's references from chapter #s	// to scenario indexes		max = GetHandleSize( actionData) / sizeof( objectActionType);	for ( i = 0; i < max; i++)	{		action = (objectActionType *)*actionData + i;				if (( action->verb == kDeclareWinner) &&			( action->argument.declareWinner.nextLevel > 0))		{			action->argument.declareWinner.nextLevel =				HD_ScenarioIndex_GetFromChapterNumber( heraFile->scenarioData,					action->argument.declareWinner.nextLevel);		}	}		max = GetHandleSize( baseObjectData) / sizeof( baseObjectType);	for ( i = 0; i < max; i++)	{		base = (baseObjectType *)*baseObjectData + i;		if ( base->destroyActionNum == 0xffffffff)		{			BPMOWritePString("\p>>>DESTROY<<<\r");			base->destroyActionNum = 0;		}		if ( base->expireActionNum == 0xffffffff)		{			BPMOWritePString("\p>>>EXPIRE<<<\r");			base->expireActionNum = 0;		}		if ( base->createActionNum == 0xffffffff)		{			BPMOWritePString("\p>>>CREATE<<<\r");			base->createActionNum = 0;		}		if ( base->collideActionNum == 0xffffffff)		{			BPMOWritePString("\p>>>COLLIDE<<<\r");			base->collideActionNum = 0;		}		if ( base->activateActionNum == 0xffffffff)		{			BPMOWritePString("\p>>>ACTIVATE<<<\r");			base->activateActionNum = 0;		}		if ( base->arriveActionNum == 0xffffffff)		{			BPMOWritePString("\p>>>ARRIVE<<<\r");			base->arriveActionNum = 0;		}		// if we're not optimized, add every object		if (((scenarioInfoType *)*(heraFile->scenarioInfo))->flags &			kScenario_Data_Flag_NotOptimized)		{			Handle	ancillaryData;						d = i;			AddOriginalBaseObjectDiscreteData( heraFile,								baseObjectData, &d, &discreteData,							&ancillaryData);		}				// object destroy action		base = (baseObjectType *)*baseObjectData + i;		if ( base->destroyAction >= 0)		{			d = base->destroyAction;			n = base->destroyActionNum & kDestroyActionNotMask;			discreteData = HD_Create_Discrete_Data( heraFile,				actionData, d, n, d,				kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( discreteData != nil)			{				base->destroyAction =									((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, kHera_Object_Type,					hera_data_byIndex, i);			} else			{				base->destroyAction = -1;			}		}		// object expire action		base = (baseObjectType *)*baseObjectData + i;				if ( base->expireAction >= 0)		{			d = base->expireAction;			n = base->expireActionNum;// & kDestroyActionNotMask;			discreteData = HD_Create_Discrete_Data( heraFile,				actionData, d, n, d,							kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( discreteData != nil)			{				base->expireAction =									((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, kHera_Object_Type,					hera_data_byIndex, i);			} else			{				base->expireAction = -1;			}		}		// object create action		base = (baseObjectType *)*baseObjectData + i;		if ( base->createAction >= 0)		{			d = base->createAction;			n = base->createActionNum;			discreteData = HD_Create_Discrete_Data( heraFile,				actionData, d, n, d,							kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( discreteData != nil)			{				base->createAction =									((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, kHera_Object_Type,					hera_data_byIndex, i);			} else			{				base->createAction = -1;			}		}		// object collide action		base = (baseObjectType *)*baseObjectData + i;		if ( base->collideAction >= 0)		{			d = base->collideAction;			n = base->collideActionNum;			discreteData = HD_Create_Discrete_Data( heraFile,				actionData, d, n, d,				kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( discreteData != nil)			{				base->collideAction =									((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, kHera_Object_Type,					hera_data_byIndex, i);			} else			{				base->collideAction = -1;			}		}		// object activate action		base = (baseObjectType *)*baseObjectData + i;		if ( base->activateAction >= 0)		{			d = base->activateAction;			n = base->activateActionNum & kPeriodicActionNotMask;			discreteData = HD_Create_Discrete_Data( heraFile,				actionData, d, n, d,				kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( discreteData != nil)			{				base->activateAction =									((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, kHera_Object_Type,					hera_data_byIndex, i);			} else			{				base->activateAction = -1;			}		}		// object arrive action		base = (baseObjectType *)*baseObjectData + i;		if ( base->arriveAction >= 0)		{			d = base->arriveAction;			n = base->arriveActionNum;			discreteData = HD_Create_Discrete_Data( heraFile,				actionData, d, n, d,				kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( discreteData != nil)			{				base->arriveAction =									((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, kHera_Object_Type,					hera_data_byIndex, i);			} else			{				base->arriveAction = -1;			}		}	}		conditionData = HRT_Resource_GetEZ( heraFile, kHera_Condition_Type, 500);	if ( conditionData == nil)	{		error = resNotFound;		goto HD_InitDiscreteData_error;	} 	max = GetHandleSize( conditionData) / sizeof( scenarioConditionType);	for ( i = 0; i < max; i++)	{		condition = (scenarioConditionType *)*conditionData + i;		if ( condition->startVerb >= 0)		{			d = condition->startVerb;			n = condition->verbNum;			discreteData = HD_Create_Discrete_Data( heraFile,				actionData, d, n, d,				 kHera_Action_Type);			condition = (scenarioConditionType *)*conditionData + i;			if ( discreteData != nil)			{				condition->startVerb =									((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, kHera_Condition_Type,					hera_data_byIndex, i);			} else			{				condition->startVerb = -1;			}		}	}		briefPointData = HRT_Resource_GetEZ( heraFile, kHera_BriefPoint_Type, 500);	if ( briefPointData == nil)	{		error = resNotFound;		goto HD_InitDiscreteData_error;	}		max = GetHandleSize( heraFile->scenarioData) / sizeof( scenarioType);	for ( i = 0; i < max; i++)	{		// make condition discrete data		scenario = (scenarioType *)*heraFile->scenarioData + i;		if ( scenario->conditionFirst >= 0)		{			d = scenario->conditionFirst;			n = scenario->conditionNum;			discreteData = HD_Create_Discrete_Data( heraFile,				conditionData, d, n, d,				kHera_Condition_Type);			scenario = (scenarioType *)*heraFile->scenarioData + i;			if ( discreteData != nil)			{				scenario->conditionFirst =									((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, kHera_Scenario_Type,					hera_data_byIndex, i);			} else			{				scenario->conditionFirst = -1;			}		}		// make briefing point discrete data		scenario = (scenarioType *)*heraFile->scenarioData + i;		if ( scenario->briefPointFirst >= 0)		{			d = scenario->briefPointFirst;			n = scenario->briefPointNum & kScenarioBriefMask;			discreteData = HD_Create_Discrete_Data( heraFile, briefPointData, d, n, d,				kHera_BriefPoint_Type);			scenario = (scenarioType *)*heraFile->scenarioData + i;			if ( discreteData != nil)			{				scenario->briefPointFirst =									((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, kHera_Scenario_Type,					hera_data_byIndex, i);			} else			{				scenario->briefPointFirst = -1;			}		}		// make initial discrete data		scenario = (scenarioType *)*heraFile->scenarioData + i;		if ( scenario->initialFirst >= 0)		{			long	initMax = (GetHandleSize( initialData) /						sizeof( scenarioInitialType));							d = scenario->initialFirst;			n = scenario->initialNum;			if (( d < 0) || ( (d + n) >= initMax) || ( n < 0))			{				BPMOWritePString("\p>> SCENARIO Bad:\t S: ");				BPMOWriteLong( i);				BPMOWritePString("\p \tF: ");				BPMOWriteLong( d);				BPMOWritePString("\p \tN: ");				BPMOWriteLong( n);				BPMOWritePString("\p / ");				BPMOWriteLong( initMax);				BPMOWritePString("\p\t<<\r");			}			discreteData = HD_Create_Discrete_Data( heraFile, initialData,				d, n, d, kHera_Initial_Type);			scenario = (scenarioType *)*heraFile->scenarioData + i;			if ( discreteData != nil)			{				scenario->initialFirst =									((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, kHera_Scenario_Type,					hera_data_byIndex, i);				{									long	elementNumber = HD_DiscreteData_GetElementNumber(								discreteData,								kHera_Initial_Type),							jkl;					scenarioInitialType	*initial = nil;								for ( jkl = 0; jkl < elementNumber; jkl++)					{						initial = (scenarioInitialType *)HD_DiscreteData_GetNthElementCopy(									discreteData, kHera_Initial_Type, jkl);						if (( initial->type >= 0) && ( initial->type <							(GetHandleSize( baseObjectData) /								sizeof( baseObjectType))))						{						} else						{																			BPMOWritePString("\p>>> ##ILLEGAL INITIAL TYPE\t");							BPMOWriteLong( i);							BPMOWritePString("\p: \t");							BPMOWriteLong( jkl);							BPMOWritePString("\p: \t");							BPMOWriteLong( initial->type);							BPMOWritePString("\p <<<\r");						}					}										}			} else			{				BPMOWritePString("\pINITIAL DATA WASN'T ADDED\r");				scenario->initialFirst = -1;			}		}	}//	BPMOKeyWait();	// on to base objects; first add "blessed" objects which may not otherwise	// be referenced		{		Handle	ancillaryData = nil;		// warp in flare		d = ((scenarioInfoType *)*(heraFile->scenarioInfo))->warpInFlareID;		if ( d >= 0)		{	AddOriginalBaseObjectDiscreteData( heraFile,					baseObjectData, &d, &discreteData,				&ancillaryData);			if ( discreteData != nil)			{				((scenarioInfoType *)*(heraFile->scenarioInfo))->warpInFlareID =					((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, -1,					hera_data_byID, ((heraDataHeaderType *)*discreteData)->id);			}		}						// warp out flare		d = ((scenarioInfoType *)*(heraFile->scenarioInfo))->warpOutFlareID;		if ( d >= 0)		{			AddOriginalBaseObjectDiscreteData( heraFile,					baseObjectData, &d, &discreteData,				&ancillaryData);			if ( discreteData != nil)			{				((scenarioInfoType *)*(heraFile->scenarioInfo))->warpOutFlareID =					((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, -1,					hera_data_byID, ((heraDataHeaderType *)*discreteData)->id);			}		}						// player body		d = ((scenarioInfoType *)*(heraFile->scenarioInfo))->playerBodyID;		if ( d >= 0)		{			AddOriginalBaseObjectDiscreteData( heraFile,					baseObjectData, &d, &discreteData,				&ancillaryData);			if ( discreteData != nil)			{				((scenarioInfoType *)*(heraFile->scenarioInfo))->playerBodyID =					((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, -1,					hera_data_byID, ((heraDataHeaderType *)*discreteData)->id);			}		}		// energy blob		d = ((scenarioInfoType *)*(heraFile->scenarioInfo))->energyBlobID;		if ( d >= 0)		{			AddOriginalBaseObjectDiscreteData( heraFile,					baseObjectData, &d, &discreteData,				&ancillaryData);			if ( discreteData != nil)			{				((scenarioInfoType *)*(heraFile->scenarioInfo))->energyBlobID =					((heraDataHeaderType *)*discreteData)->id;				HD_Add_Reference( discreteData, -1,					hera_data_byID, ((heraDataHeaderType *)*discreteData)->id);			}		}					}				// now we have to go back and get all discrete action data and	// make base object discrete data		// first retrace action data	data = HD_DiscreteData_GetNextOfType( heraFile, nil, kHera_Action_Type);	while ( data != nil)	{		long	elementNumber = HD_DiscreteData_GetElementNumber( data,					kHera_Action_Type);				for ( i = 0; i < elementNumber; i++)		{			Handle	ancillaryData = nil;						action = (objectActionType *)HD_DiscreteData_GetNthElementCopy(						data, kHera_Action_Type, i);						mAssert( action != nil);						discreteData = ancillaryData = nil;						if ( action != nil)			{				// check for any action which refers to any base object				// that's create actions, create w/ inherit actions,				// and alter actions of type alter base type								if (( action->verb == kCreateObject) || ( action->verb ==					kCreateObjectSetDest))				{					d = action->argument.createObject.whichBaseType;					AddOriginalBaseObjectDiscreteData( heraFile,							baseObjectData, &d, &discreteData,						&ancillaryData);					/*					d = action->argument.createObject.whichBaseType;					n = 1;					discreteData = HD_Create_Discrete_Data(						heraFile->baseObjectData, d, n, d,						kHera_Object_Type);*/					if ( discreteData != nil)					{						action->argument.createObject.whichBaseType =							((heraDataHeaderType *)*discreteData)->id;						HD_Add_Reference( discreteData, kHera_Action_Type,							hera_data_byID, ((heraDataHeaderType *)*data)->id);					} else					{						action->argument.createObject.whichBaseType = -1;					}				} else if (( action->verb == kAlter) &&					( action->argument.alterObject.alterType ==						kAlterBaseType))				{					d = action->argument.alterObject.minimum;					AddOriginalBaseObjectDiscreteData( heraFile,							baseObjectData, &d, &discreteData,						&ancillaryData);					if ( discreteData != nil)					{						action->argument.alterObject.minimum =							((heraDataHeaderType *)*discreteData)->id;						HD_Add_Reference( discreteData, kHera_Action_Type,							hera_data_byID, ((heraDataHeaderType *)*data)->id);					} else					{						action->argument.alterObject.minimum = -1;					}				}				HD_DiscreteData_SetNthElementFromCopy( data,					kHera_Action_Type, i, (void *)action);				DisposePtr( (Ptr)action);				action = nil;							} else			{				error = memFullErr;				goto HD_InitDiscreteData_error;			}		}						data = HD_DiscreteData_GetNextOfType( heraFile, data, kHera_Action_Type);	}		// next to do is initial objects; we have to go through scenarios	// so we can track objects whose basetype might change depending on	// race of player		max = GetHandleSize( heraFile->scenarioData) / sizeof( scenarioType);	for ( k = 0; k < max; k++)	{		// make condition discrete data		scenario = (scenarioType *)*heraFile->scenarioData + k;				data = HD_Find_Discrete_Data( heraFile, scenario->initialFirst, scenario->initialNum,			nil, kHera_Initial_Type);		if ( data != nil)		{			long	elementNumber = HD_DiscreteData_GetElementNumber( data,						kHera_Initial_Type);			scenarioInitialType	*initial = nil;						for ( i = 0; i < elementNumber; i++)			{				Handle	ancillaryData = nil;								initial = (scenarioInitialType *)HD_DiscreteData_GetNthElementCopy(							data, kHera_Initial_Type, i);								mAssert( initial != nil);								discreteData = ancillaryData = nil;								if ( initial != nil)				{					long	baseObjectClass, baseObjectNum;										if (( initial->type >= 0) && ( initial->type <						(GetHandleSize( baseObjectData) /							sizeof( baseObjectType))))				{					base = ((baseObjectType *)*baseObjectData) + initial->type;					baseObjectClass = base->baseClass;										n = d = initial->type;					AddOriginalBaseObjectDiscreteData( heraFile,							baseObjectData, &d, &discreteData,						&ancillaryData);					if ( discreteData != nil)					{						initial->type =							((heraDataHeaderType *)*discreteData)->id;						HD_Add_Reference( discreteData, kHera_Initial_Type,							hera_data_byID, ((heraDataHeaderType *)*data)->id);					} else					{						initial->type = -1;					}										base = (baseObjectType *)HD_DiscreteData_GetNthElement(						discreteData, kHera_Object_Type, 0);					mAssert( base != nil);										// if this initial type is a base object which can build,					// we have to run through all possible objects which could					// get built, depending on possible races for players					if ( base->attributes & kCanAcceptBuild)					{						long	m;												baseObjectNum = GetHandleSize( baseObjectData) /										sizeof( baseObjectType);												for ( m = 0; m < kMaxTypeBaseCanBuild; m++)						{							if ( initial->canBuild[m] > 0)							{								for ( j = 0; j < baseObjectNum; j++)								{									base = ((baseObjectType *)*baseObjectData) + j;									if ((initial->canBuild[m] == 860) &&										( base->baseClass == 860) && ( base->baseRace == 900))									{										BPMOWritePString("\p\rhuman assault transport\r");									}									if (( base->baseClass == initial->canBuild[m]) &&										( j != n) && ( HD_IsRaceLegalForScenarioPlayer(											heraFile,											 heraFile->scenarioData, k, base->baseRace,											 -1)))									{										d = j;										AddOriginalBaseObjectDiscreteData( heraFile,												baseObjectData, &d, &discreteData,											&ancillaryData);										if ( discreteData != nil)										{											HD_Add_Reference( discreteData, kHera_Initial_Type,												hera_data_byID, ((heraDataHeaderType *)*data)->id);										}									}								}							}						}					} else if ((!( initial->attributes & kFixedRace)) &&						( baseObjectClass > 0) && ( HD_IsScenarioNetworkable(							heraFile->scenarioData, k)) && ( initial->owner >= 0))					{						// if initial object's race is not fixed, we have to run through						// all objects that match specified class						baseObjectNum = GetHandleSize( baseObjectData) /										sizeof( baseObjectType);												for ( j = 0; j < baseObjectNum; j++)						{							base = ((baseObjectType *)*baseObjectData) + j;														if (( base->baseClass == baseObjectClass) &&								( j != n) && ( HD_IsRaceLegalForScenarioPlayer(									heraFile,									 heraFile->scenarioData, k, base->baseRace,									 initial->owner)))							{								d = j;								AddOriginalBaseObjectDiscreteData( heraFile,										baseObjectData, &d, &discreteData,									&ancillaryData);								if ( discreteData != nil)								{									HD_Add_Reference( discreteData, kHera_Initial_Type,										hera_data_byID, ((heraDataHeaderType *)*data)->id);								}							}						}					}										HD_DiscreteData_SetNthElementFromCopy( data,						kHera_Initial_Type, i, (void *)initial);					DisposePtr( (Ptr)initial);					initial = nil;										// we have to manually create ancillary string data					// for all discrete base objects					if ( discreteData == nil)					{						error = memFullErr;						goto HD_InitDiscreteData_error;					}				} else					{						BPMOWritePString("\p>>> ILLEGAL INITIAL TYPE\t");						BPMOWriteLong( k);						BPMOWritePString("\p: \t");						BPMOWriteLong( initial->type);						BPMOWritePString("\p <<<\r");											}				} else				{					error = memFullErr;					goto HD_InitDiscreteData_error;				}			}					}	}		// finally, look at all the objects we've added	// and add all of their weapons	// fisrt retrace action data	data = HD_DiscreteData_GetNextOfType( heraFile, nil, kHera_Object_Type);	while ( data != nil)	{		Handle			ancillaryData = nil;				base = (baseObjectType *)HD_DiscreteData_GetNthElementCopy(					data, kHera_Object_Type, 0);				mAssert( base != nil);				discreteData = ancillaryData = nil;				if ( base != nil)		{			if (base->pulse > 0)			{				d = base->pulse;				AddOriginalBaseObjectDiscreteData( heraFile,							baseObjectData, &d, &discreteData,					&ancillaryData);								if ( discreteData != nil)				{					base->pulse =						((heraDataHeaderType *)*discreteData)->id;					HD_Add_Reference( discreteData, kHera_Object_Type,						hera_data_byID, ((heraDataHeaderType *)*data)->id);				} else				{					base->pulse = -1;				}			}			if (base->beam > 0)			{				d = base->beam;				AddOriginalBaseObjectDiscreteData( heraFile,							baseObjectData, &d, &discreteData,					&ancillaryData);								if ( discreteData != nil)				{					base->beam =						((heraDataHeaderType *)*discreteData)->id;					HD_Add_Reference( discreteData, kHera_Object_Type,						hera_data_byID, ((heraDataHeaderType *)*data)->id);				} else				{					base->beam = -1;				}			}			if (base->special > 0)			{				d = base->special;				AddOriginalBaseObjectDiscreteData( heraFile,							baseObjectData, &d, &discreteData,					&ancillaryData);								if ( discreteData != nil)				{					base->special =						((heraDataHeaderType *)*discreteData)->id;					HD_Add_Reference( discreteData, kHera_Object_Type,						hera_data_byID, ((heraDataHeaderType *)*data)->id);				} else				{					base->special = -1;				}			}			HD_DiscreteData_SetNthElementFromCopy( data,				kHera_Object_Type, 0, (void *)base);			DisposePtr( (Ptr)base);			base = nil;					} else		{			error = memFullErr;			goto HD_InitDiscreteData_error;		}		data = HD_DiscreteData_GetNextOfType( heraFile, data, kHera_Object_Type);	}			error = noErr;		// fall through |	//              V	HD_InitDiscreteData_error:	if ( actionData != nil) DisposeHandle( actionData);	if ( conditionData != nil) DisposeHandle( conditionData);	if ( briefPointData != nil) DisposeHandle( briefPointData);	if ( initialData != nil) DisposeHandle( initialData);	if ( baseObjectData != nil) DisposeHandle( baseObjectData);	UseResFile( oldResFile);	return error;}OSErr HD_CompileDiscreteData( heraScenarioFileType *heraFile, Boolean optimize){	short					oldResFile, i, d;	baseObjectType			*base;	Handle					actionData = nil, conditionData = nil,							baseObjectData = nil, initialData = nil,							briefPointData = nil, shortNameStrings = nil,							longNameStrings = nil, devNoteStrings = nil,							discreteData = nil, tempScenarioData;	OSErr					error = noErr;	scenarioConditionType	*condition;	scenarioInitialType		*initial;	scenarioType			*scenario;	objectActionType		*action;	long					scenarioNumber, number;	scenarioInfoType		tempScenarioInfo;	unsigned long			checkSum = 0;		if ( heraFile->fileRefNum <= 0) return paramErr;		HU_UseResFile( heraFile->fileRefNum, &oldResFile);		HD_DiscreteData_SetAllFlags( heraFile, 0, 0, 0xffffffff);	HD_DiscreteData_ClearAllRealIndexes( heraFile, 0);		tempScenarioData = heraFile->scenarioData;	if ( tempScenarioData != nil)	{		HandToHand( &tempScenarioData);		error = MemError();		mAssert( error == noErr);		if ( error != noErr)		{			error = memFullErr;			goto HD_CompileDiscreteData_error;		}	}	if ( !optimize)			((scenarioInfoType *)*(heraFile->scenarioInfo))->flags =			((scenarioInfoType *)*(heraFile->scenarioInfo))->flags |			kScenario_Data_Flag_NotOptimized;			heraFile->callBack_actionData = actionData = NewHandle(0);	mAssert( actionData != nil);	if ( actionData == nil)	{		error = memFullErr;		goto HD_CompileDiscreteData_error;	}	heraFile->callBack_baseObjectData = baseObjectData = NewHandle(0);	mAssert( baseObjectData != nil);	if ( baseObjectData == nil)	{		error = memFullErr;		goto HD_CompileDiscreteData_error;	}	heraFile->callBack_conditionData = conditionData = NewHandle(0);	mAssert( conditionData != nil);	if ( conditionData == nil)	{		error = memFullErr;		goto HD_CompileDiscreteData_error;	}	heraFile->callBack_initialData = initialData = NewHandle(0);	mAssert( initialData != nil);	if ( initialData == nil)	{		error = memFullErr;		goto HD_CompileDiscreteData_error;	}	heraFile->callBack_briefPointData = briefPointData = NewHandle(0);	mAssert( briefPointData != nil);	if ( briefPointData == nil)	{		error = memFullErr;		goto HD_CompileDiscreteData_error;	}	shortNameStrings = NewStringList();	mAssert( shortNameStrings != nil);	if ( shortNameStrings == nil)	{		error = memFullErr;		goto HD_CompileDiscreteData_error;	}	longNameStrings = NewStringList();	mAssert( longNameStrings != nil);	if ( longNameStrings == nil)	{		error = memFullErr;		goto HD_CompileDiscreteData_error;	}	devNoteStrings = NewStringList();	mAssert( devNoteStrings != nil);	if ( devNoteStrings == nil)	{		error = memFullErr;		goto HD_CompileDiscreteData_error;	}//	heraFile->actionID = 0;//	heraFile->objectID = 0;//	heraFile->initialID = 0;//	heraFile->conditionID = 0;		if ( heraFile->scenarioInfo != nil)	{		BlockMove( *heraFile->scenarioInfo, &tempScenarioInfo,			sizeof( scenarioInfoType));	}		discreteData = HD_DiscreteData_GetNextOfType( heraFile, nil,											kHera_Object_Type);	// first we have to clear all the flags from the object's discrete data	discreteData = HD_DiscreteData_GetNextOfType( heraFile, nil, kHera_Object_Type);	while ( discreteData != nil)	{		((heraDataHeaderType *)*discreteData)->flags = 0;		discreteData = HD_DiscreteData_GetNextOfType( heraFile, discreteData,							kHera_Object_Type);	}		// we also have to clear flags from all actions	discreteData = HD_DiscreteData_GetNextOfType( heraFile, nil, kHera_Action_Type);	while ( discreteData != nil)	{		((heraDataHeaderType *)*discreteData)->flags = 0;		discreteData = HD_DiscreteData_GetNextOfType( heraFile, discreteData,							kHera_Action_Type);	}	// if we're not optimizing, just add every damn object	if ( !optimize)	{		discreteData = HD_DiscreteData_GetNextOfType( heraFile, nil,			kHera_Object_Type);		while ( discreteData != nil)		{			BPMOWritePString("\padding:\t");			base = (baseObjectType *)HD_DiscreteData_GetNthElement( discreteData,						kHera_Object_Type, 0);						BPMOWriteLong( base->baseClass);			BPMOWritePString("\p\r");						HD_AppendDiscrete( heraFile, baseObjectData,				((heraDataHeaderType *)*discreteData)->id,				kHera_Object_Type);			((heraDataHeaderType *)*discreteData)->flags |= 0x01;			discreteData = HD_DiscreteData_GetNextOfType( heraFile, discreteData,				kHera_Object_Type);					}				discreteData = HD_DiscreteData_GetNextOfType( heraFile, nil,			kHera_Action_Type);		while ( discreteData != nil)		{			HD_AppendDiscrete( heraFile, actionData,				((heraDataHeaderType *)*discreteData)->id,				kHera_Action_Type);			((heraDataHeaderType *)*discreteData)->flags |= 0x01;			discreteData = HD_DiscreteData_GetNextOfType( heraFile, discreteData,				kHera_Action_Type);		}	}	if ( ((scenarioInfoType *)*(heraFile->scenarioInfo))->playerBodyID >= 0)	{		HD_ObjectWalker( heraFile, 			((scenarioInfoType *)*(heraFile->scenarioInfo))->playerBodyID,			(unsigned long)heraFile,			HD_CompileDiscreteData_Walker_CallBack);		discreteData = HD_Find_Discrete_Data( heraFile,			((scenarioInfoType *)*(heraFile->scenarioInfo))->playerBodyID,			1, nil, kHera_Object_Type);		if ( discreteData != nil)		{			((scenarioInfoType *)*(heraFile->scenarioInfo))->playerBodyID =				((heraDataHeaderType *)*discreteData)->realIndex;		}	}		if ( ((scenarioInfoType *)*(heraFile->scenarioInfo))->energyBlobID >= 0)	{		HD_ObjectWalker( heraFile, 			((scenarioInfoType *)*(heraFile->scenarioInfo))->energyBlobID,			(unsigned long)heraFile,			HD_CompileDiscreteData_Walker_CallBack);		discreteData = HD_Find_Discrete_Data( heraFile,			((scenarioInfoType *)*(heraFile->scenarioInfo))->energyBlobID,			1, nil, kHera_Object_Type);		if ( discreteData != nil)		{			((scenarioInfoType *)*(heraFile->scenarioInfo))->energyBlobID =				((heraDataHeaderType *)*discreteData)->realIndex;		}	}	if ( ((scenarioInfoType *)*(heraFile->scenarioInfo))->warpInFlareID >= 0)	{		HD_ObjectWalker( heraFile, 			((scenarioInfoType *)*(heraFile->scenarioInfo))->warpInFlareID,			(unsigned long)heraFile,			HD_CompileDiscreteData_Walker_CallBack);		discreteData = HD_Find_Discrete_Data( heraFile,			((scenarioInfoType *)*(heraFile->scenarioInfo))->warpInFlareID,			1, nil, kHera_Object_Type);		if ( discreteData != nil)		{			((scenarioInfoType *)*(heraFile->scenarioInfo))->warpInFlareID =				((heraDataHeaderType *)*discreteData)->realIndex;		}	}	if ( ((scenarioInfoType *)*(heraFile->scenarioInfo))->warpOutFlareID >= 0)	{		HD_ObjectWalker( heraFile, 			((scenarioInfoType *)*(heraFile->scenarioInfo))->warpOutFlareID,			(unsigned long)heraFile,			HD_CompileDiscreteData_Walker_CallBack);		discreteData = HD_Find_Discrete_Data( heraFile,			((scenarioInfoType *)*(heraFile->scenarioInfo))->warpOutFlareID,			1, nil, kHera_Object_Type);		if ( discreteData != nil)		{			((scenarioInfoType *)*(heraFile->scenarioInfo))->warpOutFlareID =				((heraDataHeaderType *)*discreteData)->realIndex;		}	}		scenarioNumber = 0;		// repeat for each scnario recorded	while ( scenarioNumber < (GetHandleSize( tempScenarioData) /		sizeof( scenarioType)))	{						// step through all initial objects and do an object walk for each		// we have to jump through hoops to support the building of objects		// from various races and objects with non-fixed races in net		// scenarios				BPMOWritePString("\p\r\r>> NEW SCENARIO:\t");		BPMOWriteLong( scenarioNumber);		BPMOWritePString("\p <<\r\r");		BPMOSetKeySkip( false);				scenario = ((scenarioType *)*tempScenarioData) + scenarioNumber;				discreteData = HD_Find_Discrete_Data( heraFile,			scenario->initialFirst, scenario->initialNum,			nil, kHera_Initial_Type);				mAssert( discreteData != nil);		if ( discreteData != nil)		{			number = HD_DiscreteData_GetElementNumber( discreteData,				kHera_Initial_Type);			for ( i = 0; i < number; i++)			{				long			baseObjectClass;				Handle			discreteObjectData = nil;				baseObjectType	*base;								initial = (scenarioInitialType *)					HD_DiscreteData_GetNthElement( discreteData,						kHera_Initial_Type, i);								mAssert( initial != nil);								discreteObjectData = HD_Find_Discrete_Data( heraFile,					initial->type, 1, nil, kHera_Object_Type);								mAssert( discreteObjectData != nil);				if ( discreteObjectData != nil)				{					long		baseClass, baseRace;										HD_ObjectWalker( heraFile, 						((heraDataHeaderType *)*discreteObjectData)->id,						(unsigned long)heraFile,						HD_CompileDiscreteData_Walker_CallBack);					base = (baseObjectType *)HD_DiscreteData_GetNthElement(						discreteObjectData, kHera_Object_Type, 0);										mAssert( base != nil);					baseClass = base->baseClass;					baseRace = base->baseRace;										if ( base->attributes & kCanAcceptBuild)					{						long	m;						//						BPMOWritePString("\pobject can build; checking텦r");						for ( m = 0; m < kMaxTypeBaseCanBuild; m++)						{//							BPMOWritePString("\pbuild slot\t");//							BPMOWriteLong( m);//							BPMOWritePString("\p\r------------\r");														initial = (scenarioInitialType *)								HD_DiscreteData_GetNthElement( discreteData,									kHera_Initial_Type, i);							if ( initial->canBuild[m] > 0)							{								discreteObjectData =										HD_DiscreteData_GetNextOfType(												heraFile, nil, kHera_Object_Type);															while ( discreteObjectData != nil)								{									initial = (scenarioInitialType *)										HD_DiscreteData_GetNthElement( discreteData,											kHera_Initial_Type, i);									base = (baseObjectType *)										HD_DiscreteData_GetNthElement(										discreteObjectData, kHera_Object_Type, 0);									if (											(												base->baseClass ==													initial->canBuild[m]											)											&&											(												HD_IsRaceLegalForScenarioPlayer(												heraFile,  tempScenarioData,												scenarioNumber,												 base->baseRace,												 -1)											)										)									{//										BPMOWritePString("\pwalking:\t");//										BPMOWriteLong( ((heraDataHeaderType *)*discreteObjectData)->id);//										BPMOWritePString("\p\r");																				HD_ObjectWalker( heraFile, 											((heraDataHeaderType *)*discreteObjectData)->id,											(unsigned long)heraFile,											HD_CompileDiscreteData_Walker_CallBack);									}									discreteObjectData =										HD_DiscreteData_GetNextOfType(											heraFile, 											discreteObjectData,											kHera_Object_Type);								}							}						}					} else if ((!( initial->attributes & kFixedRace)) &&						( baseObjectClass > 0) && ( HD_IsScenarioNetworkable(							tempScenarioData, scenarioNumber)) &&							( initial->owner >= 0))					{						// if initial object's race is not fixed, we have to run through						// all objects that match specified class						discreteObjectData =								HD_DiscreteData_GetNextOfType( heraFile, 										nil, kHera_Object_Type);						while ( discreteObjectData != nil)						{							initial = (scenarioInitialType *)								HD_DiscreteData_GetNthElement( discreteData,									kHera_Initial_Type, i);							base = (baseObjectType *)								HD_DiscreteData_GetNthElement(								discreteObjectData, kHera_Object_Type, 0);														if (( base->baseClass == baseClass) &&								( HD_IsRaceLegalForScenarioPlayer( heraFile, 									 tempScenarioData, scenarioNumber,									 base->baseRace,									 initial->owner)))							{								HD_ObjectWalker( heraFile, 									((heraDataHeaderType *)*discreteObjectData)->id,									(unsigned long)heraFile,									HD_CompileDiscreteData_Walker_CallBack);							}							discreteObjectData =								HD_DiscreteData_GetNextOfType(heraFile, 										discreteObjectData, kHera_Object_Type);						}					}									initial = (scenarioInitialType *)						HD_DiscreteData_GetNthElement( discreteData,							kHera_Initial_Type, i);					HD_ObjectWalker( heraFile, initial->type, (unsigned long)heraFile,						HD_CompileDiscreteData_Walker_CallBack);				}							}		}				// now we'll check the scenario conditions and all of the		// actions they invoke				scenario = ((scenarioType *)*tempScenarioData) + scenarioNumber;		discreteData = HD_Find_Discrete_Data( heraFile, scenario->conditionFirst,											scenario->conditionNum,											nil, kHera_Condition_Type);		//		mAssert( discreteData != nil);		if ( discreteData != nil)		{			number = HD_DiscreteData_GetElementNumber( discreteData,				kHera_Condition_Type);			for ( i = 0; i < number; i++)			{				Handle					discreteActionData = nil;				scenarioConditionType	*condition;								condition = (scenarioConditionType *)					HD_DiscreteData_GetNthElement( discreteData,						kHera_Condition_Type, i);								mAssert( condition != nil);								if ( condition->startVerb >= 0)				{					discreteActionData = HD_Find_Discrete_Data(heraFile, 						condition->startVerb, condition->verbNum, nil,						kHera_Action_Type);										HD_ObjectWalker_ActionWalker( heraFile, discreteActionData,						(unsigned long)heraFile, HD_CompileDiscreteData_Walker_CallBack);				}			}		}				// while going through the scenarios we'll resolve the intial,		// brief point, and condition data				scenario = ((scenarioType *)*tempScenarioData) + scenarioNumber;		d = scenario->initialFirst;		d = HD_AppendDiscrete( heraFile, initialData, d, kHera_Initial_Type);		if ( d >= 0)		{			scenario = ((scenarioType *)*tempScenarioData) +				scenarioNumber;			scenario->initialFirst = d;			{				long	initMax = (GetHandleSize( initialData) /							sizeof( scenarioInitialType)),						n;									d = scenario->initialFirst;				n = scenario->initialNum;				if (( d < 0) || ( (d + n) > initMax) || ( n < 0))				{					BPMOWritePString("\p>> SCENARIO Bad:\t S: ");					BPMOWriteLong( scenarioNumber);					BPMOWritePString("\p \tF: ");					BPMOWriteLong( d);					BPMOWritePString("\p \tN: ");					BPMOWriteLong( n);					BPMOWritePString("\p / ");					BPMOWriteLong( initMax);					BPMOWritePString("\p\t<<\r");				}			}		}				scenario = ((scenarioType *)*tempScenarioData) + scenarioNumber;		d = scenario->conditionFirst;		d = HD_AppendDiscrete( heraFile, conditionData, d, kHera_Condition_Type);		if ( d >= 0)		{			scenario = ((scenarioType *)*tempScenarioData) +				scenarioNumber;			scenario->conditionFirst = d;		}				scenario = ((scenarioType *)*tempScenarioData) + scenarioNumber;		d = scenario->briefPointFirst;		d = HD_AppendDiscrete( heraFile, briefPointData, d, kHera_BriefPoint_Type);		if ( d >= 0)		{			scenario = ((scenarioType *)*tempScenarioData) +				scenarioNumber;			scenario->briefPointFirst = d;		}				scenarioNumber++;	}		// now that we've resolved all base objects, we'll go through	// and make sure all action references point to the resolved indexes	// -- commented out b/c we don't want to alter the discrete data	// -- the compiled action data is acted on below/*	discreteData = HD_DiscreteData_GetNextOfType( heraFile, nil,		kHera_Action_Type);	while ( discreteData != nil)	{		if (((heraDataHeaderType *)*discreteData)->flags)		{			number = HD_DiscreteData_GetElementNumber( discreteData,				kHera_Action_Type);						for ( i = 0; i < number; i++)			{				action = (objectActionType *)					HD_DiscreteData_GetNthElement( discreteData,						kHera_Action_Type, i);								if (( action->verb == kCreateObject) || ( action->verb ==					kCreateObjectSetDest))				{					d = action->argument.createObject.whichBaseType;					d = HD_GetDiscreteRealIndex( heraFile, baseObjectData,						d,						kHera_Object_Type);					action = (objectActionType *)						HD_DiscreteData_GetNthElement( discreteData,							kHera_Action_Type, i);					if ( d >= 0)						action->argument.createObject.whichBaseType = d;				} else if (( action->verb == kAlter) &&					( action->argument.alterObject.alterType ==						kAlterBaseType))				{					d = action->argument.alterObject.minimum;					d = HD_GetDiscreteRealIndex( heraFile, baseObjectData,						d,						kHera_Object_Type);					action = (objectActionType *)						HD_DiscreteData_GetNthElement( discreteData,							kHera_Action_Type, i);					if ( d >= 0)						d = action->argument.alterObject.minimum = d;				}			}					}		discreteData = HD_DiscreteData_GetNextOfType( heraFile, discreteData,							kHera_Action_Type);	}*/		// make sure all initial references point to the resolved object indexes		number = GetHandleSize( initialData) / sizeof( scenarioInitialType);	for ( i = 0; i < number; i++)	{		initial = ((scenarioInitialType *)*initialData) + i;						d = initial->type;		d =  HD_GetDiscreteRealIndex( heraFile, baseObjectData,				d, kHera_Object_Type);		initial = ((scenarioInitialType *)*initialData) + i;		mAssert( d >= 0);		mAssert( d < (GetHandleSize( baseObjectData) / sizeof(baseObjectType)));		if ( d >= 0)			initial->type = d;	}		// resolve all base object weapon and action data	number = GetHandleSize( baseObjectData) / sizeof( baseObjectType);		for ( i = 0; i < number; i++)	{		StringListAppend( shortNameStrings, "\p");		StringListAppend( longNameStrings, "\p");		StringListAppend( devNoteStrings, "\p");		// object destroy action		base = (baseObjectType *)*baseObjectData + i;		if ( base->destroyAction >= 0)		{			d = base->destroyAction;			d = HD_AppendDiscrete( heraFile, actionData, d, kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( d >= 0)			{				base->destroyAction = d;			} else			{				error = memFullErr;				mAssert( error == noErr);				goto HD_CompileDiscreteData_error;			}		}		// object expire action		base = (baseObjectType *)*baseObjectData + i;		if ( base->expireAction >= 0)		{			d = base->expireAction;			d = HD_AppendDiscrete( heraFile, actionData, d, kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( d >= 0)			{				base->expireAction = d;			} else			{				error = memFullErr;				mAssert( error == noErr);				goto HD_CompileDiscreteData_error;			}		}		// object create action		base = (baseObjectType *)*baseObjectData + i;		if ( base->createAction >= 0)		{			d = base->createAction;			d = HD_AppendDiscrete( heraFile, actionData, d, kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( d >= 0)			{				base->createAction = d;			} else			{				error = memFullErr;				mAssert( error == noErr);				goto HD_CompileDiscreteData_error;			}		}		// object collide action		base = (baseObjectType *)*baseObjectData + i;		if ( base->collideAction >= 0)		{			d = base->collideAction;			d = HD_AppendDiscrete( heraFile, actionData, d, kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( d >= 0)			{				base->collideAction = d;			} else			{				error = memFullErr;				mAssert( error == noErr);				goto HD_CompileDiscreteData_error;			}		}		// object activate action		base = (baseObjectType *)*baseObjectData + i;		if ( base->activateAction >= 0)		{			d = base->activateAction;			d = HD_AppendDiscrete( heraFile, actionData, d, kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( d >= 0)			{				base->activateAction = d;			} else			{				error = memFullErr;				mAssert( error == noErr);				goto HD_CompileDiscreteData_error;			}		}		// object arrive action		base = (baseObjectType *)*baseObjectData + i;		if ( base->arriveAction >= 0)		{			d = base->arriveAction;			d = HD_AppendDiscrete( heraFile, actionData, d, kHera_Action_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( d >= 0)			{				base->arriveAction = d;			} else			{				error = memFullErr;				mAssert( error == noErr);				goto HD_CompileDiscreteData_error;			}		}				// do the weapons as well (remember, all base objects have been		// resolved)				base = (baseObjectType *)*baseObjectData + i;		d = base->pulse;		if ( d >= 0)		{			d = HD_GetDiscreteRealIndex( heraFile, baseObjectData, d, kHera_Object_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( d >= 0)				base->pulse = d;		}		base = (baseObjectType *)*baseObjectData + i;		d = base->beam;		if ( d >= 0)		{			d = HD_GetDiscreteRealIndex( heraFile, baseObjectData, d, kHera_Object_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( d >= 0)				base->beam = d;		}		base = (baseObjectType *)*baseObjectData + i;		d = base->special;		if ( d >= 0)		{			d = HD_GetDiscreteRealIndex( heraFile, baseObjectData, d, kHera_Object_Type);			base = (baseObjectType *)*baseObjectData + i;			if ( d >= 0)				base->special = d;		}	}	// go through all base objects, find the ones that have been resolved,	// and install their name strings		discreteData = HD_DiscreteData_GetNextOfType( heraFile, nil,		kHera_Object_Type);	while ( discreteData != nil)	{				i = ((heraDataHeaderType *)*discreteData)->realIndex;		if ( i >= 0)		{			Handle						discreteStringData = nil;			heraBaseObjectStringsType	*objectStrings;						d = ((heraDataHeaderType *)*discreteData)->id;			discreteStringData = HD_Find_Discrete_Data( heraFile, d,				1, nil, kHera_ObjectStrings_Type);			if ( discreteStringData != nil)			{				objectStrings =					(heraBaseObjectStringsType *)HD_DiscreteData_GetNthElementCopy(						discreteStringData, kHera_ObjectStrings_Type, 0);				if ( objectStrings != nil)				{					StringListRemove( shortNameStrings, i + 1);					StringListRemove( longNameStrings, i + 1);					StringListRemove( devNoteStrings, i + 1);					StringListInstall( shortNameStrings, i + 1,						objectStrings->shortName);										BPMOWritePString("\padding string:\t");					BPMOWritePString( objectStrings->longName);					BPMOWritePString("\p\r");										StringListInstall( longNameStrings, i + 1,						objectStrings->longName);					StringListInstall( devNoteStrings, i + 1,						objectStrings->devNote);					DisposePtr( (Ptr)objectStrings);				}			}					}		discreteData = HD_DiscreteData_GetNextOfType( heraFile, discreteData,			kHera_Object_Type);	}		number = GetHandleSize( conditionData) / sizeof( scenarioConditionType);	for ( i = 0; i < number; i++)	{		condition = (scenarioConditionType *)*conditionData + i;		if ( condition->startVerb >= 0)		{			d = condition->startVerb;			d = HD_AppendDiscrete( heraFile, actionData, d, kHera_Action_Type);			if ( d >= 0)			{				condition->startVerb = d;			} else			{				error = memFullErr;				mAssert( error == noErr);				goto HD_CompileDiscreteData_error;			}		}	}	number = GetHandleSize( actionData) / sizeof( objectActionType);		for ( i = 0; i < number; i++)	{		action = ((objectActionType *)*actionData) + i;				if (( action->verb == kCreateObject) || ( action->verb ==			kCreateObjectSetDest))		{			d = action->argument.createObject.whichBaseType;			d = HD_GetDiscreteRealIndex( heraFile, baseObjectData,				d,				kHera_Object_Type);			action = ((objectActionType *)*actionData) + i;					if ( d >= 0)				action->argument.createObject.whichBaseType = d;		} else if (( action->verb == kAlter) &&			( action->argument.alterObject.alterType ==				kAlterBaseType))		{			d = action->argument.alterObject.minimum;			d = HD_GetDiscreteRealIndex( heraFile, baseObjectData,				d,				kHera_Object_Type);			action = ((objectActionType *)*actionData) + i;					if ( d >= 0)				d = action->argument.alterObject.minimum = d;		}	}	number = GetHandleSize( actionData) / sizeof( objectActionType);	for ( i = 0; i < number; i++)	{		action = (objectActionType *)*actionData + i;				if (( action->verb == kDeclareWinner) &&			( action->argument.declareWinner.nextLevel >= 0))		{			action->argument.declareWinner.nextLevel =				HD_ChapterNumber_GetFromScenarioIndex( heraFile->scenarioData,					action->argument.declareWinner.nextLevel);		}	}		error = noErr;		// fall through |	//              V	HD_CompileDiscreteData_error:	if ( error == noErr)	{		if ( conditionData != nil)		{			checkSum = Get_CheckSum( conditionData, checkSum);						HRT_KeepChangedResource( heraFile, conditionData,				kHera_Condition_Type, 500, 500,				"\pScenario Condition Data (Hera)");		}				if ( actionData != nil)		{			checkSum = Get_CheckSum( actionData, checkSum);			HRT_KeepChangedResource( heraFile, actionData,				kHera_Action_Type, 500, 500,				"\pAction Data (Hera)");		}				if ( briefPointData != nil)		{			HRT_KeepChangedResource( heraFile, briefPointData,				kHera_BriefPoint_Type, 500, 500,				"\pScenario Briefing Data (Hera)");		}			number = GetHandleSize( initialData) / sizeof( scenarioInitialType);	for ( i = 0; i < number; i++)	{		initial = ((scenarioInitialType *)*initialData) + i;						d = initial->type;		mAssert( d >= 0);		mAssert( d < (GetHandleSize( baseObjectData) / sizeof(baseObjectType)));	}		if ( initialData != nil)		{			checkSum = Get_CheckSum( initialData, checkSum);			HRT_KeepChangedResource( heraFile, initialData,				kHera_Initial_Type, 500, 500,				"\pScenario Initial Data (Hera)");		}				if ( baseObjectData != nil)		{			checkSum = Get_CheckSum( baseObjectData, checkSum);			HRT_KeepChangedResource( heraFile, baseObjectData,				kHera_Object_Type, 500, 500,				"\pObject Data (Hera)");		}		if ( shortNameStrings != nil)		{			HRT_KeepChangedResource( heraFile, shortNameStrings,				'STR#', 5001, 5001,				"\pObject Names Short (Hera)");		}				if ( longNameStrings != nil)		{			HRT_KeepChangedResource( heraFile, longNameStrings,				'STR#', 5000, 5000,				"\pObject Names Long (Hera)");		}		if ( devNoteStrings != nil)		{			HRT_KeepChangedResource( heraFile, devNoteStrings,				'STR#', 5002, 5002,				"\pObject Dev Notes (Hera)");		}				if ( tempScenarioData != nil)		{			checkSum = Get_CheckSum( tempScenarioData, checkSum);			HRT_KeepChangedResource( heraFile, tempScenarioData,				'snro', 500, 500,				"\pScenario Data (Hera)");		}				if ( heraFile->scenarioInfo != nil)		{			((scenarioInfoType *)*(heraFile->scenarioInfo))->checkSum =				checkSum;			HRT_KeepChangedResource( heraFile, heraFile->scenarioInfo,				'nlAG', 128, 128,				"\pScenario File Info (Hera)");		}				HRT_WriteAllToDisk( heraFile);			} else SysBeep(20);	if ( actionData != nil) DisposeHandle( actionData);	if ( conditionData != nil) DisposeHandle( conditionData);	if ( baseObjectData != nil) DisposeHandle( baseObjectData);	if ( initialData != nil) DisposeHandle( initialData);	if ( briefPointData != nil) DisposeHandle( briefPointData);	if ( shortNameStrings != nil) DisposeHandle( shortNameStrings);	if ( longNameStrings != nil) DisposeHandle( longNameStrings);	if ( devNoteStrings != nil) DisposeHandle( devNoteStrings);	if ( tempScenarioData != nil) DisposeHandle( tempScenarioData);	if ( heraFile->scenarioInfo != nil)	{		BlockMove( &tempScenarioInfo, *heraFile->scenarioInfo,			sizeof( scenarioInfoType));	}	UseResFile( oldResFile);	return error;}Handle HD_Find_Discrete_Data( heraScenarioFileType *heraFile, long id,	long num, Boolean *idFound, OSType dataType){	Handle	action = heraFile->discreteData;		if ( idFound != nil)		*idFound = false;	while ( action != nil)	{		if (( ((heraDataHeaderType *)*action)->dataType == dataType) &&			( ((heraDataHeaderType *)*action)->id == id))		{			if ((((heraDataHeaderType *)*action)->num == num) || ( num < 0))				return action;			else if ( idFound != nil)				*idFound = true;		}		action = ((heraDataHeaderType *)*action)->next;	}	return nil;}Handle HD_Create_Discrete_Data( heraScenarioFileType *heraFile, Handle source,	long index, long number,	long id, OSType type){	Handle	result = nil;	long	dataSize = HD_Get_DataSize_From_Type( type);	Boolean	idFound;	//	mAssert( number > 0);		if ( number < 0) return nil;	if ( (source != nil) && ( number < 1)) return nil;		result = HD_Find_Discrete_Data( heraFile, id, number, &idFound, type);	if ( result != nil) return result;		if ( idFound)	{		id = HD_Get_NextID_From_Type( heraFile, type);	}		mAssert( dataSize > 0);		result = NewHandle( sizeof( heraDataHeaderType) + dataSize * number);	mAssert( result != nil);	if ( result == nil) return nil;		((heraDataHeaderType *)*result)->next = heraFile->discreteData;	((heraDataHeaderType *)*result)->previous = nil;	if ( heraFile->discreteData != nil)		((heraDataHeaderType *)*(heraFile->discreteData))->previous = result;	heraFile->discreteData = result;	((heraDataHeaderType *)*result)->id = id;	((heraDataHeaderType *)*result)->realIndex = -1;	((heraDataHeaderType *)*result)->dataType = type;	((heraDataHeaderType *)*result)->num = number;	((heraDataHeaderType *)*result)->referenceNum = 0;	((heraDataHeaderType *)*result)->flags = 0;	if ( source != nil)		BlockMove( *source + (index * dataSize), *result + sizeof( heraDataHeaderType),			number * dataSize);	return result;}void HD_Delete_Discrete_Data( heraScenarioFileType *heraFile, Handle data){	mAssert( data != nil);		if ( data == nil) return;		if ( ((heraDataHeaderType *)*data)->previous != nil)	{		((heraDataHeaderType *)*(((heraDataHeaderType *)*data)->previous))->next =			((heraDataHeaderType *)*data)->next;	}	if ( ((heraDataHeaderType *)*data)->next != nil)	{		((heraDataHeaderType *)*(((heraDataHeaderType *)*data)->next))->previous =			((heraDataHeaderType *)*data)->previous;	}		if ( heraFile->discreteData == data) heraFile->discreteData =		((heraDataHeaderType *)*data)->next;		DisposeHandle( data);}void HD_Delete_Discrete_Data_All( heraScenarioFileType *heraFile){	Handle	data, nextData;	mAssert( heraFile != nil);	if ( heraFile == nil) return;		data = heraFile->discreteData;	while ( data != nil)	{		nextData = ((heraDataHeaderType *)*data)->next;		DisposeHandle( data);		data = nextData;	}}long HD_AppendDiscrete( heraScenarioFileType *heraFile,	Handle originalData, long id, OSType dataType){	Handle	discreteData = HD_Find_Discrete_Data( heraFile, id, -1, nil, dataType);	long	dataTypeSize, discreteSize, originalDataSize, offset;	OSErr	error;		mAssert( originalData != nil);		if ( discreteData == nil) return -1;	if ( ((heraDataHeaderType *)*discreteData)->realIndex >= 0)		return ((heraDataHeaderType *)*discreteData)->realIndex;		mAssert( originalData != nil);		dataTypeSize = HD_Get_DataSize_From_Type( dataType);	originalDataSize = GetHandleSize( originalData);	((heraDataHeaderType *)*discreteData)->realIndex =		originalDataSize / dataTypeSize;	HD_DiscreteData_GetOffsetAndSize(  discreteData, &offset, &discreteSize);	SetHandleSize( originalData, originalDataSize + discreteSize);	error = MemError();	mAssert( error == noErr);	if ( error != noErr)	{		return -1;	}	BlockMove( *discreteData + offset, *originalData + originalDataSize, discreteSize);	return ((heraDataHeaderType *)*discreteData)->realIndex;}long HD_Get_DataSize_From_Type( OSType type){	switch( type)	{		case kHera_Action_Type:			return sizeof( objectActionType);			break;				case kHera_Object_Type:			return sizeof( baseObjectType);			break;				case kHera_Initial_Type:			return sizeof( scenarioInitialType);			break;				case kHera_Condition_Type:			return sizeof( scenarioConditionType);			break;				case kHera_BriefPoint_Type:			return sizeof( briefPointType);			break;				case kHera_ObjectStrings_Type:			return sizeof( heraBaseObjectStringsType);			break;					default:			return 0;			break;	}}long HD_Get_NextID_From_Type( heraScenarioFileType *heraFile, OSType type){	switch( type)	{		case kHera_Action_Type:			return heraFile->actionID++;			break;				case kHera_Object_Type:			return heraFile->objectID++;			break;				case kHera_Initial_Type:			return heraFile->initialID++;			break;				case kHera_Condition_Type:			return heraFile->conditionID++;			break;				case kHera_BriefPoint_Type:			return heraFile->briefPointID++;			break;					default:			return 0;			break;	}}OSErr HD_Add_Reference( Handle data, OSType dataType, long referenceType,	unsigned long refID){	heraDataReferenceType	reference;		mAssert( data != nil);	reference.dataType = dataType;	reference.referenceType = referenceType;	switch( referenceType)	{		case hera_data_byIndex:			reference.data.index = refID;			break;				case hera_data_byID:			reference.data.id = refID;			break;				case hera_data_byHandle:			reference.data.heraData = (Handle)refID;			break;	}	((heraDataHeaderType *)*data)->referenceNum++;	return HU_Handle_Insert( sizeof( heraDataHeaderType) + (sizeof( heraDataReferenceType) *			(((heraDataHeaderType *)*data)->referenceNum - 1)), data,			(Ptr)&reference, sizeof( heraDataReferenceType));}void HD_DiscreteData_GetOffsetAndSize( Handle data, long *offset, long *size){	heraDataHeaderType	*header = (heraDataHeaderType *)*data;	mAssert( data != nil);			//	*offset = sizeof( heraDataHeaderType) + (sizeof( heraDataReferenceType) *//			(((heraDataHeaderType *)*data)->referenceNum ));//	*size = GetHandleSize( data) - *offset;	*offset = sizeof( heraDataHeaderType) + (sizeof( heraDataReferenceType) *			(header->referenceNum));	*size = GetHandleSize( data) - *offset;}void *HD_DiscreteData_GetNthElement( Handle data, OSType type, long n){	long	offset = 0, size = 0;		mAssert( n < HD_DiscreteData_GetElementNumber( data, type));		HD_DiscreteData_GetOffsetAndSize( data, &offset, &size);	return (*data + offset + ( n * HD_Get_DataSize_From_Type( type)));}/* HD_DiscreteData_GetNthElementCopy	*** MAY MOVE MEMORY*/void *HD_DiscreteData_GetNthElementCopy( Handle data, OSType type, long n){	long		typeSize = HD_Get_DataSize_From_Type( type);	void		*newElement = NewPtr( typeSize), *originalElement = nil;		if ( newElement == nil) return nil;		originalElement = HD_DiscreteData_GetNthElement( data, type, n);	BlockMoveData( originalElement, newElement, typeSize);	return newElement;}void HD_DiscreteData_SetNthElementFromCopy( Handle data, OSType type, long n,	void *newElement){	long		typeSize = HD_Get_DataSize_From_Type( type);	void		*originalElement = nil;		if ( newElement == nil) return;		originalElement = HD_DiscreteData_GetNthElement( data, type, n);	BlockMoveData( newElement, originalElement, typeSize);}long HD_DiscreteData_GetElementNumber( Handle data, OSType type){	long	offset = 0, size = 0;		HD_DiscreteData_GetOffsetAndSize( data, &offset, &size);	return size / HD_Get_DataSize_From_Type( type);}OSErr HD_DiscreteData_Replace( Handle data, Handle replacementData,	OSType dataType){/*	long			offset, size, replacementSize;	OSErr			error;		mAssert( data != nil);	mAssert( replacementData != nil);		HD_DiscreteData_GetOffsetAndSize( data, &offset, &size);	replacementSize = GetHandleSize( replacementData);	if ( replacementSize != size)	{		SetHandleSize( data, replacementSize + offset);		error = MemError();		if ( error != noErr) return error;		((heraDataHeaderType *)*data)->num = replacementSize /			HD_Get_DataSize_From_Type( dataType);			}	BlockMove( *replacementData, *data + offset, replacementSize);	return noErr;	*/	return		HD_DiscreteData_Replace_Compare( data, replacementData, dataType, nil);}OSErr HD_DiscreteData_Replace_Compare( Handle data, Handle replacementData,	OSType dataType, Boolean *same){	long			offset, size, replacementSize;	OSErr			error;	char			*oData, *nData;		mAssert( data != nil);	mAssert( replacementData != nil);	if ( same != nil) *same = true;		HD_DiscreteData_GetOffsetAndSize( data, &offset, &size);	replacementSize = GetHandleSize( replacementData);	if ( replacementSize != size)	{		if ( same != nil) *same = false;		SetHandleSize( data, replacementSize + offset);		error = MemError();		if ( error != noErr) return error;		((heraDataHeaderType *)*data)->num = replacementSize /			HD_Get_DataSize_From_Type( dataType);			}	if ( same != nil)	{		if ( *same)		{			oData = *data + offset;			nData = *replacementData;			while (( size > 0) && ( *same))			{				if ( *oData != *nData) *same = false;				oData++;				nData++;				size--;			}		}	}	BlockMove( *replacementData, *data + offset, replacementSize);		return noErr;	}//OSErr HD_DiscreteData_Insert( Handle data, void *newData, OSType dataType)//{//	return noErr;//}Handle HD_DiscreteData_GetNextOfType( heraScenarioFileType *heraFile,	Handle data, OSType type){	if ( data == nil)	{		data = heraFile->discreteData;	} else	{		data = ((heraDataHeaderType *)*data)->next;	}		while ( data != nil)	{		if (((heraDataHeaderType *)*data)->dataType == type) return data;		else data = ((heraDataHeaderType *)*data)->next;	}	return nil;}long HD_ScenarioIndex_GetFromChapterNumber( Handle scenarioData, long chapter){	scenarioType	*scenario = (scenarioType *)*scenarioData;	long			max = GetHandleSize( scenarioData) / sizeof( scenarioType),					i = 0;		while ( i < max)	{		if ( scenario->levelNameStrNum == chapter) return i;		scenario++;		i++;	}	return -1;}long HD_ChapterNumber_GetFromScenarioIndex( Handle scenarioData, long index){	scenarioType	*scenario = (scenarioType *)*scenarioData + index;	long			max = GetHandleSize( scenarioData) / sizeof( scenarioType);	if (( index >= 0) && ( index < max)) return scenario->levelNameStrNum;	else return -1;}Boolean HD_IsScenarioNetworkable( Handle scenarioData, long index){	scenarioType	*scenario = (scenarioType *)*scenarioData + index;	long			i;	for ( i = 0; i < kScenarioPlayerNum; i++)	{		if ( scenario->player[i].playerType == kNetworkHumanPlayer) return( true);	}	return false;}Boolean HD_IsRaceLegalForScenarioPlayer( heraScenarioFileType *heraFile,	Handle scenarioData, long scenarioIndex, long raceID, long player){	Handle			raceData = HRT_Resource_GetHandle( heraFile, 'race', 500, nil, nil);	raceType		*race = nil;	scenarioType 	*scenario = (scenarioType *)*scenarioData + scenarioIndex;	long			raceIndex, raceMax;	Boolean			result = true;		mAssert( scenario != nil);	mAssert( raceData != nil);//	mAssert( HD_IsScenarioNetworkable( scenarioData, scenarioIndex));		if ( HD_IsScenarioNetworkable( scenarioData, scenarioIndex))	{		raceIndex = 0;		race = (raceType *)*raceData;		raceMax = GetHandleSize( raceData) / sizeof( raceType);				while (( race->id != raceID) && ( raceIndex < raceMax))		{			race++;			raceIndex++;		}		if ( raceIndex >= raceMax)		{			result = false;			goto HD_IsRaceLegalForScenarioPlayer_return;		}			if (( player >= 0) && ( player < kScenarioPlayerNum))		{			if ( scenario->player[player].netRaceFlags & ( 0x0001 << raceIndex))				goto HD_IsRaceLegalForScenarioPlayer_return;		} else		{			for ( player = 0; player < scenario->playerNum; player++)			{				if ( scenario->player[player].netRaceFlags & ( 0x0001 << raceIndex))					goto HD_IsRaceLegalForScenarioPlayer_return;			}		}	} else	{		if (( player >= 0) && ( player < kScenarioPlayerNum))		{			if ( scenario->player[player].playerRace == raceID)				goto HD_IsRaceLegalForScenarioPlayer_return;		} else		{			for ( player = 0; player < scenario->playerNum; player++)			{				if ( scenario->player[player].playerRace == raceID)					goto HD_IsRaceLegalForScenarioPlayer_return;			}		}			}	result = false;	HD_IsRaceLegalForScenarioPlayer_return:	if ( raceData != nil) DisposeHandle( raceData);		return result;}long HD_RaceIndex_GetFrom_RaceID( heraScenarioFileType *heraFile, long raceID){	Handle			raceData = HRT_Resource_GetHandle( heraFile, 'race', 500, nil, nil);	raceType		*race = nil;	long			raceIndex, raceMax;		if ( raceData == nil) return 0;		raceIndex = 0;	race = (raceType *)*raceData;	raceMax = GetHandleSize( raceData) / sizeof( raceType);		while (( race->id != raceID) && ( raceIndex < raceMax))	{		race++;		raceIndex++;	}	if ( raceIndex >= raceMax)	{		DisposeHandle( raceData);		return -1;	} else	{		DisposeHandle( raceData);		return raceIndex;	}}long HD_RaceID_GetFrom_RaceIndex( heraScenarioFileType *heraFile, long raceIndex){	Handle			raceData = HRT_Resource_GetHandle( heraFile, 'race', 500, nil, nil);	raceType		*race = nil;	long			raceMax, result;		if ( raceData == nil) return 0;		raceMax = GetHandleSize( raceData) / sizeof( raceType);	if (( raceIndex >= raceMax) || ( raceIndex < 0))	{		DisposeHandle( raceData);		return -1;	}	race = ((raceType *)*raceData) + raceIndex;	result = race->id;	DisposeHandle( raceData);	return result;}/* HD_DataChanges_Add	returns head (creating it if needed) not tail -- not newly created changes*/heraDataChangesType *HD_DataChanges_Add( heraDataChangesType *head, long index,	long number, long action){	heraDataChangesType *newChanges = nil, *last;		newChanges = (heraDataChangesType *)NewPtr( sizeof( heraDataChangesType));	mAssert( newChanges != nil);	if ( newChanges == nil) return head;		newChanges->index = index;	newChanges->number = number;	newChanges->action = action;	newChanges->next = nil;		if ( head == nil)	{		head = newChanges;		return head;	}		last = HD_DataChanges_GetLast( head);	mAssert( last != nil);	last->next = newChanges;	return head;}heraDataChangesType *HD_DataChanges_GetLast( heraDataChangesType *head){	if ( head == nil) return nil;		while ( head->next != nil) head = head->next;	return head;}void HD_DataChanges_DeleteAll( heraDataChangesType *head){	heraDataChangesType	*next = head;		while ( next != nil)	{		head = next;		next = head->next;		DisposePtr( (Ptr)head);	}}void HD_DiscreteData_SetAllFlags( heraScenarioFileType *heraFile,	OSType type, unsigned long onFlags, unsigned long offFlags){	Handle	discreteData = heraFile->discreteData;		while ( discreteData != nil)	{		if ( ( type == 0) || (			((heraDataHeaderType *)*discreteData)->dataType == type))		{			((heraDataHeaderType *)*discreteData)->flags &= ~offFlags;			((heraDataHeaderType *)*discreteData)->flags |= onFlags;		}		discreteData = ((heraDataHeaderType *)*discreteData)->next;	}} void HD_DiscreteData_ClearAllRealIndexes( heraScenarioFileType *heraFile,	OSType type){	Handle	discreteData = heraFile->discreteData;		while ( discreteData != nil)	{		if ( ( type == 0) || (			((heraDataHeaderType *)*discreteData)->dataType == type))		{			((heraDataHeaderType *)*discreteData)->realIndex = -1;		}		discreteData = ((heraDataHeaderType *)*discreteData)->next;	}} void HD_ObjectWalker( heraScenarioFileType *heraFile,	long objectID, unsigned long userData,	Hera_Data_ObjectWalker_Callback_procPtr callBack){	Handle			discreteData = HD_Find_Discrete_Data( heraFile, objectID, 1, nil,							kHera_Object_Type),					actionData = nil;	baseObjectType	*o;		if ( discreteData == nil) return;	if ( ((heraDataHeaderType *)*discreteData)->flags & 0x01) return;		o = (baseObjectType *)HD_DiscreteData_GetNthElementCopy( discreteData,		kHera_Object_Type, 0);	mAssert( o != nil);	if ( o == nil) return;		((heraDataHeaderType *)*discreteData)->flags |= 0x01;	if ( callBack != nil)	{		callBack( discreteData, nil, userData);				if ( o->pulse >= 0) HD_ObjectWalker( heraFile, o->pulse, userData, callBack);		if ( o->beam >= 0) HD_ObjectWalker( heraFile, o->beam, userData, callBack);		if ( o->special >= 0) HD_ObjectWalker( heraFile, o->special, userData, callBack);				if ( o->destroyAction >= 0)		{			actionData = HD_Find_Discrete_Data( heraFile, o->destroyAction,							o->destroyActionNum & kHera_DestroyActionMask, nil,							kHera_Action_Type);			if ( actionData != nil)			{				HD_ObjectWalker_ActionWalker( heraFile, actionData, userData, callBack);			}						callBack( discreteData, actionData, userData);		}		if ( o->expireAction >= 0)		{			actionData = HD_Find_Discrete_Data( heraFile, o->expireAction,							o->expireActionNum & kHera_ExpireActionMask, nil,							kHera_Action_Type);			if ( actionData != nil)			{				HD_ObjectWalker_ActionWalker( heraFile, actionData, userData, callBack);			}						callBack( discreteData, actionData, userData);		}		if ( o->createAction >= 0)		{			actionData = HD_Find_Discrete_Data( heraFile, o->createAction,							o->createActionNum & kHera_CreateActionMask, nil,							kHera_Action_Type);			if ( actionData != nil)			{				HD_ObjectWalker_ActionWalker( heraFile, actionData, userData, callBack);			}						callBack( discreteData, actionData, userData);		}		if ( o->collideAction >= 0)		{			actionData = HD_Find_Discrete_Data( heraFile, o->collideAction,							o->collideActionNum & kHera_CollideActionMask, nil,							kHera_Action_Type);			if ( actionData != nil)			{				HD_ObjectWalker_ActionWalker( heraFile, actionData, userData, callBack);			}						callBack( discreteData, actionData, userData);		}		if ( o->activateAction >= 0)		{			actionData = HD_Find_Discrete_Data( heraFile, o->activateAction,							o->activateActionNum & kHera_ActivateActionMask, nil,							kHera_Action_Type);			if ( actionData != nil)			{				HD_ObjectWalker_ActionWalker( heraFile, actionData, userData, callBack);			}						callBack( discreteData, actionData, userData);		}		if ( o->arriveAction >= 0)		{			actionData = HD_Find_Discrete_Data( heraFile, o->arriveAction,							o->arriveActionNum & kHera_ArriveActionMask, nil,							kHera_Action_Type);			if ( actionData != nil)			{				HD_ObjectWalker_ActionWalker( heraFile, actionData, userData, callBack);			}						callBack( discreteData, actionData, userData);		}	}	DisposePtr( (Ptr)o);}void HD_ObjectWalker_ActionWalker( heraScenarioFileType *heraFile,	Handle discreteData, unsigned long userData,	Hera_Data_ObjectWalker_Callback_procPtr callBack){	long				actionNumber, i;	objectActionType	*action = nil;		mAssert( discreteData != nil);	if ( discreteData == nil) return;	if ( ((heraDataHeaderType *)*discreteData)->flags & 0x01) return;	((heraDataHeaderType *)*discreteData)->flags |= 0x01;		actionNumber = HD_DiscreteData_GetElementNumber( discreteData, kHera_Action_Type);		for ( i = 0; i < actionNumber; i++)	{		action = (objectActionType *)HD_DiscreteData_GetNthElement( discreteData,			kHera_Action_Type, i);				mAssert( action != nil);				if (( action->verb == kCreateObject) || ( action->verb ==			kCreateObjectSetDest))		{			HD_ObjectWalker( heraFile, action->argument.createObject.whichBaseType, userData,				callBack);		} else if (( action->verb == kAlter) &&			( action->argument.alterObject.alterType ==				kAlterBaseType))		{			HD_ObjectWalker( heraFile, action->argument.alterObject.minimum, userData,				callBack);		}	}}Boolean HD_Object_Compare( heraScenarioFileType *sourceHeraFile,	Handle sourceObjectData, heraScenarioFileType *destHeraFile,	Handle destObjectData){	Handle			sourceActionData, destActionData, sourceWeaponData, destWeaponData;	baseObjectType	*sourceObject = nil, *destObject = nil;	Boolean			result = false;		if (( sourceHeraFile == nil) || ( destHeraFile == nil)) return false;	if (( sourceObjectData == nil) || (destObjectData == nil)) return false;	if ( (((heraDataHeaderType *)*sourceObjectData)->flags & 0x01) ||		( ((heraDataHeaderType *)*sourceObjectData)->flags &			kHD_Temporary_Flag_IsBeingChecked))		return ((heraDataHeaderType *)*sourceObjectData)->realIndex ==				((heraDataHeaderType *)*destObjectData)->id;		sourceObject = (baseObjectType *)HD_DiscreteData_GetNthElementCopy(		sourceObjectData, kHera_Object_Type, 0);	mAssert( sourceObject != nil);	if ( sourceObject == nil) return false;		destObject = (baseObjectType *)HD_DiscreteData_GetNthElementCopy(		destObjectData, kHera_Object_Type, 0);		((heraDataHeaderType *)*sourceObjectData)->flags |=		kHD_Temporary_Flag_IsBeingChecked;			mAssert( destObject != nil);	if ( destObject == nil) goto HD_Object_Compare_return;		if ( !HD_Objects_Essentially_Identical( sourceObject, destObject))		goto HD_Object_Compare_return;			// check pulse	if ( sourceObject->pulse >= 0)	{		sourceWeaponData = HD_Find_Discrete_Data( sourceHeraFile, sourceObject->pulse,						-1, nil, kHera_Object_Type);		mAssert( sourceWeaponData != nil);		if ( sourceWeaponData == nil) goto HD_Object_Compare_return;				// we can assume the the dest object has a pulse weapon;		// otherwise, HD_Objects_Essentially_Identical would have rejected		mAssert( destObject->pulse >= 0);		destWeaponData = HD_Find_Discrete_Data( destHeraFile, destObject->pulse,						-1, nil, kHera_Object_Type);		mAssert( destWeaponData != nil);		if ( destWeaponData == nil) goto HD_Object_Compare_return;				if ( !HD_Object_Compare( sourceHeraFile,  sourceObjectData, destHeraFile,				destObjectData))			goto HD_Object_Compare_return;	}	// check beam	if ( sourceObject->beam >= 0)	{		sourceWeaponData = HD_Find_Discrete_Data( sourceHeraFile, sourceObject->beam,							-1, nil, kHera_Object_Type);		mAssert( sourceWeaponData != nil);		if ( sourceWeaponData == nil) goto HD_Object_Compare_return;				// we can assume the the dest object has a beam weapon;		// otherwise, HD_Objects_Essentially_Identical would have rejected		mAssert( destObject->beam >= 0);		destWeaponData = HD_Find_Discrete_Data( destHeraFile, destObject->beam,						-1, nil, kHera_Object_Type);		mAssert( destWeaponData != nil);		if ( destWeaponData == nil) goto HD_Object_Compare_return;				if ( !HD_Object_Compare( sourceHeraFile,  sourceObjectData, destHeraFile,				destObjectData))			goto HD_Object_Compare_return;	}	// check special	if ( sourceObject->special >= 0)	{		sourceWeaponData = HD_Find_Discrete_Data( sourceHeraFile, sourceObject->special,						-1, nil, kHera_Object_Type);		mAssert( sourceWeaponData != nil);		if ( sourceWeaponData == nil) goto HD_Object_Compare_return;				// we can assume the the dest object has a special weapon;		// otherwise, HD_Objects_Essentially_Identical would have rejected		mAssert( destObject->special >= 0);		destWeaponData = HD_Find_Discrete_Data( destHeraFile, destObject->special,						-1, nil, kHera_Object_Type);		mAssert( destWeaponData != nil);		if ( destWeaponData == nil) goto HD_Object_Compare_return;				if ( !HD_Object_Compare( sourceHeraFile,  sourceObjectData, destHeraFile,				destObjectData))			goto HD_Object_Compare_return;	}		if ( sourceObject->destroyAction >= 0)	{		sourceActionData = HD_Find_Discrete_Data( sourceHeraFile, sourceObject->destroyAction,						sourceObject->destroyActionNum & kHera_DestroyActionMask, nil,						kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData == nil) goto HD_Object_Compare_return;		destActionData = HD_Find_Discrete_Data( destHeraFile, destObject->destroyAction,						destObject->destroyActionNum & kHera_DestroyActionMask, nil,						kHera_Action_Type);		mAssert( destActionData != nil);		if ( destActionData == nil) goto HD_Object_Compare_return;		if ( !HD_Action_Compare( sourceHeraFile, sourceActionData, destHeraFile,			destActionData))			goto HD_Object_Compare_return;	}	if ( sourceObject->expireAction >= 0)	{		sourceActionData = HD_Find_Discrete_Data( sourceHeraFile, sourceObject->expireAction,						sourceObject->expireActionNum & kHera_ExpireActionMask, nil,						kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData == nil) goto HD_Object_Compare_return;		destActionData = HD_Find_Discrete_Data( destHeraFile, destObject->expireAction,						destObject->expireActionNum & kHera_ExpireActionMask, nil,						kHera_Action_Type);		mAssert( destActionData != nil);		if ( destActionData == nil) goto HD_Object_Compare_return;		if ( !HD_Action_Compare( sourceHeraFile, sourceActionData, destHeraFile,			destActionData))			goto HD_Object_Compare_return;	}	if ( sourceObject->createAction >= 0)	{		sourceActionData = HD_Find_Discrete_Data( sourceHeraFile, sourceObject->createAction,						sourceObject->createActionNum & kHera_CreateActionMask, nil,						kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData == nil) goto HD_Object_Compare_return;		destActionData = HD_Find_Discrete_Data( destHeraFile, destObject->createAction,						destObject->createActionNum & kHera_CreateActionMask, nil,						kHera_Action_Type);		mAssert( destActionData != nil);		if ( destActionData == nil) goto HD_Object_Compare_return;		if ( !HD_Action_Compare( sourceHeraFile, sourceActionData, destHeraFile,			destActionData))			goto HD_Object_Compare_return;	}	if ( sourceObject->collideAction >= 0)	{		sourceActionData = HD_Find_Discrete_Data( sourceHeraFile, sourceObject->collideAction,						sourceObject->collideActionNum & kHera_CollideActionMask, nil,						kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData == nil) goto HD_Object_Compare_return;		destActionData = HD_Find_Discrete_Data( destHeraFile, destObject->collideAction,						destObject->collideActionNum & kHera_CollideActionMask, nil,						kHera_Action_Type);		mAssert( destActionData != nil);		if ( destActionData == nil) goto HD_Object_Compare_return;		if ( !HD_Action_Compare( sourceHeraFile, sourceActionData, destHeraFile,			destActionData))			goto HD_Object_Compare_return;	}	if ( sourceObject->activateAction >= 0)	{		sourceActionData = HD_Find_Discrete_Data( sourceHeraFile, sourceObject->activateAction,						sourceObject->activateActionNum & kHera_ActivateActionMask, nil,						kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData == nil) goto HD_Object_Compare_return;		destActionData = HD_Find_Discrete_Data( destHeraFile, destObject->activateAction,						destObject->activateActionNum & kHera_ActivateActionMask, nil,						kHera_Action_Type);		mAssert( destActionData != nil);		if ( destActionData == nil) goto HD_Object_Compare_return;		if ( !HD_Action_Compare( sourceHeraFile, sourceActionData, destHeraFile,			destActionData))			goto HD_Object_Compare_return;	}	if ( sourceObject->arriveAction >= 0)	{		sourceActionData = HD_Find_Discrete_Data( sourceHeraFile, sourceObject->arriveAction,						sourceObject->arriveActionNum & kHera_ArriveActionMask, nil,						kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData == nil) goto HD_Object_Compare_return;		destActionData = HD_Find_Discrete_Data( destHeraFile, destObject->arriveAction,						destObject->arriveActionNum & kHera_ArriveActionMask, nil,						kHera_Action_Type);		mAssert( destActionData != nil);		if ( destActionData == nil) goto HD_Object_Compare_return;		if ( !HD_Action_Compare( sourceHeraFile, sourceActionData, destHeraFile,			destActionData))			goto HD_Object_Compare_return;	}	((heraDataHeaderType *)*sourceObjectData)->flags |= 0x01;	((heraDataHeaderType *)*sourceObjectData)->realIndex =		((heraDataHeaderType *)*destObjectData)->id;	result = true;	HD_Object_Compare_return:	if ( sourceObject != nil)			DisposePtr( (Ptr)sourceObject);	if ( destObject != nil)		DisposePtr( (Ptr)destObject);		((heraDataHeaderType *)*sourceObjectData)->flags &=		~kHD_Temporary_Flag_IsBeingChecked;			return result;}Boolean HD_Action_Compare( heraScenarioFileType *sourceHeraFile, 	Handle sourceActionData, heraScenarioFileType *destHeraFile, 	Handle destActionData){	long				sourceActionNumber, destActionNumber, i,						sourceObjectID, destObjectID;	objectActionType	*sourceAction = nil, *destAction;	Handle				sourceObjectData, destObjectData;	Boolean				result = false;		if (( sourceHeraFile == nil) || ( destHeraFile == nil)) return false;	if (( sourceActionData == nil) ||( destActionData == nil)) return false;	if (( ((heraDataHeaderType *)*sourceActionData)->flags & 0x01) ||		( ( (heraDataHeaderType *)*sourceActionData)->flags &			kHD_Temporary_Flag_IsBeingChecked))		return ((heraDataHeaderType *)*sourceActionData)->realIndex ==				((heraDataHeaderType *)*destActionData)->id;	sourceActionNumber = HD_DiscreteData_GetElementNumber( sourceActionData,		kHera_Action_Type);	destActionNumber = HD_DiscreteData_GetElementNumber( destActionData,		kHera_Action_Type);		if ( sourceActionNumber != destActionNumber) return false;		((heraDataHeaderType *)*sourceActionData)->flags |=		kHD_Temporary_Flag_IsBeingChecked;		for ( i = 0; i < sourceActionNumber; i++)	{		sourceAction = (objectActionType *)HD_DiscreteData_GetNthElement( sourceActionData,			kHera_Action_Type, i);				mAssert( sourceAction != nil);				destAction = (objectActionType *)HD_DiscreteData_GetNthElement( destActionData,			kHera_Action_Type, i);		mAssert( destAction != nil);				if ( !HD_Actions_Essentially_Identical( sourceAction, destAction))			goto HD_Action_Compare_return;					if (( sourceAction->verb == kCreateObject) || ( sourceAction->verb ==			kCreateObjectSetDest))		{			// we can assume the destAction is the same verb			// or HD_Actions_Essentially_Identical would have rejected			sourceObjectID = sourceAction->argument.createObject.whichBaseType;			destObjectID = destAction->argument.createObject.whichBaseType;						sourceObjectData = HD_Find_Discrete_Data( sourceHeraFile, sourceObjectID,								-1, nil, kHera_Object_Type);			mAssert( sourceObjectData != nil);			if ( sourceObjectData == nil) goto HD_Action_Compare_return;			destObjectData = HD_Find_Discrete_Data( destHeraFile, destObjectID, -1, nil,													kHera_Object_Type);			mAssert( destObjectData != nil);			if ( destObjectData == nil) goto HD_Action_Compare_return;						if ( !HD_Object_Compare( sourceHeraFile, sourceObjectData, destHeraFile,					destObjectData)) goto HD_Action_Compare_return;							} else if (( sourceAction->verb == kAlter) &&			( sourceAction->argument.alterObject.alterType ==				kAlterBaseType))		{			sourceObjectID = sourceAction->argument.alterObject.minimum;			destObjectID = destAction->argument.alterObject.minimum;			sourceObjectData = HD_Find_Discrete_Data( sourceHeraFile, sourceObjectID, -1,									nil, kHera_Object_Type);			mAssert( sourceObjectData != nil);			if ( sourceObjectData == nil) goto HD_Action_Compare_return;			destObjectData = HD_Find_Discrete_Data( destHeraFile, destObjectID, -1, nil,													kHera_Object_Type);			mAssert( destObjectData != nil);			if ( destObjectData == nil) goto HD_Action_Compare_return;						if ( !HD_Object_Compare( sourceHeraFile, sourceObjectData, destHeraFile,					destObjectData)) goto HD_Action_Compare_return;		}	}	((heraDataHeaderType *)*sourceActionData)->flags |= 0x01;	((heraDataHeaderType *)*sourceActionData)->realIndex =		((heraDataHeaderType *)*destActionData)->id;	result = true;	HD_Action_Compare_return:	if ( sourceActionData != nil)		((heraDataHeaderType *)*sourceActionData)->flags &= ~			kHD_Temporary_Flag_IsBeingChecked;	return result;}Boolean HD_Objects_Essentially_Identical( baseObjectType *aBase,	baseObjectType *bBase){	long		c2;		if ( aBase->attributes != bBase->attributes) return false;	if ( aBase->baseClass != bBase->baseClass) return false;	if ( aBase->baseRace != bBase->baseRace) return false;	if ( aBase->price != bBase->price) return false;		if ( aBase->offenseValue != bBase->offenseValue) return false;	if ( aBase->destinationClass != bBase->destinationClass) return false;	if ( aBase->maxVelocity != bBase->maxVelocity) return false;	if ( aBase->warpSpeed != bBase->warpSpeed) return false;	if ( aBase->warpOutDistance != bBase->warpOutDistance) return false;		if ( aBase->initialVelocity != bBase->initialVelocity) return false;	if ( aBase->initialVelocityRange != bBase->initialVelocityRange) return false;		if ( aBase->mass != bBase->mass) return false;	if ( aBase->maxThrust != bBase->maxThrust) return false;		if ( aBase->health != bBase->health) return false;	if ( aBase->damage != bBase->damage) return false;	if ( aBase->energy != bBase->energy) return false;	if ( aBase->initialAge != bBase->initialAge) return false;	if ( aBase->initialAgeRange != bBase->initialAgeRange) return false;	if ( aBase->naturalScale != bBase->naturalScale) return false;	if ( aBase->pixLayer != bBase->pixLayer) return false;	if ( aBase->pixResID != bBase->pixResID) return false;	if ( aBase->tinySize != bBase->tinySize) return false;	if ( aBase->shieldColor != bBase->shieldColor) return false;	if ( aBase->initialDirection != bBase->initialDirection) return false;	if ( aBase->initialDirectionRange != bBase->initialDirectionRange) return false;		// we don't care if they point to the same object ids	// because the objects they point to may be in different files	if ( (aBase->pulse < 0) != (bBase->pulse < 0)) return false;	if ( (aBase->beam < 0) != (bBase->beam < 0)) return false;	if ( (aBase->special < 0) != (bBase->special < 0)) return false;	if ( aBase->pulsePositionNum != bBase->pulsePositionNum) return false;	if ( aBase->beamPositionNum != bBase->beamPositionNum) return false;	if ( aBase->specialPositionNum != bBase->specialPositionNum) return false;		for( c2 = 0; c2 < kMaxWeaponPosition; c2++)	{		if ( aBase->pulsePosition[c2].h != bBase->pulsePosition[c2].h) return false;		if ( aBase->pulsePosition[c2].v != bBase->pulsePosition[c2].v) return false;		if ( aBase->beamPosition[c2].h != bBase->beamPosition[c2].h) return false;		if ( aBase->beamPosition[c2].v != bBase->beamPosition[c2].v) return false;		if ( aBase->specialPosition[c2].h != bBase->specialPosition[c2].h) return false;		if ( aBase->specialPosition[c2].v != bBase->specialPosition[c2].v) return false;	}	if ( aBase->friendDefecit != bBase->friendDefecit) return false;	if ( aBase->dangerThreshold != bBase->dangerThreshold) return false;	if ( aBase->specialDirection != bBase->specialDirection) return false;		if ( aBase->arriveActionDistance != bBase->arriveActionDistance) return false;	// We don't care here whether or not they point to the same action ids	// b/c the actions they point to are in different files	if ( ( aBase->destroyAction < 0) != ( bBase->destroyAction < 0)) return false;	if ( aBase->destroyActionNum != bBase->destroyActionNum) return false;	if ( ( aBase->expireAction < 0) != ( bBase->expireAction < 0)) return false;	if ( aBase->expireActionNum != bBase->expireActionNum) return false;	if ( ( aBase->createAction < 0) != ( bBase->createAction < 0)) return false;	if ( aBase->createActionNum != bBase->createActionNum) return false;	if ( ( aBase->collideAction < 0) != ( bBase->collideAction < 0)) return false;	if ( aBase->collideActionNum != bBase->collideActionNum) return false;	if ( ( aBase->activateAction < 0) != ( bBase->activateAction < 0)) return false;	if ( aBase->activateActionNum != bBase->activateActionNum) return false;	if ( ( aBase->arriveAction < 0) != ( bBase->arriveAction < 0)) return false;	if ( aBase->arriveActionNum != bBase->arriveActionNum) return false;		if ( !HU_Data_Is_Identical( (Ptr)&aBase->frame, (Ptr)&bBase->frame, sizeof( objectFrameType)))		return false;			if ( aBase->buildFlags != bBase->buildFlags) return false;	if ( aBase->orderFlags != bBase->orderFlags) return false;	if ( aBase->buildRatio != bBase->buildRatio) return false;	if ( aBase->buildTime != bBase->buildTime) return false;	if ( aBase->skillNum != bBase->skillNum) return false;	if ( aBase->skillNumAdj != bBase->skillNumAdj) return false;	if ( aBase->skillDen != bBase->skillDen) return false;	if ( aBase->skillDenAdj != bBase->skillDenAdj) return false;	if ( aBase->reserved2 != bBase->reserved2) return false;	if ( aBase->reserved3 != bBase->reserved3) return false;	if ( aBase->internalFlags != bBase->internalFlags) return false;	if ( aBase->pictPortraitResID != bBase->pictPortraitResID) return false;		return true;}Boolean HD_Actions_Essentially_Identical( objectActionType *aAction,	objectActionType *bAction){	if (( aAction->verb != kCreateObject) && ( aAction->verb != kCreateObjectSetDest)		&& ( ( aAction->verb != kAlter) || ( aAction->argument.alterObject.alterType !=			kAlterBaseType)))	{		return HU_Data_Is_Identical( (Ptr)aAction, (Ptr)bAction,				sizeof( objectActionType));	}		if ( aAction->verb != bAction->verb) return false;	if ( aAction->reflexive != bAction->reflexive) return false;	if ( aAction->inclusiveFilter != bAction->inclusiveFilter) return false;	if ( aAction->exclusiveFilter != bAction->exclusiveFilter) return false;	if ( aAction->owner != bAction->owner) return false;	if ( aAction->delay != bAction->delay) return false;	if ( aAction->initialSubjectOverride != bAction->initialSubjectOverride) return false;	if ( aAction->initialDirectOverride != bAction->initialDirectOverride) return false;	if ( aAction->reserved2 != bAction->reserved2) return false;		if (( aAction->verb == kCreateObject) || ( aAction->verb == kCreateObjectSetDest))	{		if ( aAction->argument.createObject.howManyMinimum != bAction->argument.createObject.howManyMinimum) return false;		if ( aAction->argument.createObject.howManyRange != bAction->argument.createObject.howManyRange) return false;		if ( aAction->argument.createObject.velocityRelative != bAction->argument.createObject.velocityRelative) return false;		if ( aAction->argument.createObject.directionRelative != bAction->argument.createObject.directionRelative) return false;		if ( aAction->argument.createObject.randomDistance != bAction->argument.createObject.randomDistance) return false;		if ( (aAction->argument.createObject.whichBaseType < 0) !=			( bAction->argument.createObject.whichBaseType < 0)) return false;		return true;	} else if (( aAction->verb == kAlter) && ( aAction->argument.alterObject.alterType ==				kAlterBaseType))	{		if ( aAction->argument.alterObject.relative != bAction->argument.alterObject.relative) return false;		if ( aAction->argument.alterObject.range != bAction->argument.alterObject.range) return false;				if ( (aAction->argument.alterObject.minimum < 0) !=			( bAction->argument.alterObject.minimum < 0)) return false;	}	mAssert( 1 != 1);	return false;}/*	all real indexes and flags should be cleared before calling this for the top	most object you're copying*/long HD_Object_Copy( heraScenarioFileType *sourceFile, Handle sourceObjectData,	heraScenarioFileType *destFile){	Handle						destObjectData = nil, destStringData = nil,								sourceStringData = nil, sourceActionData = nil;	Boolean						gotObject = false;	baseObjectType				*sourceObject = nil, *destObject = nil;	heraBaseObjectStringsType	*sourceStrings = nil, *destStrings = nil;	long						newID;		// if we've already copied this object (or have found an identical object	// before) do nothing	if ( ((heraDataHeaderType *)*sourceObjectData)->realIndex >= 0)		return ((heraDataHeaderType *)*sourceObjectData)->realIndex;	 	 destObjectData = HD_DiscreteData_GetNextOfType( destFile, nil, kHera_Object_Type);	 while (( destObjectData != nil) && ( !gotObject))	 {	 	if ( HD_Object_Compare( sourceFile, sourceObjectData, destFile,	 		destObjectData))	 	{	 		gotObject = true;	 	} else	 	{			 destObjectData = HD_DiscreteData_GetNextOfType( destFile, destObjectData,			 	kHera_Object_Type);	 	}	 }	 	 // if we found the object, do nothing	 if ( destObjectData != nil)		return ((heraDataHeaderType *)*destObjectData)->id;	 	 // otherwise, we have to make a new one	newID = HD_Get_NextID_From_Type( destFile,		kHera_Object_Type);	 	destObjectData = HD_Create_Discrete_Data( destFile,		nil, 0, 1, newID, kHera_Object_Type);	if ( destObjectData != nil)	{		newID = ((heraDataHeaderType *)*destObjectData)->id;	} else goto HD_Object_Copy_error;	destStringData = HD_Create_Discrete_Data( destFile,						nil, 0, 1, newID,						kHera_ObjectStrings_Type);	if ( destStringData == nil) goto HD_Object_Copy_error;		sourceStringData  = HD_Find_Discrete_Data( sourceFile,							((heraDataHeaderType *)*sourceObjectData)->id, -1, nil,							kHera_ObjectStrings_Type);		if ( sourceStringData != nil)	{		sourceStrings = (heraBaseObjectStringsType *)HD_DiscreteData_GetNthElement(				sourceStringData, kHera_ObjectStrings_Type, 0);	}		destStrings = (heraBaseObjectStringsType *)HD_DiscreteData_GetNthElement(			destStringData, kHera_ObjectStrings_Type, 0);		if ( sourceStrings != nil)	{		BlockMove( (Ptr)sourceStrings, destStrings,								sizeof( heraBaseObjectStringsType));	} else	{		pstrcpy( destStrings->shortName, "\pUNTITLED");		pstrcpy( destStrings->longName,"\pUntitled Object");		pstrcpy( destStrings->devNote, "\pNotes for untitled object");	}	sourceObject = (baseObjectType *)HD_DiscreteData_GetNthElement(		sourceObjectData, kHera_Object_Type, 0);	destObject = (baseObjectType *)HD_DiscreteData_GetNthElement(		destObjectData, kHera_Object_Type, 0);		BlockMove( (Ptr)sourceObject, destObject, sizeof( baseObjectType));	((heraDataHeaderType *)*sourceObjectData)->realIndex = newID;		// pulse	if ( destObject->pulse >= 0)	{		newID = destObject->pulse;		sourceObjectData = HD_Find_Discrete_Data( sourceFile,							newID, -1, nil,							kHera_Object_Type);		mAssert( sourceObjectData != nil);		if ( sourceObjectData != nil)		{			newID = HD_Object_Copy( sourceFile, sourceObjectData, destFile);		} else		{			newID = -1;		}	} else newID = -1;		destObject = (baseObjectType *)HD_DiscreteData_GetNthElement(		destObjectData, kHera_Object_Type, 0);	destObject->pulse = newID;		// beam	if ( destObject->beam >= 0)	{		newID = destObject->beam;		sourceObjectData = HD_Find_Discrete_Data( sourceFile,							newID, -1, nil,							kHera_Object_Type);		mAssert( sourceObjectData != nil);		if ( sourceObjectData != nil)		{			newID = HD_Object_Copy( sourceFile, sourceObjectData, destFile);		} else		{			newID = -1;		}	} else newID = -1;		destObject = (baseObjectType *)HD_DiscreteData_GetNthElement(		destObjectData, kHera_Object_Type, 0);	destObject->beam = newID;		// special	if ( destObject->special >= 0)	{		newID = destObject->special;		sourceObjectData = HD_Find_Discrete_Data( sourceFile,							newID, -1, nil,							kHera_Object_Type);		mAssert( sourceObjectData != nil);		if ( sourceObjectData != nil)		{			newID = HD_Object_Copy( sourceFile, sourceObjectData, destFile);		} else		{			newID = -1;		}	} else newID = -1;		destObject = (baseObjectType *)HD_DiscreteData_GetNthElement(		destObjectData, kHera_Object_Type, 0);	destObject->special = newID;	// copy actions		// destroy		if ( destObject->destroyAction >= 0)	{		newID = destObject->destroyAction;		sourceActionData = HD_Find_Discrete_Data( sourceFile,								newID,								destObject->destroyActionNum &									kHera_DestroyActionMask,								nil, kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData != nil)		{			newID = HD_Action_Copy( sourceFile, sourceActionData, destFile);		} else		{			newID = -1;		}							} else newID = -1;	destObject = (baseObjectType *)HD_DiscreteData_GetNthElement(		destObjectData, kHera_Object_Type, 0);	destObject->destroyAction = newID;	// expire		if ( destObject->expireAction >= 0)	{		newID = destObject->expireAction;		sourceActionData = HD_Find_Discrete_Data( sourceFile,								newID,								destObject->expireActionNum & kHera_ExpireActionMask,								nil, kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData != nil)		{			newID = HD_Action_Copy( sourceFile, sourceActionData, destFile);		} else		{			newID = -1;		}							} else newID = -1;	destObject = (baseObjectType *)HD_DiscreteData_GetNthElement(		destObjectData, kHera_Object_Type, 0);	destObject->expireAction = newID;	// create		if ( destObject->createAction >= 0)	{		newID = destObject->createAction;		sourceActionData = HD_Find_Discrete_Data( sourceFile,								newID,								destObject->createActionNum & kHera_CreateActionMask,								nil, kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData != nil)		{			newID = HD_Action_Copy( sourceFile, sourceActionData, destFile);		} else		{			newID = -1;		}							} else newID = -1;	destObject = (baseObjectType *)HD_DiscreteData_GetNthElement(		destObjectData, kHera_Object_Type, 0);	destObject->createAction = newID;	// collide		if ( destObject->collideAction >= 0)	{		newID = destObject->collideAction;		sourceActionData = HD_Find_Discrete_Data( sourceFile,								newID,								destObject->collideActionNum & kHera_CollideActionMask,								nil, kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData != nil)		{			newID = HD_Action_Copy( sourceFile, sourceActionData, destFile);		} else		{			newID = -1;		}							} else newID = -1;	destObject = (baseObjectType *)HD_DiscreteData_GetNthElement(		destObjectData, kHera_Object_Type, 0);	destObject->collideAction = newID;	// activate		if ( destObject->activateAction >= 0)	{		newID = destObject->activateAction;		sourceActionData = HD_Find_Discrete_Data( sourceFile,								newID,								destObject->activateActionNum & kHera_ActivateActionMask,								nil, kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData != nil)		{			newID = HD_Action_Copy( sourceFile, sourceActionData, destFile);		} else		{			newID = -1;		}							} else newID = -1;	destObject = (baseObjectType *)HD_DiscreteData_GetNthElement(		destObjectData, kHera_Object_Type, 0);	destObject->activateAction = newID;	// arrive		if ( destObject->arriveAction >= 0)	{		newID = destObject->arriveAction;		sourceActionData = HD_Find_Discrete_Data( sourceFile,								newID,								destObject->arriveActionNum & kHera_ArriveActionMask,								nil, kHera_Action_Type);		mAssert( sourceActionData != nil);		if ( sourceActionData != nil)		{			newID = HD_Action_Copy( sourceFile, sourceActionData, destFile);		} else		{			newID = -1;		}							} else newID = -1;	destObject = (baseObjectType *)HD_DiscreteData_GetNthElement(		destObjectData, kHera_Object_Type, 0);	destObject->arriveAction = newID;	return 	((heraDataHeaderType *)*destObjectData)->id;	HD_Object_Copy_error:	return -1;}long HD_Action_Copy( heraScenarioFileType *sourceFile, Handle sourceActionData,	heraScenarioFileType *destFile){	Handle							destActionData = nil, sourceObjectData = nil;	Boolean							gotObject = false;	long							actionNumber, i, newID, sourceObjectID,									destObjectID;	objectActionType				*sourceAction = nil, *destAction = nil;		// if we've already copied this object (or have found an identical object	// before) do nothing	if ( ((heraDataHeaderType *)*sourceActionData)->realIndex >= 0)		return ((heraDataHeaderType *)*sourceActionData)->realIndex;	 	 destActionData = HD_DiscreteData_GetNextOfType( destFile, nil, kHera_Action_Type);	 while (( destActionData != nil) && ( !gotObject))	 {	 	if ( HD_Action_Compare( sourceFile, sourceActionData, destFile,	 		destActionData))	 	{	 		gotObject = true;	 	} else	 	{			 destActionData = HD_DiscreteData_GetNextOfType( destFile, destActionData,			 	kHera_Action_Type);	 	}	 }	 	 // if we found the object, do nothing	 if ( destActionData != nil)		return ((heraDataHeaderType *)*destActionData)->id;		actionNumber = HD_DiscreteData_GetElementNumber( sourceActionData,		kHera_Action_Type);	newID = HD_Get_NextID_From_Type( destFile, kHera_Action_Type);		destActionData = HD_Create_Discrete_Data( destFile, nil,		0, actionNumber, newID, kHera_Action_Type);			if ( destActionData == nil) goto HD_Action_Copy_error;		newID = ((heraDataHeaderType *)*destActionData)->id;		sourceAction = (objectActionType *)HD_DiscreteData_GetNthElement( sourceActionData,		kHera_Action_Type, 0);	destAction = (objectActionType *)HD_DiscreteData_GetNthElement( destActionData,		kHera_Action_Type, 0);	if (( sourceAction != nil) && ( destAction != nil))		BlockMove( sourceAction, destAction, sizeof( objectActionType) *			actionNumber);	else goto HD_Action_Copy_error;		((heraDataHeaderType *)*sourceActionData)->realIndex = newID;	for ( i = 0; i < actionNumber; i++)	{		sourceAction = (objectActionType *)HD_DiscreteData_GetNthElement( sourceActionData,			kHera_Action_Type, i);				mAssert( sourceAction != nil);				if (( sourceAction->verb == kCreateObject) || ( sourceAction->verb ==			kCreateObjectSetDest))		{			sourceObjectID = sourceAction->argument.createObject.whichBaseType;									sourceObjectData = HD_Find_Discrete_Data( sourceFile, sourceObjectID, -1, nil,													kHera_Object_Type);			mAssert( sourceObjectData != nil);			if ( sourceObjectData == nil) goto HD_Action_Copy_error;						destObjectID = HD_Object_Copy( sourceFile, sourceObjectData, destFile);			destAction = (objectActionType *)HD_DiscreteData_GetNthElement( destActionData,				kHera_Action_Type, i);			mAssert( destAction != nil);			destAction->argument.createObject.whichBaseType = destObjectID;		} else if (( sourceAction->verb == kAlter) &&			( sourceAction->argument.alterObject.alterType ==				kAlterBaseType))		{			sourceObjectID = sourceAction->argument.alterObject.minimum;									sourceObjectData = HD_Find_Discrete_Data( sourceFile, sourceObjectID, -1, nil,													kHera_Object_Type);			mAssert( sourceObjectData != nil);			if ( sourceObjectData == nil) goto HD_Action_Copy_error;						destObjectID = HD_Object_Copy( sourceFile, sourceObjectData, destFile);			destAction = (objectActionType *)HD_DiscreteData_GetNthElement( destActionData,				kHera_Action_Type, i);			mAssert( destAction != nil);			destAction->argument.alterObject.minimum = destObjectID;		}	}		return ((heraDataHeaderType *)*destActionData)->id;	HD_Action_Copy_error:	return -1;}void HD_Scenario_Copy( heraScenarioFileType *sourceFile, Handle sourceScenarioData,	long sourceIndex, heraScenarioFileType *destFile, Handle destScenarioData,	long destIndex){	long						number, sourceID, destID, i, levelNameStrNum;	Handle						sourceData, destData;	scenarioType				*sourceScenario, *destScenario;	scenarioInitialType			*sourceInitial, *destInitial;	scenarioConditionType		*sourceCondition, *destCondition;	briefPointType				*sourceBriefPoint, *destBriefPoint;		// first copy the actual scenario data		destScenario = ((scenarioType *)*destScenarioData) + destIndex;	levelNameStrNum = destScenario->levelNameStrNum;		BlockMove( *sourceScenarioData + ( sourceIndex * sizeof( scenarioType)),		*destScenarioData + ( destIndex * sizeof( scenarioType)), sizeof( scenarioType));			destScenario = ((scenarioType *)*destScenarioData) + destIndex;	destScenario->levelNameStrNum = levelNameStrNum;		// first copy initial objects		sourceScenario = ((scenarioType *)*sourceScenarioData) + sourceIndex;		sourceID = sourceScenario->initialFirst;	number = sourceScenario->initialNum;	sourceData = HD_Find_Discrete_Data( sourceFile,						sourceID, number,						nil, kHera_Initial_Type);	mAssert( sourceData != nil);	if ( sourceData == nil) goto HD_Scenario_Copy_error;		// err		destScenario = ((scenarioType *)*destScenarioData) + destIndex;		destID = HD_Get_NextID_From_Type( destFile, kHera_Action_Type);		destData = HD_Create_Discrete_Data( destFile, nil,		0, number, destID, kHera_Initial_Type);			if ( destData == nil) goto HD_Scenario_Copy_error;	// err		destID = ((heraDataHeaderType *)*destData)->id;		destScenario = ((scenarioType *)*destScenarioData) + destIndex;	destScenario->initialFirst = destID;		sourceInitial = (scenarioInitialType *)HD_DiscreteData_GetNthElement( sourceData,		kHera_Initial_Type, 0);	destInitial = (scenarioInitialType *)HD_DiscreteData_GetNthElement( destData,		kHera_Initial_Type, 0);			if (( sourceInitial != nil) && ( destInitial != nil))		BlockMove( sourceInitial, destInitial, sizeof( scenarioInitialType) *			number);	HD_DiscreteData_SetAllFlags(		destFile, 0, 0, 0xffffffff);	HD_DiscreteData_ClearAllRealIndexes(		destFile, 0);	// walk through all initial objects and copy all their base objects	for ( i = 0; i < number; i++)	{		long			baseObjectClass;		Handle			discreteObjectData = nil;		baseObjectType	*base;				sourceInitial = (scenarioInitialType *)			HD_DiscreteData_GetNthElement( sourceData,				kHera_Initial_Type, i);				mAssert( sourceInitial != nil);				discreteObjectData = HD_Find_Discrete_Data( sourceFile,			sourceInitial->type, 1, nil, kHera_Object_Type);				mAssert( discreteObjectData != nil);		if ( discreteObjectData != nil)		{			long		baseClass, baseRace, objectID;			objectID = HD_Object_Copy( sourceFile, discreteObjectData, destFile);						destInitial = (scenarioInitialType *)				HD_DiscreteData_GetNthElement( destData,					kHera_Initial_Type, i);			mAssert( destInitial != nil);			destInitial->type = objectID;					base = (baseObjectType *)HD_DiscreteData_GetNthElement(				discreteObjectData, kHera_Object_Type, 0);						mAssert( base != nil);			baseClass = base->baseClass;			baseRace = base->baseRace;						if ( base->attributes & kCanAcceptBuild)			{				long	m;					//						BPMOWritePString("\pobject can build; checking텦r");				for ( m = 0; m < kMaxTypeBaseCanBuild; m++)				{	//							BPMOWritePString("\pbuild slot\t");	//							BPMOWriteLong( m);	//							BPMOWritePString("\p\r------------\r");										sourceInitial = (scenarioInitialType *)						HD_DiscreteData_GetNthElement( sourceData,							kHera_Initial_Type, i);					if ( sourceInitial->canBuild[m] > 0)					{						discreteObjectData =								HD_DiscreteData_GetNextOfType(										sourceFile, nil, kHera_Object_Type);											while ( discreteObjectData != nil)						{							sourceInitial = (scenarioInitialType *)								HD_DiscreteData_GetNthElement( sourceData,									kHera_Initial_Type, i);							base = (baseObjectType *)								HD_DiscreteData_GetNthElement(								discreteObjectData, kHera_Object_Type, 0);							if (									(										base->baseClass ==											sourceInitial->canBuild[m]									)									&&									(										HD_IsRaceLegalForScenarioPlayer(										sourceFile,  sourceScenarioData,										sourceIndex,										 base->baseRace,										 -1)									)								)							{	//										BPMOWritePString("\pwalking:\t");	//										BPMOWriteLong( ((heraDataHeaderType *)*discreteObjectData)->id);	//										BPMOWritePString("\p\r");																HD_Object_Copy( sourceFile, discreteObjectData, destFile);							}							discreteObjectData =								HD_DiscreteData_GetNextOfType(									sourceFile, 									discreteObjectData,									kHera_Object_Type);						}					}				}			} else if ((!( destInitial->attributes & kFixedRace)) &&				( baseObjectClass > 0) && ( HD_IsScenarioNetworkable(					sourceScenarioData, sourceIndex)) &&					( destInitial->owner >= 0))			{				// if initial object's race is not fixed, we have to run through				// all objects that match specified class				discreteObjectData =						HD_DiscreteData_GetNextOfType( sourceFile, 								nil, kHera_Object_Type);				while ( discreteObjectData != nil)				{					destInitial = (scenarioInitialType *)						HD_DiscreteData_GetNthElement( destData,							kHera_Initial_Type, i);					base = (baseObjectType *)						HD_DiscreteData_GetNthElement(						discreteObjectData, kHera_Object_Type, 0);										if (( base->baseClass == baseClass) &&						( HD_IsRaceLegalForScenarioPlayer( sourceFile, 							 sourceScenarioData, sourceIndex,							 base->baseRace,							 destInitial->owner)))					{						HD_Object_Copy( sourceFile, discreteObjectData, destFile);					}					discreteObjectData =						HD_DiscreteData_GetNextOfType( sourceFile, 								discreteObjectData, kHera_Object_Type);				}			}				}	}					// now must copy over conditions		sourceScenario = ((scenarioType *)*sourceScenarioData) + sourceIndex;		sourceID = sourceScenario->conditionFirst;	number = sourceScenario->conditionNum;	sourceData = HD_Find_Discrete_Data( sourceFile,						sourceID, number,						nil, kHera_Condition_Type);	mAssert( sourceData != nil);	if ( sourceData == nil) goto HD_Scenario_Copy_error;		// err		destScenario = ((scenarioType *)*destScenarioData) + destIndex;		destID = HD_Get_NextID_From_Type( destFile, kHera_Action_Type);		destData = HD_Create_Discrete_Data( destFile, nil,		0, number, destID, kHera_Condition_Type);			if ( destData == nil) goto HD_Scenario_Copy_error;	// err		destID = ((heraDataHeaderType *)*destData)->id;		destScenario = ((scenarioType *)*destScenarioData) + destIndex;	destScenario->conditionFirst = destID;		sourceCondition = (scenarioConditionType *)HD_DiscreteData_GetNthElement( sourceData,		kHera_Condition_Type, 0);	destCondition = (scenarioConditionType *)HD_DiscreteData_GetNthElement( destData,		kHera_Condition_Type, 0);			if (( sourceCondition != nil) && ( destCondition != nil))		BlockMove( sourceCondition, destCondition, sizeof( scenarioConditionType) *			number);	for ( i = 0; i < number; i++)	{		Handle	discreteActionData;		long	actionID;				sourceCondition = (scenarioConditionType *)HD_DiscreteData_GetNthElement( sourceData,			kHera_Condition_Type, i);		discreteActionData = HD_Find_Discrete_Data( sourceFile,			sourceCondition->startVerb, sourceCondition->verbNum, nil, kHera_Action_Type);				actionID = HD_Action_Copy( sourceFile, discreteActionData, destFile);				destCondition = (scenarioConditionType *)HD_DiscreteData_GetNthElement( destData,			kHera_Condition_Type, i);		destCondition->startVerb = actionID;	}		// that's it for deep copying!	// now must copy over briefing points		sourceScenario = ((scenarioType *)*sourceScenarioData) + sourceIndex;		sourceID = sourceScenario->briefPointFirst;	number = sourceScenario->briefPointNum & kScenarioBriefMask;	if ( sourceID > 0)	{			sourceData = HD_Find_Discrete_Data( sourceFile,							sourceID, number,							nil, kHera_BriefPoint_Type);		mAssert( sourceData != nil);		if ( sourceData == nil) goto HD_Scenario_Copy_error;		// err				destScenario = ((scenarioType *)*destScenarioData) + destIndex;				destID = HD_Get_NextID_From_Type( destFile, kHera_Action_Type);				destData = HD_Create_Discrete_Data( destFile, nil,			0, number, destID, kHera_BriefPoint_Type);					if ( destData == nil) goto HD_Scenario_Copy_error;	// err				destID = ((heraDataHeaderType *)*destData)->id;				destScenario = ((scenarioType *)*destScenarioData) + destIndex;		destScenario->briefPointFirst = destID;				sourceBriefPoint = (briefPointType *)HD_DiscreteData_GetNthElement( sourceData,			kHera_BriefPoint_Type, 0);		destBriefPoint = (briefPointType *)HD_DiscreteData_GetNthElement( destData,			kHera_BriefPoint_Type, 0);					if (( sourceBriefPoint != nil) && ( destBriefPoint != nil))			BlockMove( sourceBriefPoint, destBriefPoint, sizeof( briefPointType) *				number);	} else	{		destScenario = ((scenarioType *)*destScenarioData) + destIndex;		destScenario->briefPointFirst = -1;	}HD_Scenario_Copy_error:	return;}