/******************************************\|**| Navigation_Utilities.c\******************************************/#pragma mark ••INCLUDES••/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#include <Navigation.h>#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Window Dispatch.h"#include "str_bp.h"#pragma mark _this library includes_/* - this project*******************************************/#include "Navigation_Utilities.h"#pragma mark ••DEFINITIONS••/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kMaxDocumentCount		100		// maximum number of documents allowed#define kSelectObjectPrefKey	7#pragma mark _macros_/* - macros*******************************************/#pragma mark ••TYPEDEFS••/******************************************\|**| typedefs\******************************************//*typedef struct Document{	WindowPtr		theWindow;	TEHandle		theTE;	short			docTop;	RgnHandle		hiliteRgn;		ControlHandle	vScroll;	ControlHandle	hScroll;	short			vScrollPos;		short			fRefNum;	short			dirty;		Handle			undoDragText;	short			undoSelStart;	short			undoSelEnd;		short			lastSelStart;	short			lastSelEnd;	ParamBlockRec	fioParamBlock;			// param block for file I/O operations	Handle			fPict;	Handle			fHeader;	long			fPictLength;} Document;*/#pragma mark ••EXTERNAL GLOBALS••/******************************************\|**| external globals\******************************************/#pragma mark ••PRIVATE GLOBALS••/******************************************\|**| private globals\******************************************///Document* gDocumentList[kMaxDocumentCount];#pragma mark ••PRIVATE PROTOTYPES••/******************************************\|**| private function prototypes\******************************************/pascal void myEventProc(const NavEventCallbackMessage callBackSelector, 						NavCBRecPtr callBackParms, 						NavCallBackUserData callBackUD);OSErr AEGetDescData(const AEDesc *desc, DescType *typeCode, void *dataBuffer, ByteCount maximumSize, ByteCount *actualSize);#pragma mark ••PRIVATE FUNCTIONS••/******************************************\|**| private functions\******************************************/#pragma mark ••PUBLIC FUNCTIONS••/******************************************\|**| public functions\******************************************/OSErr NS_SelectFileObject( FSSpecPtr destFile, short openListResID){		NavReplyRecord		theReply;	NavDialogOptions	dialogOptions;	OSErr				theErr = noErr;	NavEventUPP			eventUPP = NewNavEventUPP(myEventProc);	NavTypeListHandle	openList = nil;		theErr = NavGetDefaultDialogOptions(&dialogOptions);	//	GetIndString(dialogOptions.message,rAppStringsID,sChooseObject);		if ( openListResID > 0)	{		openList = (NavTypeListHandle)GetResource( 'open', openListResID);	}	dialogOptions.preferenceKey = kSelectObjectPrefKey;	dialogOptions.dialogOptionFlags |= kNavSelectAllReadableItem;//kNavNoTypePopup;	theErr = //NavChooseObject			NavGetFile						(	NULL,								&theReply,								&dialogOptions,								eventUPP,								nil,								nil,								(NavTypeListHandle)openList,								(NavCallBackUserData)nil/*&gDocumentList*/);	#ifndef TARGET_API_MAC_CARBON	DisposeRoutineDescriptor(eventUPP);#else	DisposeNavEventUPP( eventUPP);#endif	if ((theReply.validRecord)&&(theErr == noErr))		{		// grab the target FSSpec from the AEDesc:	//		FSSpec		finalFSSpec;			AEDesc 		resultDesc;//		AliasHandle	alias;		AEKeyword	theKeyword;		DescType	actualType;		Size		actualSize;		/*		if ((theErr = AECoerceDesc(&(theReply.selection),typeFSS,&resultDesc)) ==			noErr)			if ((theErr = AEGetDescData ( &resultDesc, NULL, destFile,					sizeof ( FSSpec ), NULL )) == noErr)				{				// 'finalFSSpec' is the selected directory…				//				theErr = NewAlias( &finalFSSpec, destFile, &alias);//				if ( theErr != noErr) return theErr;//				DisposeHandle( (Handle)alias);				}*/				theErr = AEGetNthPtr( &(theReply.selection), 1, typeFSS, &theKeyword,								&actualType,								destFile, sizeof( FSSpec), &actualSize);								 		AEDisposeDesc(&resultDesc);		//		theErr = NavDisposeReply(&theReply);		}		if ( openList != nil) ReleaseResource( (Handle)openList);		return theErr;}OSErr NS_SelectFolderObject( FSSpecPtr destFile, StringPtr windowName,	StringPtr prompt){		NavReplyRecord		theReply;	NavDialogOptions	dialogOptions;	OSErr				theErr = noErr;	NavEventUPP			eventUPP = NewNavEventUPP(myEventProc);		theErr = NavGetDefaultDialogOptions(&dialogOptions);	//	GetIndString(dialogOptions.message,rAppStringsID,sChooseObject);		if ( windowName != nil)		pstrcpy( dialogOptions.windowTitle, windowName);		if ( prompt != nil)		pstrcpy( dialogOptions.message, prompt);			dialogOptions.preferenceKey = kSelectObjectPrefKey;		theErr = NavChooseFolder(	NULL,								&theReply,								&dialogOptions,								eventUPP,								NULL,								(NavCallBackUserData)nil/*&gDocumentList*/);	#ifndef TARGET_API_MAC_CARBON	DisposeRoutineDescriptor(eventUPP);#else	DisposeNavEventUPP( eventUPP);#endif TARGET_API_MAC_CARBON	if ((theReply.validRecord)&&(theErr == noErr))	{		AEDesc 		resultDesc;		AEKeyword	theKeyword;		DescType	actualType;		Size		actualSize;				theErr = AEGetNthPtr( &(theReply.selection), 1, typeFSS, &theKeyword,								&actualType,								destFile, sizeof( FSSpec), &actualSize);								 /*		if ((theErr = AECoerceDesc(&(theReply.selection),typeFSS,&resultDesc)) ==			noErr)			if ((theErr = AEGetDescData ( &resultDesc, NULL, destFile,					sizeof ( FSSpec ), NULL )) == noErr)				{				// 'finalFSSpec' is the selected directory…				//				theErr = NewAlias( &finalFSSpec, destFile, &alias);//				if ( theErr != noErr) return theErr;//				DisposeHandle( (Handle)alias);				}*///		AEDisposeDesc(&resultDesc); // <- this was making it crash is os x			// duh, not used		theErr = NavDisposeReply(&theReply);		}			return theErr;}OSErr NS_SaveAs( FSSpecPtr destFile, StringPtr fileName, StringPtr appName,	OSType fileTypeToSave, OSType fileCreator, Boolean *isStationery){	OSErr				theErr = noErr;	short				result = true;	NavReplyRecord		theReply;	NavDialogOptions	dialogOptions;	NavEventUPP			eventUPP = NewNavEventUPP(myEventProc);//	OSType				fileTypeToSave = 'rsrc';	if ( isStationery != nil) *isStationery = false;		// default behavior for browser and dialog:	NavGetDefaultDialogOptions(&dialogOptions);	// user might want to translate the saveed doc into another format//	dialogOptions.dialogOptionFlags -= kNavDontAddTranslateItems;//	GetWTitle(theDocument->theWindow,dialogOptions.savedFileName);//	GetIndString((unsigned char*)&dialogOptions.clientName,rAppStringsID,sApplicationName);	pstrcpy( dialogOptions.savedFileName, fileName);	pstrcpy( dialogOptions.clientName, appName);	//	if (theDocument->theTE != NULL)	// which document type is it?//		fileTypeToSave = kFileType;//	else//		fileTypeToSave = kFileTypePICT;	dialogOptions.preferenceKey = 2; // save button	theErr = NavPutFile(NULL,	// use system's default location						&theReply,						&dialogOptions,						eventUPP,						fileTypeToSave,						fileCreator,						(NavCallBackUserData)nil/*&gDocumentList*/);#ifndef TARGET_API_MAC_CARBON	DisposeRoutineDescriptor(eventUPP);#else	DisposeNavEventUPP( eventUPP);;#endif TARGET_API_MAC_CARBON	if (theReply.validRecord && theErr == noErr)		{//		FSSpec	finalFSSpec;			AEDesc 	resultDesc;			resultDesc.dataHandle = 0L;				*isStationery = theReply.isStationery;				// retrieve the returned selection:		if ((theErr = AEGetNthDesc(&(theReply.selection),1,typeFSS,NULL,&resultDesc)) == noErr)			{#ifndef TARGET_API_MAC_CARBON						BlockMoveData((void *)*resultDesc.dataHandle, (void *)destFile,							sizeof(FSSpec));#else			AEGetDescData( &resultDesc, (void *)destFile, sizeof( FSSpec));#endif TARGET_API_MAC_CARBON			if ( theReply.replacing)			{				result = theErr = FSpDelete( destFile);			} else theErr = noErr;			//			if (!theReply.replacing)			if ( theErr == noErr)				{//				result = FSpCreate(destFile,fileCreator,fileTypeToSave,//						theReply.keyScript);				FSpCreateResFile( destFile, fileCreator, fileTypeToSave,					theReply.keyScript);				result = ResError();								if (result != noErr)					{					SysBeep(5);					return result;					}				}				//			if (theDocument->fRefNum)//				result = FSClose(theDocument->fRefNum);			//			result = FSpOpenDF(destFile,fsRdWrPerm,&theDocument->fRefNum);//			if (result)//				{//				SysBeep(5);//				return result;//				}//			if (result = WriteFile(theDocument))//				return result;			AEDisposeDesc(&resultDesc);			theErr = NavCompleteSave(&theReply,kNavTranslateInPlace);//			SetWTitle(theDocument->theWindow,(unsigned char*)finalFSSpec.name);//			theDocument->dirty = false;			}		NavDisposeReply(&theReply);		}	else		result = theErr;	return result;}// *****************************************************************************// *// *	myEventProc()	// *// *****************************************************************************pascal void myEventProc(const NavEventCallbackMessage	callBackSelector, 						NavCBRecPtr						callBackParms, 						NavCallBackUserData				callBackUD){#pragma unused (callBackUD)	WindowPtr	pWindow = NULL;//	Document**	docList;//	Document*	theDoc = NULL;	short 		index = 0;	NavEventData	neData = callBackParms->eventData;	//	if (callBackUD != 0)	switch (callBackSelector)	{		case kNavCBEvent:		{//				docList = (Document**)callBackUD;//				if (docList != NULL)			switch (callBackParms->eventData.eventDataParms.event->what)			{				case nullEvent:					break;									case updateEvt:					pWindow = (WindowPtr)callBackParms->eventData.eventDataParms.event->message;	//							theDoc = docList[index];					if ( !DispatchWindowHandleEvent(						callBackParms->eventData.eventDataParms.event, nil))					{	//								if (theDoc != NULL)						{	//									while ((theDoc->theWindow != pWindow) && (docList[index] != NULL))								{								index++;	//										theDoc = docList[index];								}	//									theDoc = docList[index];	//									if (theDoc != NULL)							{	//									UpdateWindow(theDoc);								{									BeginUpdate( pWindow);									EndUpdate( pWindow);								}							}						}					}					break;				case activateEvt:					break;				default:					break;			}				break;				}			}}OSErr AEGetDescData(const AEDesc *desc, DescType *typeCode, void *dataBuffer, ByteCount maximumSize, ByteCount *actualSize){	*typeCode = desc->descriptorType;	Handle h = (Handle)desc->dataHandle;	ByteCount dataSize = GetHandleSize(h);	if (dataSize > maximumSize)		*actualSize = maximumSize;	else		*actualSize = dataSize;	BlockMoveData(*h, dataBuffer, *actualSize);	return noErr;}