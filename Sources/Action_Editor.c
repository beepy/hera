/******************************************\|**| Action_Editor.c\******************************************/#pragma mark ¥¥INCLUDES¥¥/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Window Dispatch.h"#include "Control Utilities.h"#include "Hewey.h"#include "Hewey_Main.h"#include "Hewey_Layout.h"#include "Hewey_Utilities.h"#include "str_bp.h"#include "Set Font By String.h"#include "BP_Error.h"#include "Assert.h"#include "strlist.h"#include "Hewey_Helpers.h"#include "PsuedoColumn_Utilities.h"#include "List_Utilities.h"#include "BPMacOutput.h"#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/#include "Action_Editor.h"#include "Space Object.h"#include "Hera_Global.h"#include "Hera_Name_Maker.h"#include "Hera_Utilities.h"#include "Bit_Flipper.h"#include "Button_Window.h"#include "Hera_Data.h"#include "Object_Editor.h"#include "TextEditor.h"#include "Sound_Selector.h"#pragma mark ¥¥DEFINITIONS¥¥/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kLarge_Tab_Width				112#define	kEditTextBigFieldWidth			75//150#define	kEditTextFieldWidth				50#define	kEditTextSmallFieldWidth		16#define	kColNum							2#define	kRowNum							3#define	kMain_Cell_X					1#define	kMain_Cell_Y					0#define	kMain_ID_Offset					100#define	kSeparator_Cell_X				0#define	kSeparator_Cell_Y				1#define	kSeparator_ID					200#define	kButton_Cell_X					0#define	kButton_Cell_Y					2#define	kOK_Button_ID					1#define	kCancel_Button_ID				2#define	kRevert_Button_ID				3#define	kSmallFontSize					gHera->smallFontSize#define	kSmallFontNum					gHera->smallFontNum#define	kLargeFontNum					gHera->bigFontNum;#define kLargeFontSize					gHera->bigFontSize;#define	kList_Master_Cell_X				0#define	kList_Master_Cell_Y				0#define	kList_Master_ColNum				2#define	kList_Master_RowNum				3			#define	kList_ID						6#define	kList_Title_Cell_X				1#define	kList_Title_Cell_Y				0#define	kList_Cell_X					1#define	kList_Cell_Y					1#define	kList_Button_Cell_X				1#define	kList_Button_Cell_Y				2#define	kList_Button_ID_Offset			300#define	kList_Remove_Button_ID			(kList_Button_ID_Offset + 2)#define	kList_Add_Button_ID				(kList_Button_ID_Offset + 4)#define	kList_Title_ID					(kList_Button_ID_Offset + 6)#define	kSuperList_ID					10#define	kSuperList_Cell_X				0#define	kSuperList_Cell_Y				1#define	kSuperList_Title_Cell_X			0#define	kSuperList_Title_Cell_Y			0#define	kSuperList_Button_Cell_X		0#define	kSuperList_Button_Cell_Y		2#define	kSuperList_Button_ID_Offset		700#define	kSuperList_Add_Button_ID		(kSuperList_Button_ID_Offset + 2)#define	kSuperList_Title_ID				(kSuperList_Button_ID_Offset + 6)#define	kMain_Master_ColNum				1#define	kMain_Master_RowNum				2#define	kArgument_Popup_ID				600#define	kArgument_Panel_Num				24#define	kArgument_Master_Cell_X			0#define	kArgument_Master_Cell_Y			0#define	kArgument_Master_ColNum			1#define	kArgument_Master_RowNum			2#define	kArgument_Main_Cell_X			0#define	kArgument_Main_Cell_Y			0// CO = create object#define	kCO_Panel_Index					kCreateObject#define	kCO_ID_Offset					(kCO_Panel_Index * 2000)#define	kCO_whichBaseType				(kCO_ID_Offset + 2)#define	kCO_howManyMinimum				(kCO_ID_Offset + 4)#define	kCO_howManyRange				(kCO_ID_Offset + 6)#define	kCO_velocityRelative			(kCO_ID_Offset + 8)#define	kCO_directionRelative			(kCO_ID_Offset + 10)#define	kCO_randomDistance				(kCO_ID_Offset + 12)#define	kCO_Select_Object_Button_ID		(kCO_ID_Offset + 14)// PS = play sound#define kPS_Panel_Index					kPlaySound#define	kPS_ID_Offset					(kPS_Panel_Index * 2000)#define	kPS_priority					(kPS_Panel_Index + 2)#define	kPS_persistence					(kPS_Panel_Index + 4)#define	kPS_absolute					(kPS_Panel_Index + 6)#define	kPS_volumeMinimum				(kPS_Panel_Index + 8)#define	kPS_volumeRange					(kPS_Panel_Index + 10)#define	kPS_idMinimum					(kPS_Panel_Index + 12)#define kPS_idRange						(kPS_Panel_Index + 14)#define	kPS_chooseSound					(kPS_Panel_Index + 16)// AL = alkter#define	kAL_Panel_Index					kAlter#define	kAL_Panel_Num					27#define	kAL_Master_Cell_X				0#define	kAL_Master_Cell_Y				1#define	kAL_Master_ColNum				1#define	kAL_Master_RowNum				1#define	kAL_Popup_Group_ID				800#define	kAlter_Field_Str_Res_ID			8016#define	kAlter_Field_ID_Offset			(1600)#define	kAlter_Field_ID_Multiplier		16#define	kAlter_BaseType_Select_Button_ID	1598// MS = make sparks#define	kMS_Panel_Index					kMakeSparks#define	kMS_ID_Offset					(kMS_Panel_Index * 2000)#define	kMS_howMany						(kMS_ID_Offset + 2)#define	kMS_speed						(kMS_ID_Offset + 4)#define	kMS_velocityRange				(kMS_ID_Offset + 6)#define	kMS_color						(kMS_ID_Offset + 8)// RE = release energy#define	kRE_Panel_Index					kReleaseEnergy#define	kRE_ID_Offset					(kRE_Panel_Index * 2000)#define	kRE_percent						(kRE_ID_Offset + 2)// LA = land at#define	kLA_Panel_Index					kLandAt#define	kLA_ID_Offset					(kLA_Panel_Index * 2000)#define	kLA_landingSpeed				(kLA_ID_Offset + 2)// AI = assume initial#define	kAI_Panel_Index					kAssumeInitialObject#define	kAI_ID_Offset					(kAI_Panel_Index * 2000)#define	kAI_whichInitialObject			(kAI_ID_Offset + 2)// EW = enter warp#define	kEW_Panel_Index					kEnterWarp#define	kEW_ID_Offset					(kEW_Panel_Index * 2000)#define	kEW_warpSpeed					(kEW_ID_Offset + 2)// DM = display message#define	kDM_Panel_Index					kDisplayMessage#define	kDM_ID_Offset					(kDM_Panel_Index * 2000)#define	kDM_resID						(kDM_ID_Offset + 2)#define	kDM_pageNum						(kDM_ID_Offset + 4)// CS = change score#define	kCS_Panel_Index					kChangeScore#define	kCS_ID_Offset					(kCS_Panel_Index * 2000)#define kCS_whichPlayer					(kCS_ID_Offset + 2)#define	kCS_whichScore					(kCS_ID_Offset + 4)#define	kCS_amount						(kCS_ID_Offset + 6)// DW = declare winner#define	kDW_Panel_Index					kDeclareWinner#define	kDW_ID_Offset					(kDW_Panel_Index * 2000)#define	kDW_whichPlayer					(kDW_ID_Offset + 2)#define kDW_nextLevel					(kDW_ID_Offset + 4)#define	kDW_textID						(kDW_ID_Offset + 6)#define	kDW_Select_Text_Button_ID		(kDW_ID_Offset + 8)// KO = kill object#define	kKO_Panel_Index					kDie#define	kKO_ID_Offset					(kKO_Panel_Index * 2000)#define	kKO_dieType						(kKO_ID_Offset + 2)// CF = color flash#define	kCF_Panel_Index					kColorFlash#define	kCF_ID_Offset					(kCF_Panel_Index * 2000)#define	kCF_length						(kCF_ID_Offset + 2)#define	kCF_color						(kCF_ID_Offset + 4)#define	kCF_shade						(kCF_ID_Offset + 6)// kDK = disable keys#define	kDK_Panel_Index					kDisableKeys#define	kDK_ID_Offset					(kDK_Panel_Index * 2000)#define	kDK_keyMask						(kDK_ID_Offset + 2)#define	kDK_keyMask_Set_ID				(kDK_ID_Offset + 4)// kEK = enable keys#define	kEK_Panel_Index					kEnableKeys#define	kEK_ID_Offset					(kEK_Panel_Index * 2000)#define	kEK_keyMask						(kEK_ID_Offset + 2)#define	kEK_keyMask_Set_ID				(kEK_ID_Offset + 4)// kSZ = set zoom#define	kSZ_Panel_Index					kSetZoom#define	kSZ_ID_Offset					(kSZ_Panel_Index * 2000)#define	kSZ_zoomLevel					(kSZ_ID_Offset + 2)// kMC = minicomputer select#define	kMC_Panel_Index					kComputerSelect#define	kMC_ID_Offset					(kMC_Panel_Index * 2000)#define	kMC_screenNumber				(kMC_ID_Offset + 2)#define	kMC_lineNumber					(kMC_ID_Offset + 4)// qualifier cell#define	kQualifier_Master_Cell_X		0#define	kQualifier_Master_Cell_Y		1#define	kQualifier_Master_ColNum		2#define	kQualifier_Master_RowNum		1#define	kQualifier_Cell_X				0#define	kQualifier_Cell_Y				0#define	kQualifier_ID_Offset			400#define	kQualifier_Inclusive_ID			(kQualifier_ID_Offset + 2)#define	kQualifier_Inclusive_Button_ID	(kQualifier_ID_Offset + 4)#define kQualifier_Exclusive_ID			(kQualifier_ID_Offset + 6)#define	kQualifier_Exclusive_Button_ID	(kQualifier_ID_Offset + 8)#define	kQualifier_Delay_ID				(kQualifier_ID_Offset + 10)#define	kQualifier_Subject_ID			(kQualifier_ID_Offset + 12)#define kQualifier_Direct_ID			(kQualifier_ID_Offset + 14)#define	kQualifier_Reflexive_ID			(kQualifier_ID_Offset + 16)#define	kQualifier_LevelKey_ID			(kQualifier_ID_Offset + 18)#define	kOwner_Cell_X					1#define	kOwner_Cell_Y					0#define	kOwner_Group_ID					500#define	kOwner_Enemy_ID					(kOwner_Group_ID + 2)#define	kOwner_Any_ID					(kOwner_Group_ID + 4)#define	kOwner_Friend_ID				(kOwner_Group_ID + 6)#define	kStrResID						8015#define	kSortByID						0#define	kSortByName						1#pragma mark _macros_/* - macros*******************************************/#pragma mark ¥¥TYPEDEFS¥¥/******************************************\|**| typedefs\******************************************/typedef struct Action_EditorWindowType{	heraScenarioFileType			*heraFile;	huiMasterControlType			*master;	huiMasterControlType			*mainMaster;	// just for 3 cells of main panel	huiMasterControlType			*argument;			// for changing action fields	huiMasterControlType			*qualifier;	huiMasterControlType			*alter;	// for changing alter verb fields	huiMasterControlType			*listMaster;	long							windowID;	short							resRefNum;	long							startActionIndex;	long							actionNumber;	long							whatAlter;	long							whatAction;	Handle							actionData;	long							whichAction;	long							setInclusive_WindowID;	long							setExclusive_WindowID;	long							setKeyMask_WindowID;	objectActionType				action;	Handle							discreteData;	Boolean							selectActionData;	Boolean							chooseOnly;	long							columnFix;	long							superActionIndex;	long							superActionID;	long							sortBy;	Action_Editor_Callback_procPtr	callBack;	long							callerID;	Str255							titlePrefix;} Action_EditorWindowType;#pragma mark ¥¥EXTERNAL GLOBALS¥¥/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark ¥¥PRIVATE GLOBALS¥¥/******************************************\|**| private globals\******************************************/#pragma mark ¥¥PRIVATE PROTOTYPES¥¥/******************************************\|**| private function prototypes\******************************************/static Boolean HandleEvent( EventRecord *, CWindowPtr, long, long);static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID);static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID);static Boolean Handle_Control_Click( Action_EditorWindowType *d,	CWindowPtr whichWindow,	long dispatchID, ControlHandle aControl, huiPlainControlType *hui,	short whichPart, EventRecord *theEvent);static void ChangeSuperAction( Action_EditorWindowType *d, CWindowPtr window,	long newSuperActionIndex);static void OK_Button( Action_EditorWindowType *d);static void Cancel_Button( Action_EditorWindowType *d);static void OKConfirmCallBack( long whichButton, long windowID);static void CancelConfirmCallBack( long whichButton, long windowID);static void Revert_Button( Action_EditorWindowType *d);static void ChangeActionNumber( Action_EditorWindowType *d, long newActionNumber);static void ChangeAlterNumber( Action_EditorWindowType *d, long newAlterNumber);static OSErr Setup_Argument_Panel( Action_EditorWindowType *d, CWindowPtr window);static void AddEditField( huiPlainControlParamType *param, long id, short resID, short index,	Boolean newLine, long fieldWidth);static void AddPopUp( huiPlainControlParamType *textParam, 	huiPlainControlParamType *buttonParam, long id, short resID, short index,	Boolean newLine, short menuStrResID);static void AddBitPopUp(  huiPlainControlParamType *textParam, 	huiPlainControlParamType *buttonParam, long id, short resID, short index,	Boolean newLine, short menuStrResID);static void GetAllData( Action_EditorWindowType *d);static void SetUpSuperList( Action_EditorWindowType *d);static void Window_SetControls_FromActionIndex( Action_EditorWindowType *d, CWindowPtr window,	long index);static void Window_SetAction_FromControls( Action_EditorWindowType *d, CWindowPtr window,	long index);static void SetActionField( Action_EditorWindowType *d, huiPlainControlParamType *dummyParam,	objectActionType *a, long id, Boolean draw);static void GetActionField( Action_EditorWindowType *d, huiPlainControlParamType *dummyParam,	objectActionType *a, long id);static OSErr SortSuperList( Action_EditorWindowType *d, Boolean draw);static short CompareCellsByName( Ptr cell_a, long length_a, Ptr cell_b, long length_b);static short CompareCellsByID( Ptr cell_a, long length_a, Ptr cell_b, long length_b);static void SetInclusiveBits( long windowID, unsigned long bits);static void SetExclusiveBits( long windowID, unsigned long bits);static void SetKeyBits( long windowID, unsigned long bits);static void CreateObject_Choose_CallBack( long dispatchID, long objectChoiceID);static void AlterBaseType_Choose_CallBack( long dispatchID, long objectChoiceID);static void WinningTextCallBack( long windowID, long resID);static void ChooseSoundCallBack( long windowID, long resID);static void InsertSequence( Action_EditorWindowType *d, CWindowPtr whichWindow);static void InsertAction( Action_EditorWindowType *d, CWindowPtr whichWindow);static void DeleteAction( Action_EditorWindowType *d, CWindowPtr whichWindow);static void Enable_Editing( Action_EditorWindowType *d, Boolean enable);#pragma mark ¥¥PRIVATE FUNCTIONS¥¥/******************************************\|**| private functions\******************************************/static Boolean HandleEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID, long command){	switch( command)	{		case kWDCloseWindowCommand:			break;				case kWDProcessEventCommand:			return( ProcessEvent( theEvent, whichWindow, dispatchID));			break;				case kWDSaveWindowCommand:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these actions?",										"\pBefore saving, the Action Editor "										"must be closed. Click Cancel to "										"abort the save.", nil, nil))				{					OKConfirmCallBack( 1, dispatchID);									} else				{					gHera->currentSave = nil;				}			}			return false;			break;				case kWD_Close_ForQuit_Command:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these actions?",										"\pBefore quitting, the Action Editor "										"must be closed. Click Cancel to "										"abort the quit.", nil, nil))				{					OKConfirmCallBack( 1, dispatchID);									} else				{					gHera->currentSave = nil;					return true;				}			}			return false;			break;				case kWD_CloseForScenarioOrder_Command:			break;					case kWDProcessMenuChoiceCommand:			return( ProcessMenuChoiceCommand( (unsigned long)theEvent,				whichWindow, dispatchID));			break;	}	return false;}static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	SignedByte						dataState;	Action_EditorWindowType			*d;	Boolean							result = false;	GrafPtr							oldPort;	short							menuID = ((menuData & 0xffff0000) >> 16),									menuItem = (menuData & 0x0000ffff);										if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (Action_EditorWindowType *)*data;	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);	result = Generic_ProcessMenuChoiceCommand( menuData, whichWindow,												dispatchID);	if ( result)	{		goto ProcessMenuChoiceCommand_Return;	}		switch( menuID)	{		case kEditMenuID:			switch( menuItem)			{				case kEdit_Undo_Item:					result = true;					break;				case kEdit_Add_Item:					result = true;					break;									case kEdit_Delete_Item:					result = true;					break;									case kEdit_Delete_All_Item:					result = true;					break;			}							break;		}	ProcessMenuChoiceCommand_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);}static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Boolean							result = false;	ControlHandle					aControl, oldControl;	short							whichPart, oldValue, newValue;	WindowPtr						scratchWindow;	Point							where;	char							whichChar;	GrafPtr							oldPort;	OSStatus						err;	Action_EditorWindowType				*d;		if ( data == nil) return false;	if ( theEvent == nil) return false;		dataState = HGetState( data);	HLock( data);	d = (Action_EditorWindowType *)*data;		if ( theEvent == nil) goto ProcessEvent_Return;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);		switch( theEvent->what)	{		case nullEvent:			IdleControls( (WindowPtr)whichWindow);						result = true;			break;					case updateEvt:				BeginUpdate ((WindowPtr)whichWindow);/*			SetPort( (WindowPtr)whichWindow);			CalcVis( (WindowPtr)whichWindow);			UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);*/			HU_GenericUpdateEventHandler( whichWindow);			EndUpdate ((WindowPtr)whichWindow);			result = true;			break;		case activateEvt:		{			Boolean	isActive = ((theEvent->modifiers & activeFlag) != 0);						if ( isActive)			{				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_scenarioFile_refNum);			}		}			// result != true so dispatch window will handle activation			// of controls etc.			break;					case mouseDown:			whichPart = FindWindow (theEvent->where, &scratchWindow);			switch( whichPart)			{				case inGrow:/*					{						Rect	growRect;						long	newSize;//						growRect = qd.screenBits.bounds;						C2C_ScreenBits_GetBounds( &growRect);												growRect.top = growRect.left = 120;						newSize = GrowWindow((WindowPtr)whichWindow,							theEvent->where ,&growRect);						if (newSize != 0)						{							SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,								(((newSize) >> 16) & 0xFFFF), true );							EraseRect(&whichWindow->portRect);							InvalRect( &whichWindow->portRect);						}					}*/					HU_GenericGrowWindow( whichWindow, theEvent->where);					result = true;					break;								case inContent:					where = theEvent->where;					scratchWindow = WD_FrontWindow();					if ( whichWindow != (CWindowPtr)scratchWindow)					{						goto ProcessEvent_Return;					}					SetPortWindowPort( (WindowPtr)whichWindow);					GlobalToLocal( &where);//					whichPart = FindControl( where, (WindowPtr)whichWindow,//						&aControl);					aControl = FindControlUnderMouse( where, (WindowPtr)whichWindow,						&whichPart);					if ( aControl == nil)						goto ProcessEvent_Return;					if ( aControl != nil)						oldValue = GetControlValue( aControl);					err = GetKeyboardFocus( (WindowPtr)whichWindow,						&oldControl);					if (( err == noErr) && ( oldControl != aControl))					{						SetKeyboardFocus( (WindowPtr)whichWindow, aControl, whichPart);					}					if ( whichPart != 0)					{						huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);//						whichPart = HandleControlClick ( aControl, where,//							theEvent->modifiers, (ControlActionUPP)-1);						if ( !ListBox_Appearance_1_0_1_Hack( aControl, where,									&whichPart))						{							whichPart = HUI_Control_Click_Handle( hui, where,								theEvent->modifiers);														}								if ( whichPart != 0)						{							result = Handle_Control_Click( d,  whichWindow,								dispatchID, aControl,  hui, whichPart,								theEvent);						}					} else // not in control					{						where = theEvent->where;						GlobalToLocal( &where);					}			}			break;					case keyDown:		case autoKey:			whichChar = theEvent->message & charCodeMask;			if ((whichChar=='\r' || whichChar==0x3))			{				// ok				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kOK_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);					result = true;					OK_Button( d);					data = nil;					goto ProcessEvent_Return;				}			} else if ((whichChar==0x1b) || ((whichChar=='.') && (theEvent->modifiers & cmdKey)))			{				// cancel				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kCancel_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);										Cancel_Button( d);					data = nil;					result = true;					goto ProcessEvent_Return;				}			} else if ( whichChar == '\t')			{				if ( theEvent->modifiers & shiftKey)					ReverseKeyboardFocus( (WindowPtr)whichWindow);				else					AdvanceKeyboardFocus( (WindowPtr)whichWindow);				result = true;				break;			} else if (( whichChar == 0x08) && ( !d->chooseOnly))			{				huiPlainControlType	*hui = nil;				err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);				hui = (huiPlainControlType	*)CU_GetControlReference( aControl);				if ( hui != nil)				{					if ( hui->generic.id == kList_ID)					{						if ( HU_Confirm_Delete("\pAre you sure you "							"want to delete this action?",								theEvent->modifiers))							DeleteAction( d, whichWindow);					}				}				result = true;			}									err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);			if (( err == noErr) && ( aControl != nil))			{				whichPart = HandleControlKey( aControl,					(theEvent->message & keyCodeMask)>>16,					theEvent->message & charCodeMask, theEvent->modifiers);				{					huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);					switch( hui->generic.id)					{													case kList_ID:							oldValue = d->whichAction;							d->whichAction = HUI_Control_GetListValue(									d->listMaster, 0, kList_Cell_X - d->columnFix, kList_Cell_Y,									kList_ID, d->whichAction);														if ( d->whichAction != oldValue)							{								Window_SetAction_FromControls( d,									whichWindow, oldValue + d->startActionIndex);								Window_SetControls_FromActionIndex(									d, whichWindow, d->whichAction + d->startActionIndex									);							}							break;												case kSuperList_ID:							newValue = HUI_Control_GetListValue(									d->listMaster, 0, kSuperList_Cell_X, kSuperList_Cell_Y,									kSuperList_ID, d->whichAction);							if ( newValue != d->superActionIndex)							{								ChangeSuperAction( d, whichWindow, newValue);							}							result = true;							break;					}				}			}			break;	}		ProcessEvent_Return:	SetPort( oldPort);	if ( data != nil)		HSetState( data, dataState);	return( result);	}static Boolean Handle_Control_Click( Action_EditorWindowType *d,	CWindowPtr whichWindow,	long dispatchID, ControlHandle aControl, huiPlainControlType *hui,	short whichPart, EventRecord *theEvent){	long			oldValue, newValue;	Boolean			result = false;	switch( hui->generic.id)	{		case kSuperList_ID:			newValue = HUI_Control_GetListValue(					d->listMaster, 0, kSuperList_Cell_X, kSuperList_Cell_Y,					kSuperList_ID, d->whichAction);			if ( newValue != d->superActionIndex)			{				ChangeSuperAction( d, whichWindow, newValue);			}			result = true;			break;					case kList_ID:			oldValue = d->whichAction;						d->whichAction = HUI_Control_GetListValue(					d->listMaster, 0, kList_Cell_X - d->columnFix, kList_Cell_Y,					kList_ID, d->whichAction);			if ( d->whichAction != oldValue)			{							Window_SetAction_FromControls( d,					whichWindow, oldValue + d->startActionIndex);				Window_SetControls_FromActionIndex(					d, whichWindow, d->whichAction + d->startActionIndex);					//									ChangePanelNumber( d, d->currentPanel); // auto corrects if not				// showing right special panel			}			result = true;			break;		case kQualifier_Inclusive_ID:		{			unsigned long bit;						if ( whichPart == kControlMenuPart)			{				oldValue = GetBevelMenuValue( aControl) - 1;				bit = 0x01 << oldValue;				d->action.inclusiveFilter ^= bit;				HU_Menu_SetCheckFromBits( aControl,					d->action.inclusiveFilter, oldValue, oldValue);			}		}			break;				case kQualifier_Exclusive_ID:		{			unsigned long bit;						if ( whichPart == kControlMenuPart)			{				oldValue = GetBevelMenuValue( aControl) - 1;				bit = 0x01 << oldValue;				d->action.exclusiveFilter ^= bit;				HU_Menu_SetCheckFromBits( aControl,					d->action.exclusiveFilter, oldValue, oldValue);			}		}				case kDK_keyMask:		case kEK_keyMask:		{			unsigned long bit;						if ( whichPart == kControlMenuPart)			{				oldValue = GetBevelMenuValue( aControl) - 1;				bit = 0x01 << oldValue;				d->action.argument.keys.keyMask ^= bit;				HU_Menu_SetCheckFromBits( aControl,					d->action.argument.keys.keyMask, oldValue, oldValue);			}		}					break;		case kOK_Button_ID:			result = true;			OK_Button( d);			break;				case kRevert_Button_ID:			result = true;			Revert_Button( d);			break;				case kCancel_Button_ID:			Cancel_Button( d);			result = true;			break;				case kArgument_Popup_ID:			ChangeActionNumber( d, GetControlValue( aControl) - 1);			break;				case kAL_Popup_Group_ID:			ChangeAlterNumber( d, GetControlValue( aControl) - 1);			break;			case kQualifier_Inclusive_Button_ID:			BitFlipper_NewWindow( &d->setInclusive_WindowID,				"\pInclusive Filter",				GetStringList( 600),				d->action.inclusiveFilter, dispatchID,				SetInclusiveBits);			result = true;			break;					case kQualifier_Exclusive_Button_ID:			BitFlipper_NewWindow( &d->setExclusive_WindowID,				"\pExclusive Filter",				GetStringList( 600),				d->action.exclusiveFilter, dispatchID,				SetExclusiveBits);			result = true;			break;					case kDK_keyMask_Set_ID:		case kEK_keyMask_Set_ID:			BitFlipper_NewWindow( &d->setKeyMask_WindowID,				"\pKey Mask",				GetStringList( 8026),				d->action.argument.keys.keyMask, dispatchID,				SetKeyBits);			result = true;			break;					case kCO_Select_Object_Button_ID:			{				long 	newWindowID = -1;				Str255	tString;								pstrcpy( tString, d->titlePrefix);				pstrcat( tString, "\p: Create Object");				ObjectEditor_NewWindow( d->heraFile, &newWindowID, dispatchID,					d->action.argument.createObject.whichBaseType, tString,					d->resRefNum, true, true, false, true,					CreateObject_Choose_CallBack);			}			result = true;			break;				case kAlter_BaseType_Select_Button_ID:			{				long 	newWindowID = -1;				Str255	tString;								pstrcpy( tString, d->titlePrefix);				pstrcat( tString, "\p: Create Object");								ObjectEditor_NewWindow( d->heraFile, &newWindowID, dispatchID,					d->action.argument.alterObject.minimum, tString,					d->resRefNum, true, true, false, true,					AlterBaseType_Choose_CallBack);			}			result = true;			break;				case kDW_Select_Text_Button_ID:			TEXTEditor_NewWindow( d->heraFile,				"\pSelect Endgame Text", d->resRefNum,				dispatchID, d->action.argument.declareWinner.textID,					true, true, true, WinningTextCallBack);			result = true;			break;					// all checkboxes		case kCO_velocityRelative:		case kCO_directionRelative:		case kPS_absolute:		case kQualifier_Reflexive_ID:			ReverseCheckBox( aControl);			result = true;			break;				case kQualifier_LevelKey_ID:			ReverseCheckBox( aControl);			if ( GetControlValue( aControl))			{				HUI_Control_Hilite( d->qualifier, 0, kQualifier_Cell_X,					kQualifier_Cell_Y, kQualifier_Exclusive_ID, 0);				HUI_Control_Hilite( d->qualifier, 0, kQualifier_Cell_X,					kQualifier_Cell_Y, kQualifier_Exclusive_Button_ID, 0);			} else if ( !d->chooseOnly)			{				HUI_Control_Hilite( d->qualifier, 0, kQualifier_Cell_X,					kQualifier_Cell_Y, kQualifier_Exclusive_ID, 1);				HUI_Control_Hilite( d->qualifier, 0, kQualifier_Cell_X,					kQualifier_Cell_Y, kQualifier_Exclusive_Button_ID, 1);			}			result = true;			break;					case kList_Add_Button_ID:			InsertAction( d, whichWindow);			result = true;			break;				case kList_Remove_Button_ID:			if ( HU_Confirm_Delete("\pAre you sure you "						"want to delete this action?",								theEvent->modifiers))				DeleteAction( d, whichWindow);			result = true;			break;				case kSuperList_Add_Button_ID:			InsertSequence( d, whichWindow);			result = true;			break;				case kPS_chooseSound:			Sound_Selector_NewWindow( d->heraFile, "\pchoose sound",				-1, d->action.argument.playSound.idMinimum, d->windowID, true,				ChooseSoundCallBack);			result = true;			break;					default:			// check for non-specific alter action check boxes			if ( hui->generic.id >= kAlter_Field_ID_Offset)			{				long	whichField = hui->generic.id % kAlter_Field_ID_Multiplier;				switch( whichField)				{					case 0:	// relative						ReverseCheckBox( aControl);						break;				}			}			break;	}	return result;}static void ChangeSuperAction( Action_EditorWindowType *d, CWindowPtr window,	long newSuperActionIndex){	ListHandle		list;	ControlHandle	aControl;	long			oldActionNum, newActionNum;	Boolean			same = true;		if (( d->whichAction >= 0) && ( d->superActionID >= 0) &&		( d->actionData != nil))	{		Window_SetAction_FromControls( d,			window,  d->whichAction + d->startActionIndex);				if (( d->discreteData != nil) && ( d->actionData != nil))		{			HD_DiscreteData_Replace_Compare( d->discreteData, d->actionData,				kHera_Action_Type, &same);			if ( !same) d->heraFile->changed = true;			DisposeHandle( d->actionData);			d->actionData = nil;		}	}		list = HUI_List_Get( d->listMaster, 0, kSuperList_Cell_X,		kSuperList_Cell_Y, kSuperList_ID);	mAssert( list != nil);	if ( list != nil)	{		if ( (**list).dataBounds.bottom <= 0) return;				d->superActionIndex = newSuperActionIndex;		d->superActionID = PsuedoColumn_List_GetIndex( list,								d->superActionIndex);		if ( d->discreteData != nil)		{			oldActionNum = HD_DiscreteData_GetElementNumber( d->discreteData,				kHera_Action_Type);		} else oldActionNum = 0;				d->discreteData = HD_Find_Discrete_Data( d->heraFile,			d->superActionID, -1, nil,			kHera_Action_Type);					if ( d->discreteData != nil)		{			newActionNum = HD_DiscreteData_GetElementNumber( d->discreteData,				kHera_Action_Type);		} else newActionNum = 0;				if (( newActionNum <= 0) && ( oldActionNum > 0))			Enable_Editing( d, false);		else if (( newActionNum > 0) && ( oldActionNum <= 0))			Enable_Editing( d, true);		GetAllData( d);		aControl = HUI_Control_Get( 			d->listMaster, 0, kList_Cell_X - d->columnFix, kList_Cell_Y,			kList_ID);		if ( aControl != nil) Draw1Control( aControl);				Window_SetControls_FromActionIndex(			d, window, d->whichAction + d->startActionIndex);		d->superActionIndex = HUI_Control_GetListValue( d->listMaster, 0,			kSuperList_Cell_X,			kSuperList_Cell_Y, kSuperList_ID, d->superActionIndex);	}}static void OK_Button( Action_EditorWindowType *d){//	Button_Window_NewWindow("\pSave Changes to Actions", true, false, 8021,//		8022, OKConfirmCallBack, d->windowID);	OKConfirmCallBack( kOK_Button_ID, d->windowID);}static void Cancel_Button( Action_EditorWindowType *d){//	Button_Window_NewWindow("\pDiscard Changes to Actions", true, false, 8023,//		8024, CancelConfirmCallBack, d->windowID);	CancelConfirmCallBack( kOK_Button_ID, d->windowID);}static void Revert_Button( Action_EditorWindowType *d){	CWindowPtr whichWindow = GetWindowPtrFromDispatchWindowID( d->windowID);		if ( whichWindow == nil) return;	if ( !Button_Window_Modal( "\pRevert this action?",							"\pClick Revert to restore this action to its "							"previous values. Click Cancel to "							"keep it as it is.", "\pRevert", nil))		return;	Window_SetControls_FromActionIndex(			d, whichWindow, d->whichAction + d->startActionIndex);}static void OKConfirmCallBack( long whichButton, long windowID){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Action_EditorWindowType			*d;	short							resRefNum = CurResFile();	Boolean							same = true;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Action_EditorWindowType *)*data;	if ( whichButton == 1)	{		gHera->modalMode--;		Window_SetAction_FromControls( d,			GetWindowPtrFromDispatchWindowID(windowID),			d->whichAction + d->startActionIndex);				if ( d->discreteData == nil)		{				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_scenarioFile_refNum);//			HU_UseResFile( d->resRefNum, &resRefNum);	//		Resource_Replace( 'obac', 500, d->actionData, "\pHera Actions");	//		UpdateResFile( d->resRefNum);			UseResFile( resRefNum);		} else		{			if ( !d->chooseOnly)				HD_DiscreteData_Replace_Compare( d->discreteData, d->actionData,					kHera_Action_Type, &same);						if ( !same) d->heraFile->changed = true;		}		if ( d->actionData != nil)			DisposeHandle( d->actionData);		d->actionData = nil;		if ( d->callBack != nil)			d->callBack( d->callerID,				((heraDataHeaderType *)*(d->discreteData))->id,				d->actionNumber);		HUI_MasterControl_Delete( d->master);		CloseDispatchWindow( d->windowID); // d and data no longer valid	} else	{		HSetState( data, dataState);	}}static void CancelConfirmCallBack( long whichButton, long windowID){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Action_EditorWindowType		*d;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Action_EditorWindowType *)*data;	if ( whichButton == 1)	{		gHera->modalMode--;		DisposeHandle( d->actionData);		d->actionData = nil;		HUI_MasterControl_Delete( d->master);		CloseDispatchWindow( d->windowID); // d and data no longer valid	} else	{		HSetState( data, dataState);	}}static void ChangeActionNumber( Action_EditorWindowType *d, long newActionNumber){		long oldPanel = d->whatAction, actualPanel;		d->whatAction = newActionNumber;		d->action.verb = (objectVerbIDType)newActionNumber;		if ( d->whatAction != oldPanel)		{			if ( oldPanel >= 0)			{				if ( oldPanel == kCreateObjectSetDest)					actualPanel = kCreateObject;				else					actualPanel = oldPanel;				HUI_Master_HideLayer( d->argument, actualPanel);			}						if ( d->whatAction == kCreateObjectSetDest)				actualPanel = kCreateObject;			else				actualPanel = d->whatAction;			HUI_Master_ShowLayer( d->argument, actualPanel);			if ( d->whatAction == kAlter)			{				short i, originalAlter = d->whatAlter;				for ( i = 0; i < d->alter->layerNum; i++)				{//					if ( i != d->whatAlter)//						HUI_Master_HideLayer( d->alter, i);//					else						ChangeAlterNumber( d, i);				}				ChangeAlterNumber( d, originalAlter);			}		}		HU_AutoDefocus( GetWindowPtrFromDispatchWindowID( d->windowID));}static void ChangeAlterNumber( Action_EditorWindowType *d, long newAlterNumber){		long oldPanel = d->whatAlter;		if ( newAlterNumber < 0) newAlterNumber = 0;		d->whatAlter = newAlterNumber;		d->action.argument.alterObject.alterType = (alterVerbIDType)newAlterNumber;		if ( d->whatAlter != oldPanel)		{			if ( oldPanel >= 0)				HUI_Master_HideLayer( d->alter, oldPanel);			HUI_Master_ShowLayer( d->alter, d->whatAlter);		}		HU_AutoDefocus( GetWindowPtrFromDispatchWindowID( d->windowID));}static OSErr Setup_Argument_Panel( Action_EditorWindowType *d, CWindowPtr window){	huiPlainControlParamType	buttonParam, textParam, groupParam;	huiCellParamType			cellParam;	huiMasterControlParamType	masterParam;	short						i;		// set up all cells	cellParam.master = d->argument;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_center;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	// set up main cell	for ( i = 0; i < kArgument_Panel_Num; i++)	{		if ( i != kAL_Panel_Index)		{			cellParam.colSpan = 1;			cellParam.rowSpan = 2;			HUI_Cell_Set( i, kArgument_Main_Cell_X, kArgument_Main_Cell_Y, &cellParam);		} else		{			cellParam.colSpan = 1;			cellParam.rowSpan = 2;			SetRect( &cellParam.outSpace, -1, -1, -1, 20);			HUI_Cell_Set( i, kArgument_Main_Cell_X, kArgument_Main_Cell_Y, &cellParam);			SetRect( &cellParam.outSpace, -1, -1, -1, -1);		}	}		// set up buttons, general	buttonParam.master = d->argument;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;	buttonParam.fontStyle.font = kSmallFontNum;	buttonParam.fontStyle.size = kSmallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = teCenter;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;	buttonParam.flags = huiControlFlag_none;	buttonParam.cellx = kArgument_Main_Cell_X;	buttonParam.celly = kArgument_Main_Cell_Y;	if ( d->chooseOnly)		buttonParam.enabled = false;			// set up text, general		textParam.master = d->argument;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = 8;	textParam.space.top = 12;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = -1;	textParam.cellx = kArgument_Main_Cell_X;	textParam.celly = kArgument_Main_Cell_Y;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;	if ( d->chooseOnly)		textParam.enabled = false;			// ----------------------------------	// create object panel	// ----------------------------------	textParam.layer = kCO_Panel_Index;	buttonParam.layer = kCO_Panel_Index;	AddEditField( &textParam, kCO_whichBaseType, kStrResID, 11, false,		kEditTextBigFieldWidth);		// select object button	buttonParam.id = kCO_Select_Object_Button_ID;	GetIndString( buttonParam.label, kStrResID, 17); // selectÉ	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.flags = huiControlFlag_none;	HUI_PushButton_New_LiteralP( &buttonParam);		AddEditField( &textParam, kCO_howManyMinimum, kStrResID, 12, true,		kEditTextFieldWidth);		AddEditField( &textParam, kCO_howManyRange, kStrResID, 13, true,		kEditTextFieldWidth);		// velocity relative checkbox	buttonParam.id = kCO_velocityRelative;	GetIndString( buttonParam.label, kStrResID, 14); // velocity relative	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 1;	buttonParam.flags = huiControlFlag_newLine;	HUI_CheckBox_New_LiteralP( &buttonParam);	// direction relative checkbox	buttonParam.id = kCO_velocityRelative;	GetIndString( buttonParam.label, kStrResID, 15); // direction relative	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 1;	buttonParam.flags = huiControlFlag_newLine;	HUI_CheckBox_New_LiteralP( &buttonParam);	AddEditField( &textParam, kCO_randomDistance, kStrResID, 16, true,		kEditTextFieldWidth);		// ----------------------------------	// play sound panel	// ----------------------------------	textParam.layer = kPS_Panel_Index;	buttonParam.layer = kPS_Panel_Index;	//	AddEditField( &textParam, kPS_priority, kStrResID, 18, false,//		kEditTextFieldWidth);		AddPopUp( &textParam, &buttonParam, kPS_priority, kStrResID, 18, false, 555);	AddEditField( &textParam, kPS_persistence, kStrResID, 19, true,		kEditTextFieldWidth);	//  check box	buttonParam.id = kPS_absolute;	buttonParam.flags = huiControlFlag_newLine;	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 1;	GetIndString( buttonParam.label, kStrResID, 20); // absolute	HUI_CheckBox_New_LiteralP( &buttonParam);			AddEditField( &textParam, kPS_volumeMinimum, kStrResID, 21, true,		kEditTextFieldWidth);	AddEditField( &textParam, kPS_volumeRange, kStrResID, 22, true,		kEditTextFieldWidth);//	AddEditField( &textParam, kPS_idMinimum, kStrResID, 23, true,//		kEditTextBigFieldWidth);	//  label	textParam.id = kPS_idMinimum -1 ;	GetIndString( textParam.label, kStrResID, 23); // which base type	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_newLine;	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		//  edit	textParam.id = kPS_idMinimum;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.label[0] = 0;	HUI_StaticText_New_LiteralP( &textParam);		buttonParam.id = kPS_chooseSound;	buttonParam.flags = huiControlFlag_none;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	GetIndString( buttonParam.label, kStrResID, 54);	HUI_PushButton_New_LiteralP( &buttonParam);		AddEditField( &textParam, kPS_idRange, kStrResID, 24, true,		kEditTextFieldWidth);	// ----------------------------------	// make sparks panel	// ----------------------------------	textParam.layer = kMS_Panel_Index;	buttonParam.layer = kMS_Panel_Index;		AddEditField( &textParam, kMS_howMany, kStrResID, 25, false, kEditTextFieldWidth);	AddEditField( &textParam, kMS_speed, kStrResID, 26, true, kEditTextFieldWidth);	AddEditField( &textParam, kMS_velocityRange, kStrResID, 27, true, kEditTextFieldWidth);		AddPopUp( &textParam, &buttonParam, kMS_color, kStrResID, 28, true, 590);		// ----------------------------------	// release energy panel	// ----------------------------------	textParam.layer = kRE_Panel_Index;	buttonParam.layer = kRE_Panel_Index;		AddEditField( &textParam, kRE_percent, kStrResID, 29, false, kEditTextFieldWidth);	// ----------------------------------	// land at panel	// ----------------------------------	textParam.layer = kLA_Panel_Index;	buttonParam.layer = kLA_Panel_Index;		AddEditField( &textParam, kLA_landingSpeed, kStrResID, 30, false, kEditTextFieldWidth);	// ----------------------------------	// assume initial	// ----------------------------------	textParam.layer = kAI_Panel_Index;	buttonParam.layer = kAI_Panel_Index;		AddEditField( &textParam, kAI_whichInitialObject, kStrResID, 50, false, kEditTextFieldWidth);	// ----------------------------------	// enter warp panel	// ----------------------------------	textParam.layer = kEW_Panel_Index;	buttonParam.layer = kEW_Panel_Index;		AddEditField( &textParam, kEW_warpSpeed, kStrResID, 31, false, kEditTextFieldWidth);	// ----------------------------------	// display message panel	// ----------------------------------	textParam.layer = kDM_Panel_Index;	buttonParam.layer = kDM_Panel_Index;		AddEditField( &textParam, kDM_resID, kStrResID, 32, false, kEditTextFieldWidth);	AddEditField( &textParam, kDM_pageNum, kStrResID, 33, true, kEditTextFieldWidth);	// ----------------------------------	// change score panel	// ----------------------------------	textParam.layer = kCS_Panel_Index;	buttonParam.layer = kCS_Panel_Index;		AddEditField( &textParam, kCS_whichPlayer, kStrResID, 34, false, kEditTextFieldWidth);	AddEditField( &textParam, kCS_whichScore, kStrResID, 35, true, kEditTextFieldWidth);	AddEditField( &textParam, kCS_amount, kStrResID, 36, true, kEditTextFieldWidth);	// ----------------------------------	// declare winner panel	// ----------------------------------	textParam.layer = kDW_Panel_Index;	buttonParam.layer = kDW_Panel_Index;		AddEditField( &textParam, kDW_whichPlayer, kStrResID, 37, false, kEditTextFieldWidth);	AddEditField( &textParam, kDW_nextLevel, kStrResID, 38, true, kEditTextFieldWidth);	AddEditField( &textParam, kDW_textID, kStrResID, 39, true, kEditTextFieldWidth);	// select text button	buttonParam.id = kDW_Select_Text_Button_ID;	GetIndString( buttonParam.label, kStrResID, 17); // selectÉ	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.flags = huiControlFlag_none;	HUI_PushButton_New_LiteralP( &buttonParam);		// ----------------------------------	// release energy panel	// ----------------------------------	textParam.layer = kKO_Panel_Index;	buttonParam.layer = kKO_Panel_Index;		AddPopUp( &textParam, &buttonParam, kKO_dieType, kStrResID, 40, true, 557);	// ----------------------------------	// color flasg	// ----------------------------------	textParam.layer = kCF_Panel_Index;	buttonParam.layer = kCF_Panel_Index;		AddEditField( &textParam, kCF_length, kStrResID, 41, false, kEditTextFieldWidth);	AddPopUp( &textParam, &buttonParam, kCF_color, kStrResID, 42, true, 590);	AddEditField( &textParam, kCF_shade, kStrResID, 43, true, kEditTextFieldWidth);	// ----------------------------------	// minicomputer select	// ----------------------------------	textParam.layer = kMC_Panel_Index;	buttonParam.layer = kMC_Panel_Index;		AddEditField( &textParam, kMC_screenNumber, kStrResID, 48, false, kEditTextFieldWidth);	AddEditField( &textParam, kMC_lineNumber, kStrResID, 49, true, kEditTextFieldWidth);	// 	// ----------------------------------	// disable keys	// ----------------------------------	textParam.layer = kDK_Panel_Index;	buttonParam.layer = kDK_Panel_Index;			AddBitPopUp( &textParam, &buttonParam, kDK_keyMask, kStrResID, 45,		true, 8026);	// ----------------------------------	// enable keys	// ----------------------------------	textParam.layer = kEK_Panel_Index;	buttonParam.layer = kEK_Panel_Index;			AddBitPopUp( &textParam, &buttonParam, kEK_keyMask, kStrResID, 46,		true, 8026);	// ----------------------------------	// disable keys	// ----------------------------------	textParam.layer = kSZ_Panel_Index;	buttonParam.layer = kSZ_Panel_Index;			AddPopUp( &textParam, &buttonParam, kSZ_zoomLevel, kStrResID, 47, true, 8027);	// ----------------------------------	// alter panel	// ----------------------------------	groupParam.master = d->argument;	groupParam.visible = true;	groupParam.enabled = true;	groupParam.whichTabSet = -1;	groupParam.whichTab = -1;	groupParam.layer = kAL_Panel_Index;	groupParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;	groupParam.fontStyle.font = gHera->smallFontNum;	groupParam.fontStyle.size = gHera->smallFontSize;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;	groupParam.helpStringResID = -1;	groupParam.id = kAL_Popup_Group_ID;	groupParam.cellx = kArgument_Main_Cell_X;	groupParam.celly = kArgument_Main_Cell_Y;	groupParam.special.menuStrList.strList = GetStringList( 558);	groupParam.fontStyle.style = gHera->smallFontStyle;	if ( groupParam.special.menuStrList.strList != nil)	{		groupParam.special.menuStrList.menuID = HU_GetNewMenuID();		groupParam.special.menuStrList.multiSelect = false;		SetRect( &groupParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);		GetIndString( groupParam.label, kStrResID, 1); // ignored		HUI_Group_Secondary_PopupButton_New_StrList( &groupParam);//		HUI_Group_New_LiteralP( &groupParam);		ReleaseResource( groupParam.special.menuStrList.strList);	}		masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = window;	masterParam.rowNum = kAL_Master_RowNum;	masterParam.colNum = kAL_Master_ColNum;	masterParam.layerNum = kAL_Panel_Num;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->alter = HUI_MasterControl_New( d->argument, kAL_Panel_Index, 0, 0, &masterParam);		mAssert( d->alter != nil);	if ( d->alter == nil) return memFullErr;	HUI_Master_HideLayer( d->alter, 0);	d->alter->tab[0][0].h = kLarge_Tab_Width;	d->alter->tab[0][0].hAlign = hui_halign_right;	d->alter->tab[0][1].h = kLarge_Tab_Width;	d->alter->tab[0][1].hAlign = hui_halign_left;		buttonParam.master = d->alter;	textParam.master = d->alter;		for ( i = 0; i < d->alter->layerNum; i++)	{		Str255	s;		Boolean	newLine = false;				textParam.layer = i;		buttonParam.layer = i;			// relative		GetIndString( s, kAlter_Field_Str_Res_ID, (i * 4) + 2);		if ( s[0] != 0)		{			//  relative checkbox			buttonParam.id = kAlter_Field_ID_Offset + (i * kAlter_Field_ID_Multiplier);			pstrcpy( buttonParam.label, s);			buttonParam.whichTabSet = 0;			buttonParam.whichTab = 1;			buttonParam.flags = huiControlFlag_none;			newLine = true;			HUI_CheckBox_New_LiteralP( &buttonParam);		}				// minimum		GetIndString( s, kAlter_Field_Str_Res_ID, (i * 4) + 3);		if ( s[0] != 0)		{			AddEditField( &textParam,				kAlter_Field_ID_Offset + (i * kAlter_Field_ID_Multiplier) + 2,				kAlter_Field_Str_Res_ID,				(i * 4) + 3, newLine,//				kEditTextFieldWidth				kEditTextBigFieldWidth				);							newLine = true;		}				if ( i == kAlterBaseType)		{			buttonParam.id = kAlter_BaseType_Select_Button_ID;			buttonParam.whichTabSet = -1;			buttonParam.whichTab = -1;			buttonParam.flags = huiControlFlag_none;			GetIndString( buttonParam.label, kStrResID, 17);			HUI_PushButton_New_LiteralP( &buttonParam);		}				// maximum		GetIndString( s, kAlter_Field_Str_Res_ID, (i * 4) +4);		if ( s[0] != 0)		{			AddEditField( &textParam, kAlter_Field_ID_Offset + (i * kAlter_Field_ID_Multiplier) + 6,				kAlter_Field_Str_Res_ID, (i * 4) + 4, newLine, kEditTextFieldWidth);			newLine = true;		}				// note		GetIndString( s, kAlter_Field_Str_Res_ID, (i * 4) + 1);		if ( s[0] != 0)		{			// inclusive label			textParam.minMaxBounds.left = 200;			textParam.minMaxBounds.right = 200;			textParam.id = kAlter_Field_ID_Offset + (i * kAlter_Field_ID_Multiplier) + 8;			pstrcpy( textParam.label, s);			textParam.whichTabSet = -1;			textParam.whichTab = -1;			if ( newLine)				textParam.flags = huiControlFlag_newLine;			else				textParam.flags = huiControlFlag_none;			HUI_StaticText_New_LiteralP( &textParam);				textParam.minMaxBounds.left = 0;			textParam.minMaxBounds.right = kHUI_Pixel_Max;		}	}	return noErr;}static void AddEditField( huiPlainControlParamType *param, long id, short resID, short index,	Boolean newLine, long fieldWidth){	//  label	param->id = id-1;	GetIndString( param->label, resID, index); // which base type	param->whichTabSet = 0;	param->whichTab = 0;	param->flags = (newLine)?(huiControlFlag_newLine):(huiControlFlag_none);	param->minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( param);		//  edit	param->id = id;	param->minMaxBounds.left = fieldWidth;	param->flags = huiControlFlag_none;	param->whichTabSet = 0;	param->whichTab = 1;	param->label[0] = 0;	HUI_EditText_New_LiteralP( param);		}static void AddPopUp( huiPlainControlParamType *textParam,	huiPlainControlParamType *buttonParam, long id, short resID, short index,	Boolean newLine, short menuStrResID){	Handle	strList;		//  label	textParam->id = id-1;	GetIndString( textParam->label, resID, index); // which base type	textParam->whichTabSet = 0;	textParam->whichTab = 0;	textParam->flags = (newLine)?(huiControlFlag_newLine):(huiControlFlag_none);	textParam->minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( textParam);			strList = GetStringList( menuStrResID);	if ( strList != nil)	{		buttonParam->flags = huiControlFlag_none;		buttonParam->whichTabSet = 0;		buttonParam->whichTab = 1;		buttonParam->id = id;		buttonParam->special.menuStrList.strList = strList;		buttonParam->special.menuStrList.menuID = HU_GetNewMenuID();//		buttonParam->minMaxBounds.right = kEditTextFieldWidth * 2;		buttonParam->minMaxBounds.left = 0;		HUI_PopupButton_New_StrList( buttonParam);		ReleaseResource( strList);		buttonParam->minMaxBounds.right = kHUI_Pixel_Max;	}}static void AddBitPopUp( huiPlainControlParamType *textParam,	huiPlainControlParamType *buttonParam, long id, short resID, short index,	Boolean newLine, short menuStrResID){	//  label	textParam->id = id-1;	GetIndString( textParam->label, resID, index); // which base type	textParam->whichTabSet = 0;	textParam->whichTab = 0;	textParam->flags = (newLine)?(huiControlFlag_newLine):(huiControlFlag_none);	textParam->minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( textParam);		buttonParam->id = id;	buttonParam->special.menuStrList.strList = GetStringList( menuStrResID);	buttonParam->special.menuStrList.menuID = HU_GetNewMenuID();	buttonParam->special.menuStrList.cicnResID = 128;	buttonParam->special.menuStrList.multiSelect = true;	buttonParam->whichTabSet = 0;	buttonParam->whichTab = 1;	buttonParam->flags = huiControlFlag_none;	buttonParam->space.left = 8;		HUI_BevelButtonMenu_New_StrList( buttonParam);	buttonParam->whichTabSet = -1;	buttonParam->whichTab = -1;	if ( buttonParam->special.menuStrList.strList != nil)		ReleaseResource( buttonParam->special.menuStrList.strList);			// set attributes button	buttonParam->id = id + 2;	GetIndString( buttonParam->label, kHera_AppStrResID, 8); // setÉ	buttonParam->space.left = 8;	buttonParam->minMaxBounds.right = kHUI_Pixel_Max;	buttonParam->minMaxBounds.left = 0;	HUI_PushButton_New_LiteralP( buttonParam);}static void GetAllData( Action_EditorWindowType *d){	short						oldResRefNum = 0;	ControlHandle				aControl;	ListHandle					list;//	OSErr						err;	long						actionNum = 0;		if ( d == nil) return;	oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_spriteFile_refNum);	if ( d->discreteData == nil) return;		/*	if ( d->discreteData == nil)	{		d->actionData = GetResource( 'obac', 500);		if ( d->actionData == nil) d->actionData = NewHandle(0);		else		{			DetachResource( d->actionData);		}	} else*/	{		long	offset, size;				HD_DiscreteData_GetOffsetAndSize( d->discreteData, &offset, &size);		BPMOWritePString("\p\raction data num: ");		d->actionData = NewHandle( size);		mAssert( d->actionData != nil);		if ( d->actionData == nil) goto GetAllData_error;		BlockMove( *d->discreteData + offset, *d->actionData, size);		BPMOWriteLong( size / sizeof( objectActionType));		BPMOWritePString("\p\r");		d->startActionIndex = 0;	}	if ( d->actionData == nil)	{		goto GetAllData_error;	}		aControl = HUI_Control_Get( 		d->listMaster, 0, kList_Cell_X - d->columnFix, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Cell		cell;				d->actionNumber = actionNum = GetHandleSize( d->actionData) / sizeof( objectActionType);		if ( d->actionNumber > 0)		{			if ( d->startActionIndex >= actionNum) d->startActionIndex = actionNum - 1;			if (( d->startActionIndex + d->actionNumber) > actionNum)				d->actionNumber = (actionNum - d->startActionIndex);		} else d->startActionIndex = 0;		GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			short	i = d->startActionIndex, count = d->actionNumber;			Str255	s;						LDelRow( 0, 0, list);	// delete all rows			(*list)->selFlags = lOnlyOne;						if ( d->actionNumber > 0)			{				cell.h = 0;				do				{	//				GetIndString( s, 4201, i);					MakeActionName( d->heraFile, nil, d->actionData, i, s);					if ( s[0] == 0) pstrcpy( s, "\puntitled");	//				if ( s[0] != 0)					{						LAddRow( 1, (**list).dataBounds.bottom, list );						cell.v = (**list).dataBounds.bottom - 1;						LSetCell( (Ptr)(&s[1]), s[0], cell, list );					}					i ++;					count--;				} while ( count > 0);			}		}	}	actionNum = GetHandleSize( d->actionData) / sizeof( objectActionType);	if ( actionNum == 0)		d->whichAction = 0;	else if ( d->whichAction >= actionNum)		d->whichAction = actionNum - 1;	d->whichAction = HUI_Control_GetListValue( d->listMaster, 0, kList_Cell_X - d->columnFix, kList_Cell_Y,										kList_ID, d->whichAction);	Window_SetControls_FromActionIndex( d,		GetWindowPtrFromDispatchWindowID( d->windowID), d->whichAction + d->startActionIndex);	GetAllData_error:		UseResFile( oldResRefNum);}static void SetUpSuperList( Action_EditorWindowType *d){	ControlHandle				aControl;	ListHandle					list;	long						actionNum = 0;	Handle						discreteData = nil;		if ( d == nil) return;		aControl = HUI_Control_Get( 		d->listMaster, 0, kSuperList_Cell_X, kSuperList_Cell_Y,		kSuperList_ID);	if ( aControl != nil)	{		Cell		cell;				GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			Str255	s, ids;			Ptr		data;			long	dataLength;						LDelRow( 0, 0, list);	// delete all rows			(*list)->selFlags = lOnlyOne;						cell.h = 0;			discreteData = HD_DiscreteData_GetNextOfType( d->heraFile, nil, kHera_Action_Type);			while ( discreteData != nil)			{				GetActionNameFromDiscreteAction( d->heraFile, discreteData, s,					false);				NumToString( ((heraDataHeaderType *)*discreteData)->id,					ids);				if ( s[0] == 0) pstrcpy( s, "\puntitled");				data = PsuedoColumn_Data_Make( &dataLength,					((heraDataHeaderType *)*discreteData)->id, ids,						"\p\t", s, "\p");				if ( data != nil)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( data, dataLength, cell, list );					DisposePtr( data);				}				discreteData = HD_DiscreteData_GetNextOfType( d->heraFile, discreteData, kHera_Action_Type);			}		}	}	if ( d->superActionIndex < actionNum) d->whichAction = actionNum - 1;	d->whichAction = HUI_Control_GetListValue( d->listMaster, 0, kList_Cell_X - d->columnFix, kList_Cell_Y,										kList_ID, d->whichAction);	SortSuperList( d, true);}static void Window_SetControls_FromActionIndex( Action_EditorWindowType *d, CWindowPtr window,	long index){	SignedByte					actionDataState;	GrafPtr						oldPort;	objectActionType			*anAction;	huiPlainControlParamType	dummyParam;		mAssert( d != nil);	mAssert( d->actionData != nil);		if ( d->actionNumber <= 0) return;		actionDataState = HGetState( d->actionData);	HLock( d->actionData);	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);		anAction = (objectActionType *)*d->actionData + index;		BlockMoveData( anAction, &d->action, sizeof( objectActionType));	// set qualifiers	dummyParam.layer = 0;	dummyParam.cellx = kQualifier_Cell_X;	dummyParam.celly = kQualifier_Cell_Y;	dummyParam.master = d->qualifier;	if (( anAction->verb == kEnableKeys) || ( anAction->verb == kDisableKeys))		d->action.argument.keys.keyMask = anAction->argument.keys.keyMask;	SetActionField( d, &dummyParam, anAction, kQualifier_Inclusive_ID, true);	d->action.inclusiveFilter = anAction->inclusiveFilter;	SetActionField( d, &dummyParam, anAction, kQualifier_Exclusive_ID, true);	d->action.exclusiveFilter = anAction->exclusiveFilter;	SetActionField( d, &dummyParam, anAction, kQualifier_Delay_ID, true);	SetActionField( d, &dummyParam, anAction, kQualifier_Subject_ID, true);	SetActionField( d, &dummyParam, anAction, kQualifier_Direct_ID, true);	SetActionField( d, &dummyParam, anAction, kQualifier_Reflexive_ID, true);	SetActionField( d, &dummyParam, anAction, kQualifier_LevelKey_ID, true);		// owner	dummyParam.cellx = kOwner_Cell_X;	dummyParam.celly = kOwner_Cell_Y;		SetActionField( d, &dummyParam, anAction, kOwner_Group_ID, true);		// argument popup	dummyParam.master = d->mainMaster;	dummyParam.cellx = kArgument_Main_Cell_X;	dummyParam.celly = kArgument_Main_Cell_Y;	dummyParam.layer = 0;	SetActionField( d, &dummyParam, anAction, kArgument_Popup_ID, true);	dummyParam.master = d->argument;	dummyParam.cellx = 0;	dummyParam.celly = 0;// CO = create object	dummyParam.layer = kCO_Panel_Index;//kCO_ID_Offset	SetActionField( d, &dummyParam, anAction, kCO_whichBaseType, true);	SetActionField( d, &dummyParam, anAction, kCO_howManyMinimum, true);	SetActionField( d, &dummyParam, anAction, kCO_howManyRange, true);	SetActionField( d, &dummyParam, anAction, kCO_velocityRelative, true);	SetActionField( d, &dummyParam, anAction, kCO_directionRelative, true);	SetActionField( d, &dummyParam, anAction, kCO_randomDistance, true);// PS = play sound	dummyParam.layer = kPS_Panel_Index;//kPS_ID_Offset	SetActionField( d, &dummyParam, anAction, kPS_priority, true);	SetActionField( d, &dummyParam, anAction, kPS_persistence, true);	SetActionField( d, &dummyParam, anAction, kPS_absolute, true);	SetActionField( d, &dummyParam, anAction, kPS_volumeMinimum, true);	SetActionField( d, &dummyParam, anAction, kPS_volumeRange, true);	SetActionField( d, &dummyParam, anAction, kPS_idMinimum, true);	SetActionField( d, &dummyParam, anAction, kPS_idRange, true);// AL = alkter	dummyParam.layer =kAL_Panel_Index;//kAL_Panel_Num	SetActionField( d, &dummyParam, anAction, kAL_Popup_Group_ID, true);//kAlter_Field_Str_Res_ID//kAlter_Field_ID_Offset//kAlter_Field_ID_Multiplier// MS = make sparks	dummyParam.layer =kMS_Panel_Index;//kMS_ID_Offset	SetActionField( d, &dummyParam, anAction, kMS_howMany, true);	SetActionField( d, &dummyParam, anAction, kMS_speed, true);	SetActionField( d, &dummyParam, anAction, kMS_velocityRange, true);	SetActionField( d, &dummyParam, anAction, kMS_color, true);// RE = release energy	dummyParam.layer =kRE_Panel_Index;//kRE_ID_Offset	SetActionField( d, &dummyParam, anAction, kRE_percent, true);// LA = land at	dummyParam.layer =kLA_Panel_Index;//kLA_ID_Offset	SetActionField( d, &dummyParam, anAction, kLA_landingSpeed, true);// AI = land at	dummyParam.layer =kAI_Panel_Index;//kLA_ID_Offset	SetActionField( d, &dummyParam, anAction, kAI_whichInitialObject, true);// EW = enter warp	dummyParam.layer = kEW_Panel_Index;//kEW_ID_Offset	SetActionField( d, &dummyParam, anAction, kEW_warpSpeed, true);// DM = display message	dummyParam.layer =kDM_Panel_Index;//kDM_ID_Offset	SetActionField( d, &dummyParam, anAction, kDM_resID, true);	SetActionField( d, &dummyParam, anAction, kDM_pageNum, true);// CS = change score	dummyParam.layer =kCS_Panel_Index;//kCS_ID_Offset	SetActionField( d, &dummyParam, anAction, kCS_whichPlayer, true);	SetActionField( d, &dummyParam, anAction, kCS_whichScore, true);	SetActionField( d, &dummyParam, anAction, kCS_amount, true);// DW = declare winner	dummyParam.layer =kDW_Panel_Index;//kDW_ID_Offset	SetActionField( d, &dummyParam, anAction, kDW_whichPlayer, true);	SetActionField( d, &dummyParam, anAction, kDW_nextLevel, true);	SetActionField( d, &dummyParam, anAction, kDW_textID, true);// KO = kill object	dummyParam.layer =kKO_Panel_Index;//kKO_ID_Offset	SetActionField( d, &dummyParam, anAction, kKO_dieType, true);// CF = color flash	dummyParam.layer =kCF_Panel_Index;//kCF_ID_Offset	SetActionField( d, &dummyParam, anAction, kCF_length, true);	SetActionField( d, &dummyParam, anAction, kCF_color, true);	SetActionField( d, &dummyParam, anAction, kCF_shade, true);// MC = mini computer	dummyParam.layer =kMC_Panel_Index;	SetActionField( d, &dummyParam, anAction, kMC_screenNumber, true);	SetActionField( d, &dummyParam, anAction, kMC_lineNumber, true);	dummyParam.layer = kDK_Panel_Index;	SetActionField( d, &dummyParam, anAction, kDK_keyMask, true);	dummyParam.layer = kEK_Panel_Index;	SetActionField( d, &dummyParam, anAction, kEK_keyMask, true);		dummyParam.layer = kSZ_Panel_Index;	SetActionField( d, &dummyParam, anAction, kSZ_zoomLevel, true);		if ( anAction->verb == kAlter)	{		dummyParam.master = d->alter;		dummyParam.layer = anAction->argument.alterObject.alterType;				SetActionField( d, &dummyParam, anAction, kAlter_Field_ID_Offset + 			(dummyParam.layer * kAlter_Field_ID_Multiplier), true);		SetActionField( d, &dummyParam, anAction, kAlter_Field_ID_Offset + 			(dummyParam.layer * kAlter_Field_ID_Multiplier) + 2, true);		SetActionField( d, &dummyParam, anAction, kAlter_Field_ID_Offset + 			(dummyParam.layer * kAlter_Field_ID_Multiplier) + 6, true);	}		SetPort( oldPort);	HSetState( d->actionData, actionDataState);}	static void Window_SetAction_FromControls( Action_EditorWindowType *d, CWindowPtr window,	long index){	SignedByte					actionDataState;	GrafPtr						oldPort;	objectActionType			*anAction;	huiPlainControlParamType	dummyParam;	Str255						s;	ControlHandle				aControl;		mAssert( d != nil);		if ( d->actionData == nil) return;		mAssert( d->actionData != nil);		if ( d->actionNumber <= 0) return;	if ( d->chooseOnly) return;		actionDataState = HGetState( d->actionData);	HLock( d->actionData);	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);		anAction = (objectActionType *)*d->actionData + index;		BlockMoveData( &d->action, anAction, sizeof( objectActionType));	// set qualifiers	dummyParam.layer = 0;	dummyParam.cellx = kQualifier_Cell_X;	dummyParam.celly = kQualifier_Cell_Y;	dummyParam.master = d->qualifier;		anAction->inclusiveFilter = d->action.inclusiveFilter;	GetActionField( d, &dummyParam, anAction, kQualifier_Inclusive_ID);	anAction->exclusiveFilter = d->action.exclusiveFilter;	GetActionField( d, &dummyParam, anAction, kQualifier_Exclusive_ID);	GetActionField( d, &dummyParam, anAction, kQualifier_Delay_ID);	GetActionField( d, &dummyParam, anAction, kQualifier_Subject_ID);	GetActionField( d, &dummyParam, anAction, kQualifier_Direct_ID);	GetActionField( d, &dummyParam, anAction, kQualifier_Reflexive_ID);	GetActionField( d, &dummyParam, anAction, kQualifier_LevelKey_ID);		// owner	dummyParam.cellx = kOwner_Cell_X;	dummyParam.celly = kOwner_Cell_Y;		GetActionField( d, &dummyParam, anAction, kOwner_Group_ID);		// argument popup	dummyParam.master = d->mainMaster;	dummyParam.cellx = kArgument_Main_Cell_X;	dummyParam.celly = kArgument_Main_Cell_Y;	dummyParam.layer = 0;	GetActionField( d, &dummyParam, anAction, kArgument_Popup_ID);	dummyParam.master = d->argument;	dummyParam.cellx = 0;	dummyParam.celly = 0;// CO = create object	dummyParam.layer = kCO_Panel_Index;//kCO_ID_Offset	GetActionField( d, &dummyParam, anAction, kCO_whichBaseType);	GetActionField( d, &dummyParam, anAction, kCO_howManyMinimum);	GetActionField( d, &dummyParam, anAction, kCO_howManyRange);	GetActionField( d, &dummyParam, anAction, kCO_velocityRelative);	GetActionField( d, &dummyParam, anAction, kCO_directionRelative);	GetActionField( d, &dummyParam, anAction, kCO_randomDistance);// PS = play sound	dummyParam.layer = kPS_Panel_Index;//kPS_ID_Offset	GetActionField( d, &dummyParam, anAction, kPS_priority);	GetActionField( d, &dummyParam, anAction, kPS_persistence);	GetActionField( d, &dummyParam, anAction, kPS_absolute);	GetActionField( d, &dummyParam, anAction, kPS_volumeMinimum);	GetActionField( d, &dummyParam, anAction, kPS_volumeRange);	GetActionField( d, &dummyParam, anAction, kPS_idMinimum);	GetActionField( d, &dummyParam, anAction, kPS_idRange);// AL = alkter	dummyParam.layer =kAL_Panel_Index;//kAL_Panel_Num	GetActionField( d, &dummyParam, anAction, kAL_Popup_Group_ID);//kAlter_Field_Str_Res_ID//kAlter_Field_ID_Offset//kAlter_Field_ID_Multiplier// MS = make sparks	dummyParam.layer =kMS_Panel_Index;//kMS_ID_Offset	GetActionField( d, &dummyParam, anAction, kMS_howMany);	GetActionField( d, &dummyParam, anAction, kMS_speed);	GetActionField( d, &dummyParam, anAction, kMS_velocityRange);	GetActionField( d, &dummyParam, anAction, kMS_color);// RE = release energy	dummyParam.layer =kRE_Panel_Index;//kRE_ID_Offset	GetActionField( d, &dummyParam, anAction, kRE_percent);// LA = land at	dummyParam.layer =kLA_Panel_Index;//kLA_ID_Offset	GetActionField( d, &dummyParam, anAction, kLA_landingSpeed);// AI = which initial object	dummyParam.layer =kAI_Panel_Index;//kLA_ID_Offset	GetActionField( d, &dummyParam, anAction, kAI_whichInitialObject);// EW = enter warp	dummyParam.layer = kEW_Panel_Index;//kEW_ID_Offset	GetActionField( d, &dummyParam, anAction, kEW_warpSpeed);// DM = display message	dummyParam.layer =kDM_Panel_Index;//kDM_ID_Offset	GetActionField( d, &dummyParam, anAction, kDM_resID);	GetActionField( d, &dummyParam, anAction, kDM_pageNum);// CS = change score	dummyParam.layer =kCS_Panel_Index;//kCS_ID_Offset	GetActionField( d, &dummyParam, anAction, kCS_whichPlayer);	GetActionField( d, &dummyParam, anAction, kCS_whichScore);	GetActionField( d, &dummyParam, anAction, kCS_amount);// DW = declare winner	dummyParam.layer =kDW_Panel_Index;//kDW_ID_Offset	GetActionField( d, &dummyParam, anAction, kDW_whichPlayer);	GetActionField( d, &dummyParam, anAction, kDW_nextLevel);	GetActionField( d, &dummyParam, anAction, kDW_textID);// KO = kill object	dummyParam.layer =kKO_Panel_Index;//kKO_ID_Offset	GetActionField( d, &dummyParam, anAction, kKO_dieType);// CF = color flash	dummyParam.layer =kCF_Panel_Index;//kCF_ID_Offset	GetActionField( d, &dummyParam, anAction, kCF_length);	GetActionField( d, &dummyParam, anAction, kCF_color);	GetActionField( d, &dummyParam, anAction, kCF_shade);// kMC = mini computer	dummyParam.layer =kMC_Panel_Index;	GetActionField( d, &dummyParam, anAction, kMC_screenNumber);	GetActionField( d, &dummyParam, anAction, kMC_lineNumber);	dummyParam.layer = kDK_Panel_Index;	if (( anAction->verb == kEnableKeys) || ( anAction->verb == kDisableKeys))		anAction->argument.keys.keyMask = d->action.argument.keys.keyMask;	GetActionField( d, &dummyParam, anAction, kDK_keyMask);	dummyParam.layer = kEK_Panel_Index;	GetActionField( d, &dummyParam, anAction, kEK_keyMask);		dummyParam.layer = kSZ_Panel_Index;	GetActionField( d, &dummyParam, anAction, kSZ_zoomLevel);	if ( anAction->verb == kAlter)	{		dummyParam.master = d->alter;		dummyParam.layer = anAction->argument.alterObject.alterType;				GetActionField( d, &dummyParam, anAction, kAlter_Field_ID_Offset + 			(dummyParam.layer * kAlter_Field_ID_Multiplier));		GetActionField( d, &dummyParam, anAction, kAlter_Field_ID_Offset + 			(dummyParam.layer * kAlter_Field_ID_Multiplier) + 2);		GetActionField( d, &dummyParam, anAction, kAlter_Field_ID_Offset + 			(dummyParam.layer * kAlter_Field_ID_Multiplier) + 6);	}	MakeActionName( d->heraFile, anAction, nil, -1, s);	HUI_Control_SetListCell( 		d->listMaster, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, 0, index,		(Ptr)&s[1], s[0]);	aControl = HUI_Control_Get( 		d->listMaster, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Draw1Control( aControl);	}	BlockMoveData( anAction, &d->action, sizeof( objectActionType));	SetPort( oldPort);	HSetState( d->actionData, actionDataState);}	static void SetActionField( Action_EditorWindowType *d, huiPlainControlParamType *dummyParam,	objectActionType *a, long id, Boolean draw){	ControlHandle	aControl;	Str255			s;		if ( dummyParam == nil) return;	if ( a == nil) return;	if ( id < 0) return;		aControl = HUI_Control_Get( dummyParam->master, dummyParam->layer, dummyParam->cellx,		dummyParam->celly, id);	if ( aControl == nil) return;		switch( id)	{		// qualifiers		case kQualifier_Inclusive_ID:			HU_Menu_SetCheckFromBits( aControl, a->inclusiveFilter, 0, 31);			break;					case kQualifier_Exclusive_ID:			HU_Menu_SetCheckFromBits( aControl, a->exclusiveFilter, 0, 31);			break;					case kQualifier_Delay_ID:			SetControlTextItemLong( aControl, a->delay);			break;		case kQualifier_Subject_ID:			SetControlTextItemLong( aControl, a->initialSubjectOverride);			break;		case kQualifier_Direct_ID:			SetControlTextItemLong( aControl, a->initialDirectOverride);			break;				case kQualifier_Reflexive_ID:			SetControlValue( aControl, (a->reflexive)?(1):(0));			break;				case kQualifier_LevelKey_ID:				SetControlValue( aControl, (a->exclusiveFilter == 0xffffffff) ?					(1) : (0) );			if ( a->exclusiveFilter == 0xffffffff)			{				HUI_Control_Hilite( dummyParam->master, dummyParam->layer, dummyParam->cellx,					dummyParam->celly, kQualifier_Exclusive_ID, 0);				HUI_Control_Hilite( dummyParam->master, dummyParam->layer, dummyParam->cellx,					dummyParam->celly, kQualifier_Exclusive_Button_ID, 0);			} else if ( !d->chooseOnly)			{				HUI_Control_Hilite( dummyParam->master, dummyParam->layer, dummyParam->cellx,					dummyParam->celly, kQualifier_Exclusive_ID, 1);				HUI_Control_Hilite( dummyParam->master, dummyParam->layer, dummyParam->cellx,					dummyParam->celly, kQualifier_Exclusive_Button_ID, 1);			}			break;					case kOwner_Group_ID:			SetControlValue( aControl, a->owner + 2);			break;// CO = create object			case kArgument_Popup_ID:				SetControlValue( aControl, a->verb + 1);				ChangeActionNumber( d, a->verb);			break;						case kCO_whichBaseType:				if ( a->verb != kCreateObject) return;//				SetControlTextItemLong( aControl, a->argument.createObject.whichBaseType);				SetControlTextItemString( aControl,					GetObjectName_WithID_FromDiscreteObjectID( d->heraFile, 						a->argument.createObject.whichBaseType, s, 0));			break;						case kCO_howManyMinimum:				if ( a->verb != kCreateObject) return;				SetControlTextItemLong( aControl, a->argument.createObject.howManyMinimum);			break;						case kCO_howManyRange:				if ( a->verb != kCreateObject) return;				SetControlTextItemLong( aControl, a->argument.createObject.howManyRange);			break;						case kCO_velocityRelative:				if ( a->verb != kCreateObject) return;				SetControlValue( aControl, (a->argument.createObject.velocityRelative)?(1):(0));			break;						case kCO_directionRelative:				if ( a->verb != kCreateObject) return;				SetControlValue( aControl, (a->argument.createObject.directionRelative)?(1):(0));			break;						case kCO_randomDistance:				if ( a->verb != kCreateObject) return;				SetControlTextItemLong( aControl, a->argument.createObject.randomDistance);			break;						case kPS_priority:				if ( a->verb != kPlaySound) return;								SetControlValue( aControl, a->argument.playSound.priority + 1);			break;						case kPS_persistence:				if ( a->verb != kPlaySound) return;								SetControlTextItemLong( aControl, a->argument.playSound.persistence);			break;						case kPS_absolute:				if ( a->verb != kPlaySound) return;								SetControlValue( aControl, (a->argument.playSound.absolute)?(1):(0));			break;						case kPS_volumeMinimum:				if ( a->verb != kPlaySound) return;								SetControlTextItemLong( aControl, a->argument.playSound.volumeMinimum);			break;						case kPS_volumeRange:				if ( a->verb != kPlaySound) return;								SetControlTextItemLong( aControl, a->argument.playSound.volumeRange);			break;						case kPS_idMinimum:				if ( a->verb != kPlaySound) return;				//				SetControlTextItemLong( aControl, a->argument.playSound.idMinimum);				SetControlTextItemString( aControl,					HNM_Resource_Name_Make( d->heraFile, 'snd ',					a->argument.playSound.idMinimum, s));			break;						case kPS_idRange:				if ( a->verb != kPlaySound) return;								SetControlTextItemLong( aControl, a->argument.playSound.idRange);			break;						case kAL_Popup_Group_ID:				if ( a->verb != kAlter) return;				SetControlValue( aControl, a->argument.alterObject.alterType + 1);				ChangeAlterNumber( d, a->argument.alterObject.alterType);			break;												case kMS_howMany:				if (a->verb != kMakeSparks)					return;				SetControlTextItemLong( aControl, a->argument.makeSparks.howMany);			break;						case kMS_speed:				if (a->verb != kMakeSparks)					return;				SetControlTextItemLong( aControl, a->argument.makeSparks.speed);			break;						case kMS_velocityRange:				if (a->verb != kMakeSparks)					return;				SetControlTextItemSmallFixed( aControl, a->argument.makeSparks.velocityRange);			break;						case kMS_color:				if (a->verb != kMakeSparks)					return;				SetControlValue( aControl, a->argument.makeSparks.color + 1);			break;									case kRE_percent:				if (a->verb != kReleaseEnergy)					return;				SetControlTextItemSmallFixed( aControl, a->argument.releaseEnergy.percent);			break;									case kLA_landingSpeed:				if (a->verb != kLandAt)					return;				SetControlTextItemLong( aControl, a->argument.landAt.landingSpeed);			break;						case kAI_whichInitialObject:				if (a->verb != kAssumeInitialObject)					return;				SetControlTextItemLong( aControl, a->argument.assumeInitial.whichInitialObject);			break;						case kEW_warpSpeed:				if (a->verb != kEnterWarp)					return;				SetControlTextItemSmallFixed( aControl, a->argument.enterWarp.warpSpeed);			break;									case kDM_resID:				if (a->verb != kDisplayMessage)					return;				SetControlTextItemLong( aControl, a->argument.displayMessage.resID);			break;						case kDM_pageNum:				if (a->verb != kDisplayMessage)					return;				SetControlTextItemLong( aControl, a->argument.displayMessage.pageNum);			break;						case kCS_whichPlayer:				if (a->verb != kChangeScore)					return;				SetControlTextItemLong( aControl, a->argument.changeScore.whichPlayer);			break;						case kCS_whichScore:				if (a->verb != kChangeScore)					return;				SetControlTextItemLong( aControl, a->argument.changeScore.whichScore);			break;						case kCS_amount:				if (a->verb != kChangeScore)					return;				SetControlTextItemLong( aControl, a->argument.changeScore.amount);			break;						case kDW_whichPlayer:				if (a->verb != kDeclareWinner)					return;				SetControlTextItemLong( aControl, a->argument.declareWinner.whichPlayer);			break;						case kDW_nextLevel:				if (a->verb != kDeclareWinner)					return;				SetControlTextItemLong( aControl,					HD_ChapterNumber_GetFromScenarioIndex( d->heraFile->scenarioData,						a->argument.declareWinner.nextLevel));			break;						case kDW_textID:				if (a->verb != kDeclareWinner)					return;				SetControlTextItemLong( aControl, a->argument.declareWinner.textID);			break;									case kKO_dieType:				if (a->verb != kDie)					return;				SetControlValue( aControl, a->argument.killObject.dieType + 1);			break;						case kCF_length:				if (a->verb != kColorFlash)					return;				SetControlTextItemLong( aControl, a->argument.colorFlash.length);			break;						case kCF_color:				if (a->verb != kColorFlash)					return;				SetControlValue( aControl, a->argument.colorFlash.color + 1);			break;						case kCF_shade:				if (a->verb != kColorFlash)					return;				SetControlTextItemLong( aControl, a->argument.colorFlash.shade);			break;						case kMC_screenNumber:				if (a->verb != kComputerSelect)					return;				SetControlTextItemLong( aControl, a->argument.computerSelect.screenNumber);			break;			case kMC_lineNumber:				if (a->verb != kComputerSelect)					return;				SetControlTextItemLong( aControl, a->argument.computerSelect.lineNumber);			break;						case kDK_keyMask:				if (a->verb != kDisableKeys)					return;				HU_Menu_SetCheckFromBits( aControl, a->argument.keys.keyMask, 0, 31);				break;							case kEK_keyMask:				if (a->verb != kEnableKeys)					return;				HU_Menu_SetCheckFromBits( aControl, a->argument.keys.keyMask, 0, 31);				break;						case kSZ_zoomLevel:				if ( a->verb != kSetZoom)					return;				SetControlValue( aControl, a->argument.zoom.zoomLevel);				break;							default:				if ( a->verb != kAlter) return;				{					long	whichField = id % kAlter_Field_ID_Multiplier;					switch( whichField)					{						case 0:	// relative							SetControlValue( aControl, (a->argument.alterObject.relative)?(1):(0));							break;												case 2: // min							switch( a->argument.alterObject.alterType)							{								case kAlterOffline:								case kAlterSpin:								case kAlterVelocity:									SetControlTextItemSmallFixed( aControl,										a->argument.alterObject.minimum);																		break;								case kAlterBaseType:									SetControlTextItemString( aControl,										GetObjectName_WithID_FromDiscreteObjectID(											d->heraFile, 											a->argument.alterObject.minimum, s, 0));									break;																		default:									SetControlTextItemLong( aControl,										a->argument.alterObject.minimum);									break;							}							break;						case 6: // range							switch( a->argument.alterObject.alterType)							{								case kAlterHidden:								case kAlterConditionTrueYet:									SetControlTextItemLong( aControl,										a->argument.alterObject.range + 1);									break;																default:									SetControlTextItemLong( aControl,										a->argument.alterObject.range);									break;							}							break;					}				}				}	if ( draw) Draw1Control( aControl);}static void GetActionField( Action_EditorWindowType *d, huiPlainControlParamType *dummyParam,	objectActionType *a, long id){	ControlHandle	aControl;		if ( dummyParam == nil) return;	if ( a == nil) return;	if ( id < 0) return;		aControl = HUI_Control_Get( dummyParam->master, dummyParam->layer, dummyParam->cellx,		dummyParam->celly, id);	if ( aControl == nil) return;		switch( id)	{		// qualifiers		case kQualifier_Inclusive_ID://			HU_Menu_SetCheckFromBits( aControl, a->inclusiveFilter, 0, 31);			break;					case kQualifier_Exclusive_ID://			HU_Menu_SetCheckFromBits( aControl, a->exclusiveFilter, 0, 31);			break;					case kQualifier_Delay_ID:			a->delay = GetControlTextItemLong( aControl);			break;		case kQualifier_Subject_ID:			a->initialSubjectOverride = GetControlTextItemLong( aControl);			break;		case kQualifier_Direct_ID:			a->initialDirectOverride = GetControlTextItemLong( aControl);			break;				case kQualifier_Reflexive_ID:			a->reflexive = GetControlValue( aControl);			break;				case kQualifier_LevelKey_ID:			if ( GetControlValue( aControl))				a->exclusiveFilter = 0xffffffff;			break;					case kOwner_Group_ID:			a->owner = GetControlValue( aControl) - 2;			break;// CO = create object			case kArgument_Popup_ID:				a->verb = (objectVerbIDType)(GetControlValue( aControl) - 1);			break;						case kCO_whichBaseType://				if ( a->verb != kCreateObject) return;//				a->argument.createObject.whichBaseType = GetControlTextItemLong( aControl);			break;						case kCO_howManyMinimum:				if ( a->verb != kCreateObject) return;				a->argument.createObject.howManyMinimum = GetControlTextItemLong( aControl);			break;						case kCO_howManyRange:				if ( a->verb != kCreateObject) return;				 a->argument.createObject.howManyRange = GetControlTextItemLong( aControl);			break;						case kCO_velocityRelative:				if ( a->verb != kCreateObject) return;				a->argument.createObject.velocityRelative = GetControlValue( aControl);			break;						case kCO_directionRelative:				if ( a->verb != kCreateObject) return;				a->argument.createObject.directionRelative = GetControlValue( aControl);			break;						case kCO_randomDistance:				if ( a->verb != kCreateObject) return;				 a->argument.createObject.randomDistance = GetControlTextItemLong( aControl);			break;						case kPS_priority:				if ( a->verb != kPlaySound) return;								 a->argument.playSound.priority = (soundPriorityType)(GetControlValue( aControl) - 1);			break;						case kPS_persistence:				if ( a->verb != kPlaySound) return;								 a->argument.playSound.persistence = GetControlTextItemLong( aControl);			break;						case kPS_absolute:				if ( a->verb != kPlaySound) return;								a->argument.playSound.absolute = GetControlValue( aControl);			break;						case kPS_volumeMinimum:				if ( a->verb != kPlaySound) return;								 a->argument.playSound.volumeMinimum = GetControlTextItemLong( aControl);			break;						case kPS_volumeRange:				if ( a->verb != kPlaySound) return;								 a->argument.playSound.volumeRange = GetControlTextItemLong( aControl);			break;						case kPS_idMinimum://				if ( a->verb != kPlaySound) return;				//				 a->argument.playSound.idMinimum = GetControlTextItemLong( aControl);			break;						case kPS_idRange:				if ( a->verb != kPlaySound) return;								 a->argument.playSound.idRange = GetControlTextItemLong( aControl);			break;						case kAL_Popup_Group_ID:				if ( a->verb != kAlter) return;				 a->argument.alterObject.alterType = (alterVerbIDType)(GetControlValue( aControl) - 1);			break;												case kMS_howMany:				if (a->verb != kMakeSparks)					return;				 a->argument.makeSparks.howMany = GetControlTextItemLong( aControl);			break;						case kMS_speed:				if (a->verb != kMakeSparks)					return;				 a->argument.makeSparks.speed = GetControlTextItemLong( aControl);			break;						case kMS_velocityRange:				if (a->verb != kMakeSparks)					return;				 a->argument.makeSparks.velocityRange = GetControlTextItemSmallFixed( aControl);			break;						case kMS_color:				if (a->verb != kMakeSparks)					return;				a->argument.makeSparks.color = GetControlValue( aControl) - 1;			break;									case kRE_percent:				if (a->verb != kReleaseEnergy)					return;				 a->argument.releaseEnergy.percent = GetControlTextItemSmallFixed( aControl);			break;									case kLA_landingSpeed:				if (a->verb != kLandAt)					return;				 a->argument.landAt.landingSpeed = GetControlTextItemLong( aControl);			break;						case kAI_whichInitialObject:				if (a->verb != kAssumeInitialObject)					return;				 a->argument.assumeInitial.whichInitialObject = GetControlTextItemLong( aControl);			break;						case kEW_warpSpeed:				if (a->verb != kEnterWarp)					return;				 a->argument.enterWarp.warpSpeed = GetControlTextItemSmallFixed( aControl);			break;									case kDM_resID:				if (a->verb != kDisplayMessage)					return;				 a->argument.displayMessage.resID = GetControlTextItemLong( aControl);			break;						case kDM_pageNum:				if (a->verb != kDisplayMessage)					return;				 a->argument.displayMessage.pageNum = GetControlTextItemLong( aControl);			break;						case kCS_whichPlayer:				if (a->verb != kChangeScore)					return;				 a->argument.changeScore.whichPlayer = GetControlTextItemLong( aControl);			break;						case kCS_whichScore:				if (a->verb != kChangeScore)					return;				 a->argument.changeScore.whichScore = GetControlTextItemLong( aControl);			break;						case kCS_amount:				if (a->verb != kChangeScore)					return;				 a->argument.changeScore.amount = GetControlTextItemLong( aControl);			break;						case kDW_whichPlayer:				if (a->verb != kDeclareWinner)					return;				 a->argument.declareWinner.whichPlayer = GetControlTextItemLong( aControl);			break;						case kDW_nextLevel:				if (a->verb != kDeclareWinner)					return;				 a->argument.declareWinner.nextLevel =				 	HD_ScenarioIndex_GetFromChapterNumber( d->heraFile->scenarioData,				 		GetControlTextItemLong( aControl));			break;						case kDW_textID:				if (a->verb != kDeclareWinner)					return;				 a->argument.declareWinner.textID = GetControlTextItemLong( aControl);			break;									case kKO_dieType:				if (a->verb != kDie)					return;				 a->argument.killObject.dieType = (dieVerbIDType)(GetControlValue( aControl) - 1);			break;						case kCF_length:				if (a->verb != kColorFlash)					return;				 a->argument.colorFlash.length = GetControlTextItemLong( aControl);			break;						case kCF_color:				if (a->verb != kColorFlash)					return;				 a->argument.colorFlash.color = GetControlValue( aControl) - 1;			break;						case kCF_shade:				if (a->verb != kColorFlash)					return;				 a->argument.colorFlash.shade = GetControlTextItemLong( aControl);			break;						case kMC_screenNumber:				if (a->verb != kComputerSelect)					return;				a->argument.computerSelect.screenNumber = GetControlTextItemLong( aControl);			break;			case kMC_lineNumber:				if (a->verb != kComputerSelect)					return;				a->argument.computerSelect.lineNumber = GetControlTextItemLong( aControl);			break;						case kSZ_zoomLevel:				if ( a->verb != kSetZoom)					return;				a->argument.zoom.zoomLevel = GetControlValue( aControl);				break;							default:				if ( a->verb != kAlter) return;				{					long	whichField = id % kAlter_Field_ID_Multiplier;					switch( whichField)					{						case 0:	// relative							a->argument.alterObject.relative = GetControlValue( aControl);							break;												case 2: // min							switch( a->argument.alterObject.alterType)							{								case kAlterOffline:								case kAlterSpin:								case kAlterVelocity:									a->argument.alterObject.minimum = GetControlTextItemSmallFixed( aControl);											break;																case kAlterBaseType:									// do nothing; automatically set									break;																	default:									a->argument.alterObject.minimum = GetControlTextItemLong( aControl);									break;							}							break;						case 6: // range							switch( a->argument.alterObject.alterType)							{								case kAlterHidden:								case kAlterConditionTrueYet:									a->argument.alterObject.range =										GetControlTextItemLong( aControl) - 1;									break;																	default:																a->argument.alterObject.range =										GetControlTextItemLong( aControl);									break;							}							break;					}				}				}}static OSErr SortSuperList( Action_EditorWindowType *d, Boolean draw){	short			currentSelectionIndex = 0, dataLength = 0;	long			currentSelectionReference = 0, i = 0, thisReference;	Ptr				data = nil;	OSErr			err = noErr;	ControlHandle	aControl = nil;	ListHandle		list = nil;	Boolean 		done, found;		// in order to preserve the selection,	// we have to get its arbitrary reference #		currentSelectionIndex =  HUI_Control_GetListValue(			d->listMaster, 0, kSuperList_Cell_X, kSuperList_Cell_Y,			kSuperList_ID, d->superActionIndex);		aControl = HUI_Control_Get( 		d->listMaster, 0, kSuperList_Cell_X, kSuperList_Cell_Y,		kSuperList_ID);			if ( aControl == nil) return paramErr;	GetListBoxListHandle( aControl, &list);		if ( list == nil) return paramErr;		data = List_Utilities_GetCell(list, (Point){currentSelectionIndex, 0},		&dataLength);		if ( data == nil) return memFullErr;		PsuedoColumn_String_GetAll( data, dataLength,		&currentSelectionReference, (StringPtr)-1);	DisposePtr( data);	if ( d->superActionID >= 0) currentSelectionReference = d->superActionID;	switch( d->sortBy)	{			case kSortByName:			err = List_Utilities_QSort( list, (Point){0, 0},				(Point){(**list).dataBounds.bottom - 1, 0},				CompareCellsByName);			break;				case kSortByID:			err = List_Utilities_QSort( list, (Point){0, 0},				(Point){(**list).dataBounds.bottom - 1, 0},				CompareCellsByID);			break;		}		// now we have to find our selection; we may as well start with its original	// position		done = found = false;	i = 0;		while (( !done) && ( !found))	{		if ( (currentSelectionIndex + i) < (**list).dataBounds.bottom)		{			data = List_Utilities_GetCell(list, (Point){currentSelectionIndex + i, 0},				&dataLength);			if ( data != nil)			{				PsuedoColumn_String_GetAll( data, dataLength,					&thisReference, (StringPtr)-1);								if ( thisReference == currentSelectionReference)				{					found = true;					currentSelectionIndex = currentSelectionIndex + i;				}				DisposePtr( data);			}		} else done = true;		if ( (currentSelectionIndex - i) >= 0)		{			data = List_Utilities_GetCell(list, (Point){currentSelectionIndex - i, 0},				&dataLength);			if ( data != nil)			{				PsuedoColumn_String_GetAll( data, dataLength,					&thisReference, (StringPtr)-1);								if ( thisReference == currentSelectionReference)				{					found = true;					currentSelectionIndex = currentSelectionIndex - i;				}				DisposePtr( data);			}			done = false;		} else		{			// do nothing; if done was previously true, keep it true			// if it was false, keep it false		}		i++;	}	d->superActionIndex = HUI_Control_SetListValue( d->listMaster, 0, kSuperList_Cell_X, kSuperList_Cell_Y,			kSuperList_ID, currentSelectionIndex);	LAutoScroll( list);	if ( draw) Draw1Control( aControl);		return err;}static short CompareCellsByName( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	name_a, name_b;	long	result;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, nil, name_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, nil, name_b, -1);	result = pstrcmp_nocase( name_a, name_b);	return -result;}static short CompareCellsByID( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	id_string_a, id_string_b;	long	id_a, id_b;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, id_string_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, id_string_b, -1);	StringToNum( id_string_a, &id_a);	StringToNum( id_string_b, &id_b);	if ( id_a < id_b)	{		return 1;	} else if ( id_a > id_b)	{		return -1;	} else	{		return 0;	}}static void SetInclusiveBits( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Action_EditorWindowType			*d;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Action_EditorWindowType *)*data;	d->action.inclusiveFilter = bits;	HU_HUIMenu_SetCheckFromBits( d->qualifier, 0, kQualifier_Cell_X, kQualifier_Cell_Y,		kQualifier_Inclusive_ID, bits, 0, 31);		HSetState( data, dataState);}static void SetExclusiveBits( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Action_EditorWindowType			*d;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Action_EditorWindowType *)*data;	d->action.exclusiveFilter = bits;	HU_HUIMenu_SetCheckFromBits( d->qualifier, 0, kQualifier_Cell_X, kQualifier_Cell_Y,		kQualifier_Exclusive_ID, bits, 0, 31);		HSetState( data, dataState);}static void SetKeyBits( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Action_EditorWindowType			*d;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Action_EditorWindowType *)*data;	d->action.argument.keys.keyMask = bits;	HU_HUIMenu_SetCheckFromBits( d->argument, kDisableKeys, kArgument_Main_Cell_X, kArgument_Main_Cell_Y,		kDK_keyMask, bits, 0, 31);		HU_HUIMenu_SetCheckFromBits( d->argument, kEnableKeys, kArgument_Main_Cell_X, kArgument_Main_Cell_Y,		kEK_keyMask, bits, 0, 31);	HSetState( data, dataState);}static void CreateObject_Choose_CallBack( long dispatchID, long objectChoiceID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	Action_EditorWindowType			*d = nil;	huiPlainControlParamType		dummyParam;	SignedByte						dataState;	if ( objectChoiceID < 0) return;		if ( data == nil) return;			dataState = HGetState( data);	HLock( data);	d = (Action_EditorWindowType *)*data;	d->action.argument.createObject.whichBaseType = objectChoiceID;		dummyParam.master = d->argument;	dummyParam.cellx = kArgument_Main_Cell_X;	dummyParam.celly = kArgument_Main_Cell_Y;	dummyParam.layer = kCO_Panel_Index;		SetActionField( d, &dummyParam, &d->action, kCO_whichBaseType, true);	HSetState( data, dataState);}static void AlterBaseType_Choose_CallBack( long dispatchID, long objectChoiceID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	Action_EditorWindowType			*d = nil;	huiPlainControlParamType		dummyParam;	SignedByte						dataState;	if ( objectChoiceID < 0) return;		if ( data == nil) return;			dataState = HGetState( data);	HLock( data);	d = (Action_EditorWindowType *)*data;	d->action.argument.alterObject.minimum = objectChoiceID;		dummyParam.master = d->alter;	dummyParam.cellx = kArgument_Main_Cell_X;	dummyParam.celly = kArgument_Main_Cell_Y;	dummyParam.layer = kAlterBaseType;		SetActionField( d, &dummyParam, &d->action, kAlter_Field_ID_Offset +		(kAlterBaseType * kAlter_Field_ID_Multiplier) + 2, true);	HSetState( data, dataState);}static void WinningTextCallBack( long windowID, long resID){	Handle						windowData =									GetDispatchWindowDataHandle( windowID);	SignedByte					dataState;	Action_EditorWindowType		*d;	huiPlainControlParamType	dummyParam;		if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);	d = (Action_EditorWindowType *)*windowData;		d->action.argument.declareWinner.textID = resID;		dummyParam.master = d->argument;	dummyParam.layer = kDW_Panel_Index;	dummyParam.cellx = kArgument_Main_Cell_X;	dummyParam.celly = kArgument_Main_Cell_Y;			SetActionField( d, &dummyParam, &d->action, kDW_textID, true);		HSetState( windowData, dataState);}static void ChooseSoundCallBack( long windowID, long resID){	Handle						windowData =									GetDispatchWindowDataHandle( windowID);	SignedByte					dataState;	Action_EditorWindowType		*d;	huiPlainControlParamType	dummyParam;		if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);	d = (Action_EditorWindowType *)*windowData;		d->action.argument.playSound.idMinimum = resID;		dummyParam.master = d->argument;	dummyParam.layer = kPS_Panel_Index;	dummyParam.cellx = kArgument_Main_Cell_X;	dummyParam.celly = kArgument_Main_Cell_Y;			SetActionField( d, &dummyParam, &d->action, kPS_idMinimum, true);		HSetState( windowData, dataState);}static void Enable_Editing( Action_EditorWindowType *d, Boolean enable){	HUI_Cell_Set_Enabled( d->master, 0, kMain_Cell_X, kMain_Cell_Y, enable);}#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/OSErr Action_Editor_NewWindow( heraScenarioFileType *heraFile,	StringPtr titlePrefix, short resRefNum,	long startActionIndex, long actionNum, long discreteDataID,	Boolean selectActionData, long callerID,	Action_Editor_Callback_procPtr callBack){	Rect						bounds;	CWindowPtr					newWindow;	ControlHandle				rootControl, aControl;	huiPlainControlParamType	buttonParam, textParam, groupParam;	huiMasterControlParamType	masterParam;	OSStatus					err;	Handle						data, strList, discreteData = nil;	Action_EditorWindowType		*d;	long						maxWidth = 0;	long						windowID = -1, i;	huiCellParamType			cellParam;	Str255						title;	#pragma unused ( err, textParam, aControl)	selectActionData = true;		if ( discreteDataID >= 0)	{		long	offset, size;				discreteData = HD_Find_Discrete_Data( heraFile, 			discreteDataID, -1, nil,			kHera_Action_Type);				if ( discreteData != nil)		{			HD_DiscreteData_GetOffsetAndSize( discreteData, &offset, &size);			startActionIndex = 0;			actionNum = size / sizeof( objectActionType);		}	} else	{		discreteData = HD_DiscreteData_GetNextOfType( heraFile, 			nil, kHera_Action_Type);		if ( discreteData != nil)			discreteDataID = ((heraDataHeaderType *)*discreteData)->id;		else		{			discreteDataID = HD_Get_NextID_From_Type( heraFile, 				kHera_Action_Type);			discreteData = HD_Create_Discrete_Data( heraFile, 				nil, 0, 0, discreteDataID,				kHera_Action_Type);			if ( discreteData != nil)				discreteDataID = ((heraDataHeaderType *)*discreteData)->id;		}			}		// create the new window	data = NewHandle( sizeof( Action_EditorWindowType));	if ( data == nil) return memFullErr;		HLock( data);		d = (Action_EditorWindowType *)*data;	d->resRefNum = resRefNum;	d->startActionIndex = startActionIndex;	d->actionNumber = actionNum;	d->whatAlter = d->whatAction = -1;	d->actionData = nil;	d->whichAction = 0;	d->setInclusive_WindowID = -1;	d->setExclusive_WindowID = -1;	d->discreteData = discreteData;	d->selectActionData = selectActionData;	if ( d->selectActionData) d->columnFix = 0;	else d->columnFix = 1;	d->superActionIndex = -1;	d->superActionID = discreteDataID;	d->sortBy = kSortByID;	d->callBack = callBack;	d->callerID = callerID;	d->heraFile = heraFile;	if ( titlePrefix == nil)	{		d->titlePrefix[0] = 0;		pstrcpy( title, "\pSequences");	} else	{		pstrcpy( d->titlePrefix, titlePrefix);		pstrcpy( title, titlePrefix);		pstrcat( title, "\p: Sequences");	}		if ( heraFile->fileRefNum <= 0) d->chooseOnly = true;	else d->chooseOnly = false;		SetRect( &bounds, 64, 64, 128, 128);	newWindow = NewDispatchWindow( &bounds, title, false,		kWindowMovableModalDialogProc, (WindowPtr)-1, false,		HandleEvent, 0,		&windowID);	SetDispatchWindowDataHandle( windowID, data);	d->windowID = windowID;		SetThemeWindowBackground( (WindowPtr)newWindow,		kThemeActiveDialogBackgroundBrush, true);	SetPortWindowPort( (WindowPtr)newWindow);	CreateRootControl( (WindowPtr)newWindow, &rootControl);	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kRowNum;	masterParam.colNum = kColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->master = HUI_MasterControl_New( nil, 0, 0, 0, &masterParam);		mAssert( d->master != nil);	if ( d->master == nil) return memFullErr;	HUI_Master_ShowLayer( d->master, 0);	d->master->tab[0][0].h = kLarge_Tab_Width;	d->master->tab[0][0].hAlign = hui_halign_right;	cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	// set up main cell	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.vAlign = hui_valign_center;	SetRect( &cellParam.outSpace, 0, 0, 0, 0);	SetRect( &cellParam.inSpace, 0, 0, 0, 0);	HUI_Cell_Set( 0, kMain_Cell_X, kMain_Cell_Y, &cellParam);	// set up list master cell	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.vAlign = hui_valign_center;	SetRect( &cellParam.outSpace, 0, 0, 0, 0);	SetRect( &cellParam.inSpace, 0, 0, 0, 0);	HUI_Cell_Set( 0, kList_Master_Cell_X, kList_Master_Cell_Y, &cellParam);	// separator	cellParam.minMaxBounds.right = kHUI_Pixel_Max;		// set up list sub-master	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kList_Master_RowNum;	masterParam.colNum = kList_Master_ColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->listMaster = HUI_MasterControl_New( d->master, 0, kList_Master_Cell_X,		kList_Master_Cell_Y, &masterParam);	mAssert( d->listMaster != nil);	if ( d->listMaster == nil) return memFullErr;	HUI_Master_ShowLayer( d->listMaster, 0);	d->listMaster->tab[0][0].h = kLarge_Tab_Width;	d->listMaster->tab[0][0].hAlign = hui_halign_right;	d->listMaster->tab[0][1].h = kLarge_Tab_Width;	d->listMaster->tab[0][1].hAlign = hui_halign_left;	// set up super list cell	if ( d->selectActionData)	{		// set up list title cell		cellParam.master = d->listMaster;		cellParam.baseLine = -1;		cellParam.hAlign = hui_halign_center;		cellParam.vAlign = hui_valign_top;		cellParam.flags = huiControlFlag_none;		SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);		SetRect( &cellParam.outSpace, -1, -1, -1, -1);		SetRect( &cellParam.inSpace, -1, -1, -1, -1);		SetRect( &cellParam.inSpace, -1, -1, 3, 3);		SetRect( &cellParam.outSpace, -1, -1, 3, 3);		cellParam.colSpan = 1;		cellParam.rowSpan = 1;		cellParam.baseLine = gHera->smallFontSize;		d->listMaster->rowDontExpand[kSuperList_Title_Cell_Y] = true;		cellParam.hAlign = hui_halign_left;		HUI_Cell_Set( 0, kSuperList_Title_Cell_X, kSuperList_Title_Cell_Y, &cellParam);		cellParam.hAlign = hui_halign_center;		SetRect( &cellParam.outSpace, -1, -1, -1, -1);		SetRect( &cellParam.inSpace, -1, -1, -1, -1);		SetRect( &cellParam.outSpace, 12, -1, -1, 5);		SetRect( &cellParam.inSpace, 3, -1, 3, 3);		cellParam.colSpan = 1;		cellParam.rowSpan = 1;		cellParam.hAlign = hui_halign_right;		HUI_Cell_Set( 0, kSuperList_Cell_X, kSuperList_Cell_Y, &cellParam);			// set up list button cells		SetRect( &cellParam.inSpace, -1, -1, -1, -1);		SetRect( &cellParam.outSpace, -1, -1, -1, -1);		cellParam.colSpan = 1;		cellParam.rowSpan = 1;		cellParam.baseLine = gHera->smallFontSize;		cellParam.hAlign = hui_halign_center;		d->listMaster->rowDontExpand[kSuperList_Button_Cell_Y] = true;		HUI_Cell_Set( 0, kSuperList_Button_Cell_X, kSuperList_Button_Cell_Y, &cellParam);	}				// set up list title cell	cellParam.master = d->listMaster;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, 3);	SetRect( &cellParam.outSpace, -1, -1, -1, 3);	if ( d->selectActionData)		cellParam.colSpan = 1;	else		cellParam.colSpan = 2;	cellParam.rowSpan = 1;	cellParam.baseLine = gHera->smallFontSize;	d->listMaster->rowDontExpand[kList_Title_Cell_Y] = true;	cellParam.hAlign = hui_halign_left;	HUI_Cell_Set( 0, kList_Title_Cell_X-d->columnFix, kList_Title_Cell_Y, &cellParam);	cellParam.hAlign = hui_halign_center;	// set up list cell	SetRect( &cellParam.outSpace, 12, -1, -1, 5);	SetRect( &cellParam.inSpace, 3, -1, 3, 3);	if ( d->selectActionData)		cellParam.colSpan = 1;	else		cellParam.colSpan = 2;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_right;	HUI_Cell_Set( 0, kList_Cell_X - d->columnFix, kList_Cell_Y, &cellParam);	// set up list button cells	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	if ( d->selectActionData)		cellParam.colSpan = 1;	else		cellParam.colSpan = 2;	cellParam.rowSpan = 1;	cellParam.baseLine = gHera->smallFontSize;	cellParam.hAlign = hui_halign_center;	d->listMaster->rowDontExpand[kList_Button_Cell_Y] = true;	HUI_Cell_Set( 0, kList_Button_Cell_X-d->columnFix, kList_Button_Cell_Y, &cellParam);	// set up main sub-master	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kMain_Master_RowNum;	masterParam.colNum = kMain_Master_ColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->mainMaster = HUI_MasterControl_New( d->master, 0, kMain_Cell_X,		kMain_Cell_Y, &masterParam);	mAssert( d->mainMaster != nil);	if ( d->mainMaster == nil) return memFullErr;	HUI_Master_HideLayer( d->mainMaster, 0);	d->mainMaster->tab[0][0].h = kLarge_Tab_Width;	d->mainMaster->tab[0][0].hAlign = hui_halign_right;	d->mainMaster->tab[0][1].h = kLarge_Tab_Width;	d->mainMaster->tab[0][1].hAlign = hui_halign_left;	// set up main master cells	cellParam.master = d->mainMaster;	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_center;	SetRect( &cellParam.outSpace, -1, -1, 12, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	HUI_Cell_Set( 0, kQualifier_Master_Cell_X, kQualifier_Master_Cell_Y, &cellParam);	HUI_Cell_Set( 0, kArgument_Master_Cell_X, kArgument_Master_Cell_Y, &cellParam);		// set up buttons, general	buttonParam.master = d->master;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask | kControlUseJustMask;	buttonParam.fontStyle.font = kSmallFontNum;	buttonParam.fontStyle.size = kSmallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = teCenter;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;	buttonParam.flags = huiControlFlag_none;		if ( d->chooseOnly)		buttonParam.enabled = false;			// set up text general	textParam.master = d->master;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = 8;	textParam.space.top = 10;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = -1;	textParam.cellx = kQualifier_Cell_X;	textParam.celly = kQualifier_Cell_Y;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;	if ( d->chooseOnly)		textParam.enabled = false;			if ( d->selectActionData)	{		// make selection list		buttonParam.enabled = true;				buttonParam.master = d->listMaster;		buttonParam.id = kSuperList_ID;		buttonParam.minMaxBounds.left = 160;		buttonParam.minMaxBounds.right = 160;		buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;//200;		buttonParam.minMaxBounds.top = 200;		buttonParam.minMaxBounds.bottom = 200;		buttonParam.cellx = kSuperList_Cell_X;		buttonParam.celly = kSuperList_Cell_Y;		buttonParam.special.listBox.ldesResID = 130;	// psuedo-column ldef		buttonParam.special.listBox.refCon = 131;		// psuedo-column params		buttonParam.flags = huiControlFlag_useCellV;		HUI_ListBox_New_LiteralP( &buttonParam);				if ( d->chooseOnly)			buttonParam.enabled = false;					buttonParam.minMaxBounds.left = 0;		buttonParam.minMaxBounds.top = 0;		buttonParam.minMaxBounds.right = kHUI_Pixel_Max;		buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;				// set up super list title				textParam.master = d->listMaster;		textParam.cellx = kSuperList_Title_Cell_X;		textParam.celly = kSuperList_Title_Cell_Y;		textParam.id = kSuperList_Title_ID;		GetIndString( textParam.label, kStrResID, 51);		textParam.flags = huiControlFlag_none;		textParam.fontStyle.style = gHera->smallFontBoldStyle;		HUI_StaticText_New_LiteralP( &textParam);		textParam.fontStyle.style = 0;				// set up list buttons				buttonParam.id = kSuperList_Add_Button_ID;		buttonParam.cellx =  kSuperList_Button_Cell_X;		buttonParam.celly =  kSuperList_Button_Cell_Y;		buttonParam.flags = huiControlFlag_none;		GetIndString( buttonParam.label, kStrResID, 55);		HUI_PushButton_New_LiteralP( &buttonParam);		//		buttonParam.id = kSuperList_Remove_Button_ID;//		buttonParam.cellx =  kSuperList_Button_Cell_X;//		buttonParam.celly =  kSuperList_Button_Cell_Y;//		buttonParam.flags = huiControlFlag_none;//		GetIndString( buttonParam.label, kHera_AppStrResID, 10);//		HUI_PushButton_New_LiteralP( &buttonParam);	}	// make selection list	buttonParam.enabled = true;	buttonParam.master = d->listMaster;	buttonParam.id = kList_ID;	buttonParam.minMaxBounds.left = 160;	buttonParam.minMaxBounds.right = 160;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;//200;	buttonParam.minMaxBounds.top = 200;	buttonParam.minMaxBounds.bottom = 200;	buttonParam.cellx = kList_Cell_X - d->columnFix;	buttonParam.celly = kList_Cell_Y;	buttonParam.special.listBox.ldesResID = 128;	buttonParam.special.listBox.refCon = 0;	buttonParam.flags = huiControlFlag_useCellV;	HUI_ListBox_New_LiteralP( &buttonParam);		if ( d->chooseOnly)		buttonParam.enabled = false;		buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// set up list title		textParam.master = d->listMaster;	textParam.cellx = kList_Title_Cell_X-d->columnFix;	textParam.celly = kList_Title_Cell_Y;	textParam.id = kList_Title_ID;	GetIndString( textParam.label, kStrResID, 52);	textParam.flags = huiControlFlag_none;	textParam.fontStyle.style = gHera->smallFontBoldStyle;	HUI_StaticText_New_LiteralP( &textParam);	textParam.fontStyle.style = 0;	// set up list buttons		buttonParam.id = kList_Add_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X-d->columnFix;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 9);	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.id = kList_Remove_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X-d->columnFix;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 10);	HUI_PushButton_New_LiteralP( &buttonParam);	buttonParam.master = d->master;	// set up action selection group		groupParam.master = d->mainMaster;	groupParam.visible = true;	groupParam.enabled = true;	groupParam.whichTabSet = -1;	groupParam.whichTab = -1;	groupParam.layer = 0;	groupParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;	groupParam.fontStyle.font = gHera->smallFontNum;	groupParam.fontStyle.size = gHera->smallFontSize;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;	groupParam.helpStringResID = -1;	groupParam.id = kArgument_Popup_ID;	groupParam.cellx = kArgument_Master_Cell_X;	groupParam.celly = kArgument_Master_Cell_X;	groupParam.special.menuStrList.strList = GetStringList( 559);	groupParam.fontStyle.style = gHera->smallFontStyle;	if ( d->chooseOnly) groupParam.enabled = false;		if ( groupParam.special.menuStrList.strList != nil)	{		groupParam.special.menuStrList.menuID = HU_GetNewMenuID();		groupParam.special.menuStrList.multiSelect = false;		SetRect( &groupParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);		GetIndString( groupParam.label, kStrResID, 1); // ignored		HUI_Group_PopupButton_New_StrList( &groupParam);//		HUI_Group_New_LiteralP( &groupParam);		ReleaseResource( groupParam.special.menuStrList.strList);	}		groupParam.enabled = true;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;	groupParam.cellx = kQualifier_Master_Cell_X;	groupParam.celly = kQualifier_Master_Cell_Y;	groupParam.special.group.isSecondary = false;	GetIndString( groupParam.label, kStrResID, 1); // qualifiers	HUI_Group_New_LiteralP( &groupParam);		// set up argument master	masterParam.rowNum = kArgument_Master_RowNum;	masterParam.colNum = kArgument_Master_ColNum;	masterParam.layerNum = kArgument_Panel_Num;	d->argument = HUI_MasterControl_New( d->mainMaster, 0, kArgument_Master_Cell_X,		kArgument_Master_Cell_Y, &masterParam);			mAssert( d->argument != nil);	if ( d->argument == nil) return memFullErr;	HUI_Master_HideLayer( d->argument, 0);		d->argument->tab[0][0].h = kLarge_Tab_Width;	d->argument->tab[0][0].hAlign = hui_halign_right;	d->argument->tab[0][1].h = kLarge_Tab_Width;	d->argument->tab[0][1].hAlign = hui_halign_left;		Setup_Argument_Panel( d, newWindow);		// set up qualifier master	masterParam.rowNum = kQualifier_Master_RowNum;	masterParam.colNum = kQualifier_Master_ColNum;	masterParam.layerNum = 1;	d->qualifier = HUI_MasterControl_New( d->mainMaster, 0, kQualifier_Master_Cell_X,		kQualifier_Master_Cell_Y, &masterParam);		mAssert( d->qualifier != nil);	if ( d->qualifier == nil) return memFullErr;	HUI_Master_HideLayer( d->qualifier, 0);	d->qualifier->tab[0][0].h = kLarge_Tab_Width;	d->qualifier->tab[0][0].hAlign = hui_halign_right;	d->qualifier->tab[0][1].h = kLarge_Tab_Width;	d->qualifier->tab[0][1].hAlign = hui_halign_left;	// set up qualifier cells	cellParam.master = d->qualifier;	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	SetRect( &cellParam.outSpace, 12, 0, 12, 0);	SetRect( &cellParam.inSpace, -1, -1, -1, 12);	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_center;	HUI_Cell_Set( 0, kQualifier_Cell_X, kQualifier_Cell_Y, &cellParam);	SetRect( &cellParam.outSpace, 12, 0, 12, 18);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	HUI_Cell_Set( 0, kOwner_Cell_X, kOwner_Cell_Y, &cellParam);	groupParam.master = d->qualifier;	groupParam.cellx = kOwner_Cell_X;	groupParam.celly = kOwner_Cell_Y;	groupParam.id = kOwner_Group_ID;	GetIndString( groupParam.label, kStrResID, 2); // owner	groupParam.visible = true;	groupParam.id = kOwner_Group_ID - 1;	groupParam.special.group.isSecondary = true;	HUI_Group_New_LiteralP( &groupParam);	groupParam.id = kOwner_Group_ID;	HUI_RadioGroup_New_LiteralP( &groupParam);		buttonParam.master = d->qualifier;	buttonParam.cellx = kOwner_Cell_X;	buttonParam.celly = kOwner_Cell_Y;		buttonParam.id = kOwner_Enemy_ID;	buttonParam.flags = huiControlFlag_none;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;		GetIndString( buttonParam.label, kStrResID, 8); // enemy	HUI_RadioButton_New_LiteralP( &buttonParam);		buttonParam.flags = huiControlFlag_newLine;	buttonParam.id = kOwner_Any_ID;	GetIndString( buttonParam.label, kStrResID, 9); // any	HUI_RadioButton_New_LiteralP( &buttonParam);	buttonParam.id = kOwner_Friend_ID;	GetIndString( buttonParam.label, kStrResID, 10); // friend	HUI_RadioButton_New_LiteralP( &buttonParam);	// set up qualifiers		// set up text, general		textParam.master = d->qualifier;	textParam.cellx = kQualifier_Cell_X;	textParam.celly = kQualifier_Cell_Y;	buttonParam.master = d->qualifier;	buttonParam.layer = 0;	buttonParam.cellx = kQualifier_Cell_X;	buttonParam.celly = kQualifier_Cell_Y;		buttonParam.id = kQualifier_Reflexive_ID;	GetIndString( buttonParam.label, kStrResID, 44);	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 1;	buttonParam.flags = huiControlFlag_none;	HUI_CheckBox_New_LiteralP( &buttonParam);		AddBitPopUp( &textParam, &buttonParam, kQualifier_Inclusive_ID, kStrResID, 3,		true, 600);	buttonParam.id = kQualifier_LevelKey_ID;	GetIndString( buttonParam.label, kStrResID, 53);	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 1;	buttonParam.flags = huiControlFlag_newLine;	HUI_CheckBox_New_LiteralP( &buttonParam);		AddBitPopUp( &textParam, &buttonParam, kQualifier_Exclusive_ID, kStrResID, 4,		true, 600);	// Delay label	textParam.minMaxBounds.left = 0;	textParam.id = kQualifier_Delay_ID-1;	GetIndString( textParam.label, kStrResID, 5); // Delay filter	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_newLine;	HUI_StaticText_New_LiteralP( &textParam);		// Delay edit	textParam.id = kQualifier_Delay_ID;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.label[0] = 0;	HUI_EditText_New_LiteralP( &textParam);		// Subject label	textParam.minMaxBounds.left = 0;	textParam.id = kQualifier_Subject_ID-1;	GetIndString( textParam.label, kStrResID, 6); // Subject filter	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_newLine;	HUI_StaticText_New_LiteralP( &textParam);		// Subject edit	textParam.id = kQualifier_Subject_ID;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.label[0] = 0;	HUI_EditText_New_LiteralP( &textParam);		// Direct label	textParam.minMaxBounds.left = 0;	textParam.id = kQualifier_Direct_ID -1;	GetIndString( textParam.label, kStrResID, 7); // Direct filter	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_newLine;	HUI_StaticText_New_LiteralP( &textParam);		// Direct edit	textParam.id = kQualifier_Direct_ID;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.label[0] = 0;	HUI_EditText_New_LiteralP( &textParam);			// set up default buttons	strList = GetStringList( kHera_DefaultMainButtonStrResID);	if ( strList != nil)	{		HUI_Main_Buttons_H_Setup( d->master, 0,			kSeparator_Cell_X, kColNum, kSeparator_Cell_Y, 1,				true, strList);				ReleaseResource( strList);	}		HUI_Master_Layout( d->master, (Point){0, 0}, (Point){0, 0});	HUI_Master_HideAllLayers_Deep( d->mainMaster);	HUI_Master_ShowAllLayers_Deep( d->mainMaster);	HUI_Master_ShowLayer( d->mainMaster, 0);	HUI_Master_ShowAllControls( d->mainMaster, 0, true);//	HUI_Master_ShowLayer( d->argument, 1);//	HUI_Master_ShowAllControls( d->argument, 1, true);//	HUI_Master_ShowAllControls( d->argument, 2, true);	for ( i = 0; i < d->argument->layerNum; i++)	{		HUI_Master_HideLayer( d->argument, i);	}		d->whatAction = -1;	ChangeActionNumber( d, 1);	ChangeActionNumber( d, kAL_Panel_Index);//	ChangeAlterNumber( d, 1);	for ( i = 0; i < d->alter->layerNum; i++)	{		ChangeAlterNumber( d, i);	}		ShowWindow( (WindowPtr)newWindow);	SetUpSuperList( d);	GetAllData( d);		gHera->modalMode++;		if ( d->discreteData == nil) Enable_Editing( d, false);	else if ( HD_DiscreteData_GetElementNumber( d->discreteData,				kHera_Action_Type) <= 0) Enable_Editing( d, false);					HUnlock( data);	return noErr;}static void InsertSequence( Action_EditorWindowType *d, CWindowPtr whichWindow){	Ptr					data = nil;	long				dataLength;	ControlHandle		aControl;	Str255				s, ids;	Point				cell;	ListHandle			list;		d->heraFile->changed = true;		Window_SetAction_FromControls( d,		whichWindow, d->whichAction + d->startActionIndex);	aControl = HUI_Control_Get( 		d->listMaster, 0, kSuperList_Cell_X, kSuperList_Cell_Y,		kSuperList_ID);	if ( aControl == nil) return;		GetListBoxListHandle( aControl, &list);	if ( list == nil) return;		if ( d->actionData == nil)	{		d->actionData = NewHandle( 0);		d->actionNumber = 0;	}		d->discreteData = HD_Create_Discrete_Data( d->heraFile,				d->actionData, 0,		d->actionNumber, HD_Get_NextID_From_Type( d->heraFile, 			kHera_Action_Type),		kHera_Action_Type);			if ( d->discreteData != nil)	{		GetActionNameFromDiscreteAction( d->heraFile, 			d->discreteData, s,			false);		d->superActionID = ((heraDataHeaderType *)*(d->discreteData))->id;		NumToString( ((heraDataHeaderType *)*(d->discreteData))->id,			ids);		if ( s[0] == 0) pstrcpy( s, "\puntitled");		data = PsuedoColumn_Data_Make( &dataLength,			((heraDataHeaderType *)*(d->discreteData))->id, ids,				"\p\t", s, "\p");		if ( data != nil)		{			LAddRow( 1, (**list).dataBounds.bottom, list );			cell.h = 0;			cell.v = (**list).dataBounds.bottom - 1;			LSetCell( data, dataLength, cell, list );			DisposePtr( data);		}	}//d->superActionIndex = 	HUI_Control_SetListValue( d->listMaster, 0, kSuperList_Cell_X, kSuperList_Cell_Y,			kSuperList_ID, (**list).dataBounds.bottom - 1);		ChangeSuperAction( d, whichWindow, (**list).dataBounds.bottom - 1);		LAutoScroll( list);	Draw1Control( aControl);		}static void InsertAction( Action_EditorWindowType *d, CWindowPtr whichWindow){	Ptr					data = nil;	long				dataLength;	ControlHandle		aControl;	Str255				s;		d->heraFile->changed = true;		Window_SetAction_FromControls( d,		whichWindow, d->whichAction + d->startActionIndex);		if ( d->actionNumber > 0)	{		HUI_Control_GetListCell( 			d->listMaster, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 0, d->whichAction,			&data, &dataLength);				HU_Handle_InsertData( d->whichAction, d->actionData, (Ptr)&d->action,			sizeof( objectActionType), 0);		HUI_Control_InsertListRows(			d->listMaster, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 1, d->whichAction);		if ( data != nil)		{			HUI_Control_SetListCell( 				d->listMaster, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, 0, d->whichAction,				data, dataLength);						DisposePtr( data);		}		d->actionNumber++;	} else	{		d->actionNumber = 1;			d->action.verb = kNoAction;		d->action.reflexive = false;		d->action.inclusiveFilter = d->action.exclusiveFilter = 0;		d->action.owner = 0;		d->action.delay = 0;		d->action.initialSubjectOverride = -1;		d->action.initialDirectOverride = -1;		d->action.reserved2 = 0;		HU_Handle_InsertData( d->whichAction, d->actionData, (Ptr)&d->action,			sizeof( objectActionType), 0);		MakeActionName( d->heraFile, &d->action, nil, 0, s);		d->whichAction = 0;				HUI_Control_InsertListRows(			d->listMaster, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 1, d->whichAction);				HUI_Control_SetListCell( 			d->listMaster, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 0, d->whichAction,			(Ptr)&s[1], s[0]);		Window_SetControls_FromActionIndex(			d, whichWindow, d->whichAction + d->startActionIndex			);				Enable_Editing( d, true);	}	d->whichAction = 		HUI_Control_GetListValue(			d->listMaster, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->whichAction);	aControl = HUI_Control_Get( 		d->listMaster, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Draw1Control( aControl);	}	}static void DeleteAction( Action_EditorWindowType *d, CWindowPtr whichWindow){	ControlHandle	aControl;		if ( d->actionNumber <= 0) return;		d->heraFile->changed = true;		HU_Handle_DeleteData( d->whichAction, d->actionData,		sizeof( objectActionType), 0);		HUI_Control_DeleteListRows(		d->listMaster, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, 1, d->whichAction);		d->whichAction = 		HUI_Control_SetListValue(			d->listMaster, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->whichAction);	aControl = HUI_Control_Get( 		d->listMaster, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		ListHandle	list = nil;				GetListBoxListHandle( aControl, &list);		if ( list != nil)		{			LAutoScroll(list);		}		Draw1Control( aControl);	}		d->actionNumber--;	if ( d->actionNumber <= 0) Enable_Editing( d, false);		Window_SetControls_FromActionIndex(		d, whichWindow, d->whichAction + d->startActionIndex		);	}