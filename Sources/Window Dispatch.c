/**\|**| Window Dispatch.c\**//**\|**| #includes\**//* - system*/#include <Appearance.h>/* - third party libraries*//* - bp libraries*/#include "BPMacOutput.h"#include "Assert.h"/* - this project*/#include "Window Dispatch.h"/**\|**| #defines\**//* - definitions*/#define	kMaxWindowNumber	128/* - macros*//**\|**| typedefs\**/typedef struct windowDataStruct{	CWindowPtr		window;	Boolean			(*eventHandler)(EventRecord *, CWindowPtr, long, long);	unsigned long	additionalData;	Handle			data;	Boolean			backgroundNullEvents;} windowDataType;/**\|**| external globals\**/WindowPtr			gHilitedWindow = nil;/**\|**| private globals\**/windowDataType *gWindowData = nil;/**\|**| private function prototypes\**/long GetFreeWindow( void);/**\|**| private functions\**//* GetFreeWindow	returns first unused window data; if no free window data, returns -1*/long GetFreeWindow( void){	long			i;	windowDataType	*window;		if ( gWindowData == nil) return -1;	i = 0;	window = gWindowData;	while (( i < kMaxWindowNumber) && ( window->window != nil))	{		i++;		window++;	}		if ( i >= kMaxWindowNumber) return -1;	return i;}/**\|**| public functions\**/OSStatus InitWindowDispatch( void){	long			i;	windowDataType	*window;		gWindowData = (windowDataType *)NewPtr( sizeof( windowDataType) * kMaxWindowNumber);	if ( gWindowData == nil) return -1;	window = gWindowData;	for ( i = 0; i < kMaxWindowNumber; i++)	{		window->window = nil;		window->data = nil;		window->backgroundNullEvents = false;		window++;	}	return 0;}void DisposeWindowDispatch( void){	long			i;	windowDataType	*window;	if ( gWindowData != nil)	{	window = gWindowData;		for ( i = 0; i < kMaxWindowNumber; i++)		{			if ( window->window != nil)			{				CloseDispatchWindow( i);			}			window++;		}		DisposePtr( (Ptr)gWindowData);	}}CWindowPtr NewDispatchWindow( Rect *boundsRect, StringPtr title,	Boolean visible, short procID, WindowPtr behind, Boolean goAwayFlag,	Boolean (*handleEventProc)(EventRecord *, CWindowPtr, long, long),	unsigned long additionalData, long *dispatchID){	long			whichDispatchWindow = GetFreeWindow();	windowDataType	*window;	OSStatus		err;	ControlHandle	aControl = nil;	WindowPtr		frontWindow = WD_FrontWindow();				if ( whichDispatchWindow < 0) return nil;	window = gWindowData + whichDispatchWindow;		{		GrafPtr	oldPort;		GetPort( &oldPort);	//	mAssert( frontWindow != nil);		if ( frontWindow != nil)	{		Str255	windowTitle;				GetWTitle( frontWindow, windowTitle);		//		DebugStr( windowTitle);				SetPortWindowPort( frontWindow);			BPMOWritePString("\pcalling get root control\r");		err = GetRootControl( frontWindow, &aControl);	//		mAssert( err == noErr);				if (( err == noErr) && ( aControl != nil))		{			BPMOWritePString("\pcalling deactivatecontrol\r");			DeactivateControl( aControl);		}	}		if ( oldPort != nil) SetPort( oldPort);		}	BPMOWritePString("\pcalling newcwindow\r");	window->window = NewCWindow( nil, boundsRect, title, visible, procID,		behind, goAwayFlag, whichDispatchWindow);	window->eventHandler = handleEventProc;	window->additionalData = additionalData;	window->data = nil;	window->backgroundNullEvents = false;	*dispatchID = whichDispatchWindow;	gHilitedWindow = window->window;	return( (CWindowPtr)window->window);}void CloseDispatchWindow( long windowID){	windowDataType	*window;	ControlHandle	aControl;	WindowPtr		frontWindow;	OSStatus		err;		if ( windowID < 0)	{		frontWindow = WD_FrontWindow();		windowID = GetDispatchWindowIDFromWindowPtr( (CWindowPtr)frontWindow);	}	if ( windowID < 0) return;		window = gWindowData + windowID;		if ( window->window != nil)	{		window->eventHandler( nil, window->window,			GetWRefCon( window->window), kWDCloseWindowCommand);//		CloseWindow( (WindowPtr)window->window);		DisposeWindow( window->window);//		window->window.refCon = -1;		if ( window->data != nil)			DisposeHandle( window->data);	}	frontWindow = WD_FrontWindow();	aControl = nil;			err = GetRootControl( frontWindow, &aControl);	if (( err == noErr) && ( aControl != nil))	{		ActivateControl( aControl);	}	}long GetDispatchWindowIDFromWindowPtr( CWindowPtr windowptr){	long			i;	windowDataType	*window;		if ( gWindowData == nil) return -1;	i = 0;	window = gWindowData;	while (( i < kMaxWindowNumber) && ( windowptr != (CWindowPtr)window->window))	{		i++;		window++;	}		if ( i >= kMaxWindowNumber) return -1;	return i;}CWindowPtr GetWindowPtrFromDispatchWindowID( long windowid){	long			i;	windowDataType	*window;		if ( gWindowData == nil) return nil;	i = 0;	window = gWindowData;	while ( i < kMaxWindowNumber)	{		if ( window->window != nil)		{			if ( GetWRefCon( window->window) == windowid)			{				return window->window;			}		}		i++;		window++;	}		if ( i >= kMaxWindowNumber) return nil;	return (CWindowPtr)window->window;}void WindowDispatch_BrindWindowIDToFront( long windowid){	CWindowPtr window = GetWindowPtrFromDispatchWindowID( windowid);		if ( window == nil) return;		SelectWindow( (WindowPtr)window);	gHilitedWindow = window;}unsigned long GetDispatchWindowAdditionalData( long windowid){	windowDataType	*window = gWindowData + windowid;	return( window->additionalData);}Handle GetDispatchWindowDataHandle( long windowid){	windowDataType	*window = gWindowData + windowid;	if ( windowid < 0) return nil;	return( window->data);}void SetDispatchWindowDataHandle( long windowid, Handle data){	windowDataType	*window = gWindowData + windowid;	if (( windowid < 0) || ( windowid >= kMaxWindowNumber)) DebugStr("\pillegal window id");	if ( window->data != nil) DebugStr("\psetting of non-zero window handle");	window->data = data;}Boolean DispatchWindowHandleEvent( EventRecord *theEvent,	unsigned long *menuChoice){	long			windowid, i;	windowDataType	*windowdata;	CWindowPtr		whichWindow;	short			whichPart;	char			whichChar;	Boolean			result = false;		switch ( theEvent->what ) 	{		case nullEvent:			whichWindow = (CWindowPtr)WD_FrontWindow();			windowid = GetDispatchWindowIDFromWindowPtr( whichWindow);			windowdata = gWindowData;			for ( i = 0; i < kMaxWindowNumber; i++)			{				if ( windowdata->window != nil)				{					if (( GetWRefCon( windowdata->window) != windowid) &&						( windowdata->backgroundNullEvents))										{						windowdata->eventHandler( theEvent, (CWindowPtr)(windowdata->window),							i, kWDProcessEventCommand);										}				}				windowdata++;			}						if ( windowid >= 0)			{				windowdata = gWindowData + windowid;				return windowdata->eventHandler( theEvent, whichWindow,					windowid, kWDProcessEventCommand);			} else return false;			break;					case updateEvt:			BPMOWritePString("\pdispatch activate ");			whichWindow = (CWindowPtr)theEvent->message;			windowid = GetDispatchWindowIDFromWindowPtr( whichWindow);			if ( windowid >= 0)			{				BPMOWritePString("\p id:");				BPMOWriteLong( windowid);				BPMOWritePString("\p\r");				windowdata = gWindowData + windowid;				return windowdata->eventHandler( theEvent, whichWindow,					windowid, kWDProcessEventCommand);			} else			{				BPMOWritePString("\punknown\r");				return false;			}			/*			if ( whichWindow != nil)			{				BeginUpdate (whichWindow);				SetPort( whichWindow);				EndUpdate (whichWindow);			}*/				break;		case mouseDown:			whichPart = FindWindow (theEvent->where,  (WindowPtr *)&whichWindow);//			if ( whichWindow != (CWindowPtr)WD_FrontWindow())			if ( whichWindow == nil) return false;			if ( !IsWindowHilited( whichWindow))			{				return false;			}			windowid = GetDispatchWindowIDFromWindowPtr( whichWindow);			BPMOWritePString("\pmouseDown windowID: ");			BPMOWriteLong( windowid);			BPMOWritePString("\p\r");						if ( windowid >= 0)			{				windowdata = gWindowData + windowid;				return windowdata->eventHandler( theEvent, whichWindow,					windowid, kWDProcessEventCommand);			} else return false;			break;		case mouseUp:			break;		case keyDown:		case autoKey:			whichWindow = (CWindowPtr)WD_FrontWindow();			windowid = GetDispatchWindowIDFromWindowPtr( whichWindow);			if ( windowid >= 0)			{				windowdata = gWindowData + windowid;				whichChar = theEvent->message & charCodeMask;				if (( theEvent->modifiers & cmdKey ) != 0)				{					if ( menuChoice == nil)					{						result = windowdata->eventHandler(								(EventRecord *)MenuEvent( theEvent),								whichWindow, windowid,								kWDProcessMenuChoiceCommand);					} else					{						*menuChoice = MenuEvent( theEvent);												result =  windowdata->eventHandler(								(EventRecord *)*menuChoice,								whichWindow, windowid,								kWDProcessMenuChoiceCommand);											}					HiliteMenu( 0);					return result;				}									return windowdata->eventHandler( theEvent, whichWindow,					windowid, kWDProcessEventCommand);			} else return false;			break;					case activateEvt:			whichWindow = (CWindowPtr)WD_FrontWindow();			windowid = GetDispatchWindowIDFromWindowPtr( whichWindow);			if ( windowid >= 0)			{				windowdata = gWindowData + windowid;				return windowdata->eventHandler( theEvent, whichWindow,					windowid, kWDProcessEventCommand);			} else return false;			return false;			break;	}	return false;}Boolean DispatchWindowHandleMenuChoice( short menuID, short menuItem){	CWindowPtr		whichWindow;	long			windowid;	windowDataType	*windowdata;	unsigned long	menuChoiceData;		whichWindow = (CWindowPtr)WD_FrontWindow();	windowid = GetDispatchWindowIDFromWindowPtr( whichWindow);	if ( windowid >= 0)	{		menuChoiceData = menuID;		menuChoiceData <<= 16;		menuChoiceData |= menuItem;				windowdata = gWindowData + windowid;		return windowdata->eventHandler( (EventRecord *)menuChoiceData, whichWindow,			windowid, kWDProcessMenuChoiceCommand);				} else return false;}Boolean DispatchWindowDispatchWDEvent( long wdEvent){	long			windowid;	windowDataType	*windowdata;	CWindowPtr		whichWindow, nextWindow;	whichWindow = (CWindowPtr)WD_FrontWindow();	while ( whichWindow != nil)	{#ifndef TARGET_API_MAC_CARBON		nextWindow = (CWindowPtr)(((WindowPeek)whichWindow)->nextWindow);#else		nextWindow = GetNextWindow( whichWindow);#endif TARGET_API_MAC_CARBON		windowid = GetDispatchWindowIDFromWindowPtr( whichWindow);		if ( windowid >= 0)		{			windowdata = gWindowData + windowid;			if  (windowdata->eventHandler( nil, whichWindow,				windowid, wdEvent) != false) return true;		}		whichWindow = nextWindow;	}	return false;/*	windowdata = gWindowData;	for ( i = 0; i < kMaxWindowNumber; i++)	{		if (( windowdata->window.refCon != -1) &&			( windowdata->eventHandler != nil))			{			if  (windowdata->eventHandler( nil, whichWindow,				i, wdEvent) != false) return true;		}		windowdata++;	}	return true;			*/}void DispatchWindowSave( long windowid){	CWindowPtr		frontWindow;	windowDataType	*windowdata;		if ( windowid < 0)	{		frontWindow = (CWindowPtr)WD_FrontWindow();		windowid = GetDispatchWindowIDFromWindowPtr( frontWindow);	}		if ( windowid < 0) return;		windowdata = gWindowData + windowid;	windowdata->eventHandler( nil, (CWindowPtr)windowdata->window,		windowid, kWDSaveWindowCommand);}void DispatchWindow_SetBackgroundNullEvents( long windowid, Boolean wantEvents){	windowDataType	*window;	if (( windowid < 0)  || ( windowid >= kMaxWindowNumber)) return;	window = gWindowData + windowid;	window->backgroundNullEvents = wantEvents;}WindowPtr WD_FrontWindow( void){	return gHilitedWindow;}