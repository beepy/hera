/******************************************\|**| Bit_Flipper.c\******************************************/#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Window Dispatch.h"#include "Control Utilities.h"#include "Hewey.h"#include "Hewey_Main.h"#include "Hewey_Layout.h"#include "Hewey_Utilities.h"#include "str_bp.h"#include "Set Font By String.h"#include "BP_Error.h"#include "Assert.h"#include "strlist.h"#include "Hewey_Helpers.h"#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/#include "Hera_Global.h"#include "Data_Selector.h"#include "Race_Editor.h"#include "Bit_Flipper.h"#include "Hera_Utilities.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kColNum							3#define	kRowNum							1#define	kMain_Cell_X					0#define	kMain_Cell_Y					0#define	kMain_ID_Offset					100#define	kSeparator_Cell_X				1#define	kSeparator_Cell_Y				0#define	kSeparator_ID					200#define	kButton_Cell_X					2#define	kButton_Cell_Y					0#define	kOK_Button_ID					1#define	kCancel_Button_ID				2#define	kRevert_Button_ID				3#define	kCheck_All_Button_ID			4#define	kUncheck_All_Button_ID			5#define	kStrResID						8003#define	kMaxBitNum						32#define	kDefaultBitNum					kMaxBitNum#pragma mark _macros_/* - macros*******************************************/#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/typedef struct bitFlipperWindowType{	huiMasterControlType			*master;	unsigned long					bits;	unsigned long					originalBits;	long							ownerWindowID;	long							bitNum;	bitFlipper_BitSetProcPtrType	setBitProc;	} bitFlipperWindowType;#pragma mark 본EXTERNAL GLOBALS본/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark 본PRIVATE GLOBALS본/******************************************\|**| private globals\******************************************/#pragma mark 본PRIVATE PROTOTYPES본/******************************************\|**| private function prototypes\******************************************/#pragma mark 본PRIVATE FUNCTIONS본/******************************************\|**| private functions\******************************************/static Boolean HandleEvent( EventRecord *, CWindowPtr, long, long);static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID);static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID);static void FlipBit( bitFlipperWindowType *d, long whichBit);static void SetBit( bitFlipperWindowType *d, long whichBit, Boolean bitIsOn);static void SetAllBits( bitFlipperWindowType *d);#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/static Boolean HandleEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID, long command){	switch( command)	{		case kWDCloseWindowCommand:			break;				case kWDProcessEventCommand:			return( ProcessEvent( theEvent, whichWindow, dispatchID));			break;				case kWDSaveWindowCommand:			return false;			break;		case kWDProcessMenuChoiceCommand:			return( ProcessMenuChoiceCommand( (unsigned long)theEvent,				whichWindow, dispatchID));			break;	}	return false;}static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	SignedByte						dataState;	bitFlipperWindowType			*d;	Boolean							result = false;	GrafPtr							oldPort;	short							menuID = ((menuData & 0xffff0000) >> 16),									menuItem = (menuData & 0x0000ffff);										if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (bitFlipperWindowType *)*data;	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);	result = Generic_ProcessMenuChoiceCommand( menuData, whichWindow,												dispatchID);	if ( result)	{		goto ProcessMenuChoiceCommand_Return;	}		switch( menuID)	{		case kEditMenuID:			switch( menuItem)			{				case kEdit_Undo_Item:					result = true;					break;				case kEdit_Add_Item:					result = true;					break;									case kEdit_Delete_Item:					result = true;					break;									case kEdit_Delete_All_Item:					result = true;					break;			}							break;		}	ProcessMenuChoiceCommand_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);}static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Boolean							result = false;	ControlHandle					aControl, oldControl;	short							whichPart, oldValue;	WindowPtr						scratchWindow;	Point							where;	char							whichChar;	GrafPtr							oldPort;	OSStatus						err;	bitFlipperWindowType			*d;		if ( data == nil) return false;	if ( theEvent == nil) return false;		dataState = HGetState( data);	HLock( data);	d = (bitFlipperWindowType *)*data;		if ( theEvent == nil) goto ProcessEvent_Return;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);		switch( theEvent->what)	{		case nullEvent:			IdleControls( (WindowPtr)whichWindow);						result = true;			break;					case updateEvt:				BeginUpdate ((WindowPtr)whichWindow);/*			SetPort( (WindowPtr)whichWindow);			CalcVis( (WindowPtr)whichWindow);			UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);*/			HU_GenericUpdateEventHandler( whichWindow);			EndUpdate ((WindowPtr)whichWindow);			result = true;			break;		case mouseDown:			whichPart = FindWindow (theEvent->where, &scratchWindow);			switch( whichPart)			{				case inGrow:/*					{						Rect	growRect;						long	newSize;//						growRect = qd.screenBits.bounds;						C2C_ScreenBits_GetBounds( &growRect);						growRect.top = growRect.left = 120;						newSize = GrowWindow((WindowPtr)whichWindow,							theEvent->where ,&growRect);						if (newSize != 0)						{							SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,								(((newSize) >> 16) & 0xFFFF), true );							EraseRect(&whichWindow->portRect);							InvalRect( &whichWindow->portRect);						}					}*/					HU_GenericGrowWindow( whichWindow, theEvent->where);					result = true;					break;								case inContent:					where = theEvent->where;					scratchWindow = WD_FrontWindow();					if ( whichWindow != (CWindowPtr)scratchWindow)					{						goto ProcessEvent_Return;					}					SetPortWindowPort( (WindowPtr)whichWindow);					GlobalToLocal( &where);					whichPart = FindControl( where, (WindowPtr)whichWindow,						&aControl);					if ( aControl == nil)						goto ProcessEvent_Return;					if ( aControl != nil)						oldValue = GetControlValue( aControl);					err = GetKeyboardFocus( (WindowPtr)whichWindow, &oldControl);					if (( err == noErr) && ( oldControl != aControl))					{						SetKeyboardFocus( (WindowPtr)whichWindow, aControl, whichPart);					}					if ( whichPart != 0)					{						huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);//						whichPart = HandleControlClick ( aControl, where,//							theEvent->modifiers, nil);						if ( !ListBox_Appearance_1_0_1_Hack( aControl, where,									&whichPart))						{							whichPart = HUI_Control_Click_Handle( hui, where,								theEvent->modifiers);														}							if (( hui->generic.id >= kMain_ID_Offset) &&							( hui->generic.id < ( kMain_ID_Offset + kMaxBitNum)							&& ( whichPart != kControlNoPart)))						{							FlipBit( d, hui->generic.id - kMain_ID_Offset);							result = true;						}												if ( whichPart != kControlNoPart) switch( hui->generic.id)						{							case kRevert_Button_ID:								d->bits = d->originalBits;								SetAllBits( d);								result = true;								break;														case kOK_Button_ID:								result = true;								if ( d->setBitProc != nil)									d->setBitProc( d->ownerWindowID, d->bits);								HUI_MasterControl_Delete( d->master);								gHera->modalMode--;								CloseDispatchWindow( dispatchID);								data = nil;								goto ProcessEvent_Return;								break;														case kCancel_Button_ID:								HUI_MasterControl_Delete( d->master);								gHera->modalMode--;								CloseDispatchWindow( dispatchID);								data = nil;								result = true;								goto ProcessEvent_Return;								break;														case kCheck_All_Button_ID:								{									long	i;																		for ( i = 0; i < d->bitNum; i++)									{										SetBit( d, i, true);									}								}								break;														case kUncheck_All_Button_ID:								{									long	i;																		for ( i = 0; i < d->bitNum; i++)									{										SetBit( d, i, false);									}								}								break;															default:								break;						}					} else // not in control					{						where = theEvent->where;						GlobalToLocal( &where);					}			}			break;					case keyDown:		case autoKey:			whichChar = theEvent->message & charCodeMask;			if ((whichChar=='\r' || whichChar==0x3))			{				// ok				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kOK_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);					result = true;					if ( d->setBitProc != nil)						d->setBitProc( d->ownerWindowID, d->bits);					HUI_MasterControl_Delete( d->master);					gHera->modalMode--;					CloseDispatchWindow( dispatchID);					data = nil;					goto ProcessEvent_Return;				}			} else if ((whichChar==0x1b) || ((whichChar=='.') && (theEvent->modifiers & cmdKey)))			{				// cancel				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kCancel_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);										HUI_MasterControl_Delete( d->master);					gHera->modalMode--;					CloseDispatchWindow( dispatchID);					data = nil;					result = true;					goto ProcessEvent_Return;				}			} else if ( whichChar == '\t')			{				if ( theEvent->modifiers & shiftKey)					ReverseKeyboardFocus( (WindowPtr)whichWindow);				else					AdvanceKeyboardFocus( (WindowPtr)whichWindow);				result = true;				break;			}						err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);			if (( err == noErr) && ( aControl != nil))			{				whichPart = HandleControlKey( aControl,					(theEvent->message & keyCodeMask)>>16,					theEvent->message & charCodeMask, theEvent->modifiers);				{				}			}			break;	}		ProcessEvent_Return:	SetPort( oldPort);	if ( data != nil)		HSetState( data, dataState);	return( result);	}static void FlipBit( bitFlipperWindowType *d, long whichBit){	unsigned long bitMask = (0x01) << whichBit;		if ( d->bits & bitMask) SetBit( d, whichBit, false);	else SetBit( d, whichBit, true);}static void SetBit( bitFlipperWindowType *d, long whichBit, Boolean bitIsOn){	Boolean	controlIsChecked = HUI_Control_GetValueShort( d->master, 0,		kMain_Cell_X, kMain_Cell_Y, kMain_ID_Offset + whichBit);		if ( controlIsChecked != bitIsOn)	{		HUI_Control_SetValueShort( d->master, 0,		 kMain_Cell_X, kMain_Cell_Y, kMain_ID_Offset + whichBit, bitIsOn, true);	}		if ( bitIsOn) d->bits |= 0x01 << whichBit;	else d->bits &= ~(0x01 << whichBit);}static void SetAllBits( bitFlipperWindowType *d){	long			i;	unsigned long	bit = 0x01;		for ( i = 0; i < d->bitNum; i++)	{		if ( d->bits & bit) SetBit( d, i, true);		else SetBit( d, i, false);		bit <<= 1;	}}#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/OSErr BitFlipper_NewWindow( long *windowID, StringPtr title,	Handle bitNameStringList, unsigned long bits, long ownerID,	bitFlipper_BitSetProcPtrType setBitProc){	Rect						bounds;	CWindowPtr					newWindow;	ControlHandle				rootControl, aControl;	huiPlainControlParamType	buttonParam, textParam;	huiMasterControlParamType	masterParam;	OSStatus					err;	Handle						data;	bitFlipperWindowType		*d;	Str255						s;	long						i, j, maxWidth = 0;#pragma unused ( err, textParam, aControl)		// create the new window	*windowID = -1;	data = NewHandle( sizeof( bitFlipperWindowType));	if ( data == nil) return memFullErr;		HLock( data);	d = (bitFlipperWindowType *)*data;	d->ownerWindowID = ownerID;	d->setBitProc = setBitProc;		SetRect( &bounds, 64, 64, 128, 128);	newWindow = NewDispatchWindow( &bounds, title, false,		kWindowMovableModalDialogProc, (WindowPtr)-1, false,		HandleEvent, 0,		windowID);	SetDispatchWindowDataHandle( *windowID, data);		SetThemeWindowBackground( (WindowPtr)newWindow,		kThemeActiveDialogBackgroundBrush, true);	SetPortWindowPort( (WindowPtr)newWindow);	CreateRootControl( (WindowPtr)newWindow, &rootControl);	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kRowNum;	masterParam.colNum = kColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = gHera->smallFontSize;	d->master = HUI_MasterControl_New( nil, 0, 0, 0, &masterParam);		mAssert( d->master != nil);	if ( d->master == nil) return memFullErr;	d->master->tab[0][0].h = 112;	d->master->tab[0][0].hAlign = hui_halign_right;	// set up buttons, general	buttonParam.master = d->master;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	buttonParam.fontStyle.font = gHera->smallFontNum;	buttonParam.fontStyle.size = gHera->smallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = -1;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;	// make main check boxes, one for each bit		buttonParam.flags = huiControlFlag_none;	buttonParam.cellx = kMain_Cell_X;	buttonParam.celly = kMain_Cell_Y;		if ( bitNameStringList == nil)	{			d->bitNum = kDefaultBitNum;	} else	{		d->bitNum = StringListSize( bitNameStringList);	}	for ( i = 0; i < 8; i++)	{		for ( j = i; j <= ( i + 24); j += 8)		{			if ( j < d->bitNum)			{				huiPlainControlType *hui;				Boolean				isGood = true;								if ( bitNameStringList == nil) buttonParam.label[0] = 0;				else				{					RetrieveIndString( bitNameStringList, j + 1,						buttonParam.label);				}				if ( buttonParam.label[0] == 0)				{					GetIndString( buttonParam.label, kStrResID, 1); // bit #					NumToString( j, s);					pstrcat( buttonParam.label, s);					isGood = false;				}				buttonParam.id = kMain_ID_Offset + j;				buttonParam.whichTabSet = 0;				buttonParam.whichTab = (j - i) / 8;				hui = HUI_CheckBox_New_LiteralP( &buttonParam);				if ( hui != nil)				{					if ( hui->generic.control != nil)					{						Rect	controlBounds;												CU_GetControlBounds( hui->generic.control,												&controlBounds);																		if ( (controlBounds.right -							controlBounds.left) > maxWidth)						{							maxWidth = (controlBounds.right -										controlBounds.left);						}					}									}				if ( !isGood) DeactivateControl( hui->generic.control // , kControlDisabledPart					);				buttonParam.flags = huiControlFlag_none;			}		}		buttonParam.flags = huiControlFlag_newLine;	}	j = 0;	for ( i = 0; i < 4; i++)	{		d->master->tab[0][i].h = j;		d->master->tab[0][i].hAlign = hui_halign_left;		j += maxWidth + 8;	}		buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	/*	// set up separator	buttonParam.cellx = kSeparator_Cell_X;	buttonParam.celly = kSeparator_Cell_Y;	buttonParam.id = kSeparator_ID;	buttonParam.flags = huiControlFlag_useCellH;	buttonParam.minMaxBounds.bottom = 8;	buttonParam.space.top = 0;	buttonParam.space.left = 0;	HUI_SeparatorLine_New( &buttonParam);		// set up main buttons	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.minMaxBounds.left = 120;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.cellx = kButton_Cell_X;	buttonParam.celly = kButton_Cell_Y;	buttonParam.flags = huiControlFlag_none;	buttonParam.fontStyle.font = gHera->bigFontNum;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.size = gHera->bigFontSize;		// cancel	buttonParam.id = kCancel_Button_ID;	buttonParam.space.left = 24;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 4); // cancel	HUI_PushButton_New_LiteralP( &buttonParam);		// revert	buttonParam.id = kRevert_Button_ID;	buttonParam.space.left = 24;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 5); // revert	HUI_PushButton_New_LiteralP( &buttonParam);		// ok	buttonParam.flags = (huiControlFlagType)((int)huiControlFlag_isDefault | (int)huiControlFlag_none);	buttonParam.id = kOK_Button_ID;	buttonParam.space.left = 0;	GetIndString( buttonParam.label, kHera_AppStrResID, 3); // ok	HUI_PushButton_New_LiteralP( &buttonParam);	*/		HUI_Main_Buttons_V_Setup( d->master, 0,		kSeparator_Cell_X, 1, kSeparator_Cell_Y, 1, true, GetStringList( 8017));		ShowWindow( (WindowPtr)newWindow);	HUI_Master_Layout( d->master, (Point){0, 0}, (Point){0, 0});	HUI_Master_ShowLayer( d->master, 0);	d->bits = d->originalBits = bits;	SetAllBits( d);		HUnlock( data);	gHera->modalMode++;		return noErr;}