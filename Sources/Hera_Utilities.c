/******************************************\|**| Hera_Utilities.c\******************************************/#pragma mark ¥¥INCLUDES¥¥/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Hewey_Utilities.h"#include "Control Utilities.h"#include "Assert.h"#include "String Numerics.h"#include "strlist.h"#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/#include "Hera_Utilities.h"#include "Hera_Global.h"#include "Hera_ResourceTracker.h"#pragma mark ¥¥DEFINITIONS¥¥/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#pragma mark _macros_/* - macros*******************************************/#pragma mark ¥¥TYPEDEFS¥¥/******************************************\|**| typedefs\******************************************/typedef union testType {	long	bif;	short	baf;	Str63	zip;	struct	{		long	gizzyGo;		long	gizzyGoo;	} gizzyGum;} testType;typedef struct genericWindowDataType{	heraScenarioFileType	*heraFile;} genericWindowDataType;#pragma mark ¥¥EXTERNAL GLOBALS¥¥/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;OSErr HeraFile_SaveAs( heraScenarioFileType *sourceFile, Boolean copy,	Boolean optimized);OSErr HeraFile_Save( heraScenarioFileType *sourceFile, Boolean optimized);#pragma mark ¥¥PRIVATE GLOBALS¥¥/******************************************\|**| private globals\******************************************/#pragma mark ¥¥PRIVATE PROTOTYPES¥¥/******************************************\|**| private function prototypes\******************************************/#pragma mark ¥¥PRIVATE FUNCTIONS¥¥/******************************************\|**| private functions\******************************************/#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/OSErr HU_Handle_InsertData( long index, Handle h, Ptr data, long unitSize,	long offset){	long		dataSize = 0, start = (unitSize * index) + offset;	OSStatus	err;	SignedByte	hstate;	testType	gizzyTest;		gizzyTest.baf = index;		if ( h == nil) return paramErr;	dataSize = GetHandleSize( h);	hstate = HGetState( h);	if ( start > dataSize) return paramErr;	if ( start < 0) return paramErr;	if ( unitSize < 1) return paramErr;	HUnlock( h);		SetHandleSize( h, dataSize + unitSize);	err = MemError();	if ( err != noErr)	{		HSetState( h, hstate);		return err;	}		HLock( h);	if ( start < ( dataSize))	{		BlockMoveData( *h + start, *h + start + unitSize, dataSize -			start);	}	BlockMoveData( data, *h + start, unitSize);	HSetState( h, hstate);	return noErr;}OSErr HU_Handle_DeleteData( long index, Handle h, long unitSize, long offset){	long		dataSize, start = (index * unitSize) + offset,				end = start + (unitSize-1);	OSStatus	err;	SignedByte	hstate;		if ( h == nil) return paramErr;	dataSize = GetHandleSize( h);	hstate = HGetState( h);	if ( start >= dataSize) return paramErr;	if ( start < 0) return paramErr;	if ( end < start) return paramErr;	if ( end >= dataSize) return paramErr;		HUnlock( h);	if ( end < (dataSize - 1))	{		BlockMoveData( *h + end + 1, *h + start, dataSize - (end+1));	}	SetHandleSize( h, dataSize - ((end - start) + 1));	err = MemError();	HSetState( h, hstate);	return err;}OSErr HU_Handle_CopyDataFromResource( long index, long num, Handle h, ResType resType,	short resID, short refNum, long unitSize){	long	dataSize = unitSize * num, start = index * unitSize, resHandleSize;	short	oldRefNum = CurResFile();	Handle	resHandle = nil;	OSErr	result = noErr;		if ( refNum > 0) UseResFile( refNum);	resHandle = GetResource( resType, resID);	if ( resHandle != nil)	{		resHandleSize = GetHandleSize( resHandle);		if ( start < resHandleSize)		{			if ( (start + dataSize) > resHandleSize)			{				dataSize = resHandleSize - start;			}			BlockMoveData( *resHandle + start, *h + start, dataSize);		}  else result = paramErr;		ReleaseResource( resHandle);	}	UseResFile( oldRefNum);	return result;}OSErr HU_Data_CopyFromHandle( Ptr dest, Handle source, long index,	long unitSize){	if ( dest == nil) return paramErr;	if ( source == nil) return paramErr;	if ( index < 0) return paramErr;	if ( index >= (GetHandleSize( source) / unitSize)) return paramErr;		BlockMoveData( *source + (unitSize * index), dest, unitSize);		return noErr;}OSErr HU_Handle_Insert( long start, Handle h, Ptr data, long insertSize){	long		dataSize = 0;	OSStatus	err;	SignedByte	hstate;		if ( h == nil) return paramErr;	dataSize = GetHandleSize( h);	hstate = HGetState( h);	if ( start > dataSize) return paramErr;	if ( start < 0) return paramErr;	if ( insertSize < 1) return paramErr;	HUnlock( h);		SetHandleSize( h, dataSize + insertSize);	err = MemError();	if ( err != noErr)	{		HSetState( h, hstate);		return err;	}		HLock( h);	if ( start < ( dataSize))	{		BlockMoveData( *h + start, *h + start + insertSize, dataSize -			start);	}	BlockMoveData( data, *h + start, insertSize);	HSetState( h, hstate);	return noErr;}Boolean HU_Data_Is_Identical( Ptr aData, Ptr dData, long dataSize){	unsigned char *ap = (unsigned char *)aData, *dp = (unsigned char *)dData;		while ( dataSize > 0)	{		if ( *ap != *dp) return false;		ap++;		dp++;		dataSize--;	}	return true;}StringPtr rstring( StringPtr s, short resid, short strnum){	GetIndString( s, resid, strnum);	return s;}void Resource_Replace( OSType resType, short resID, Handle h, StringPtr defaultName){	Handle oldData = GetResource( resType, resID);		if ( oldData != nil)	{		SetHandleSize( oldData, GetHandleSize( h));		if ( MemError())		{			Str255	resName;			ResType	tType;			short	tID;						// coldn't resize original data for some reason; try deleting it and dumping handle			GetResInfo( oldData, &tID, &tType, resName);			RemoveResource( oldData);			AddResource( h, resType, resID, resName);		} else		{			BlockMoveData( *h, *oldData, GetHandleSize( h));			ChangedResource( oldData);		}	} else	{		AddResource( h, resType, resID, defaultName);	}}void HU_HUIMenu_SetCheckFromBits( huiMasterControlType *master, long layer, long cellx, long celly,	long id, unsigned long bits, long startBit, long endBit){	MenuHandle				aMenu;	HUI_Control_GetBevelMenu( master, layer, cellx, celly,		id, &aMenu);	if ( aMenu != nil)	{		long			bitNum;		unsigned long	bit = 1 << startBit;				for ( bitNum = startBit; bitNum <= endBit; bitNum++)		{			if ( bits & bit)			{				SetItemMark( aMenu, bitNum + 1, '¥');			} else			{				SetItemMark( aMenu, bitNum + 1, noMark);			}			bit <<= 1;		}	}}void HU_Menu_SetCheckFromBits( ControlHandle aControl,	unsigned long bits, long startBit, long endBit){	MenuHandle				aMenu;	GetBevelMenuHandle( aControl, &aMenu);	if ( aMenu != nil)	{		long			bitNum;		unsigned long	bit = 1 << startBit;				for ( bitNum = startBit; bitNum <= endBit; bitNum++)		{			if ( bits & bit)			{				SetItemMark( aMenu, bitNum + 1, '¥');			} else			{				SetItemMark( aMenu, bitNum + 1, noMark);			}			bit <<= 1;		}	}}void HU_UseResFile( short factoryResFile, short *originalResFile){	mAssert( originalResFile != nil);	*originalResFile = CurResFile();	if ( factoryResFile > 0)		UseResFile( factoryResFile);//	if ( gHera->userDataFile_refNum <= 0) UseResFile( factoryResFile);//	else UseResFile( gHera->userDataFile_refNum);}void HU_GetResourceNameFromID( short resID, ResType resType, StringPtr name){	short			theID;	Handle			theResource;	ResType			dummyType;		mAssert( name != nil);	theResource = GetResource( resType, resID);	if ( theResource == nil)	{		name[0] = 0;		return;	}	GetResInfo( theResource, &theID, &dummyType, name);	ReleaseResource( theResource);}OSErr SetControlTextItemSmallFixed( ControlHandle aControl, smallFixedType f){	Str255	s;		SmallFixedToString( f, s);	return SetControlTextItemString( aControl, s);}smallFixedType GetControlTextItemSmallFixed( ControlHandle aControl){	Str255	s;		GetControlTextItemString( aControl, s);	return( StringToSmallFixed( s));}void ReverseCheckBox( ControlHandle aControl){	mAssert( aControl != nil);	SetControlValue( aControl, (GetControlValue( aControl))?(0):(1));}short HU_GetNewMenuID( void){	static short result = 999;		result++;	return result;}StringPtr HU_GetOneIndString( heraScenarioFileType *heraFile,	short resID, short stringIndex, StringPtr s){	Handle	tempData = HRT_Resource_GetHandle( heraFile, 'STR#', resID, nil,		nil);	s[0] = 0;		if ( tempData == nil) return s;		RetrieveIndString( tempData, stringIndex, s);		DisposeHandle( tempData);	return s;}Boolean Generic_ProcessMenuChoiceCommand(  unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	SignedByte						dataState;	Boolean							result = false;	GrafPtr							oldPort;	short							menuID = ((menuData & 0xffff0000) >> 16),									menuItem = (menuData & 0x0000ffff);	ControlHandle					aControl;	OSStatus						err;	heraScenarioFileType			*heraFile;	genericWindowDataType			*d;											if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (genericWindowDataType *)*data;	heraFile = d->heraFile;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);	switch( menuID)	{		case kEditMenuID:			err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);						if ( aControl != nil) switch( menuItem)			{				case kEditMenuID:					result = true;					break;									case kEdit_Undo_Item:					result = true;					break;									case kEdit_Cut_Item:					result = HUI_Control_AutoCut(						(huiGenericControlType *)CU_GetControlReference( aControl));					break;									case kEdit_Copy_Item:					result = HUI_Control_AutoCopy(						(huiGenericControlType *)CU_GetControlReference( aControl));					break;									case kEdit_Paste_Item:					result = HUI_Control_AutoPaste(						(huiGenericControlType *)CU_GetControlReference( aControl));					break;									case kEdit_Clear_Item:					result = true;					break;									case kEdit_Select_All_Item:					result = HUI_Control_AutoSelectAll(						(huiGenericControlType *)CU_GetControlReference( aControl));					break;									case kEdit_Add_Item:					result = true;					break;									case kEdit_Delete_Item:					result = true;					break;									case kEdit_Delete_All_Item:					result = true;					break;			}							break;				case kFileMenuID:			switch( menuItem)			{				case kFile_Save_Item:					HeraFile_Save( heraFile, false);					result = true;					break;								case kFile_Save_As_Item:					HeraFile_SaveAs( heraFile, false, false);					result = true;					break;								case kFile_Save_As_Optimized_Item:					HeraFile_SaveAs( heraFile, true, true);					result = true;					break;			}			break;	}	Generic_ProcessMenuChoiceCommand:	SetPort( oldPort);	HSetState( data, dataState);	return( result);}Boolean HU_Confirm_Delete( StringPtr deleteString, unsigned short modifiers){	unsigned char			okButton[] = "\pDelete",							cancelButton[] = "\pCancel";								AlertStdAlertParamRec	alertParam;	short					itemHit;	if ( modifiers & cmdKey) return true;		alertParam.movable = false;	alertParam.helpButton = false;	alertParam.filterProc = nil;	alertParam.defaultText = okButton;	alertParam.cancelText = cancelButton;	alertParam.otherText = nil;	alertParam.defaultButton = kAlertStdAlertOKButton;	alertParam.cancelButton = 0;	alertParam.position = kWindowDefaultPosition;	StandardAlert( kAlertCautionAlert, deleteString, "\pWhen deleting,  "		"hold down the command key to bypass this dialog",		&alertParam, &itemHit);	return (itemHit == kAlertStdAlertOKButton);}Boolean HU_ScenarioFiles_Equal( heraScenarioFileType *file1,	heraScenarioFileType *file2){	if (( file1 == nil) || ( file2 == nil)) return false;	if (file1->fileRefNum <= 0) return false;		return( (file1->fileRefNum == file2->fileRefNum)?(true):(false));}heraScenarioFileType *HU_HeraFile_Get_From_WindowID( long dispatchID){	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	heraScenarioFileType			*heraFile;	genericWindowDataType			*d;		if ( data == nil) return nil;		d = (genericWindowDataType *)*data;	heraFile = d->heraFile;	return heraFile;}void HU_AutoDefocus( CWindowPtr window){	OSErr			err;	ControlHandle	theControl;		if ( window == nil) return;	err = GetKeyboardFocus( (WindowPtr)window, &theControl);	if ( err != noErr) return;	if ( theControl == nil) return;	if ( !IsControlVisible( theControl))		ReverseKeyboardFocus( (WindowPtr)window);}void HU_GenericUpdateEventHandler( WindowPtr whichWindow){	GrafPtr		port;	RgnHandle	visibleRgn = NewRgn();		mAssert( whichWindow != nil);	port = GetWindowPort( whichWindow);	mAssert( port != nil);	mAssert( visibleRgn != nil);	GetPortVisibleRegion( port, visibleRgn);	BeginUpdate ((WindowPtr)whichWindow);	SetPortWindowPort( (WindowPtr)whichWindow);	CalcVis( (WindowPtr)whichWindow);//	UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);	UpdateControls( whichWindow, visibleRgn);	EndUpdate ((WindowPtr)whichWindow);	DisposeRgn( visibleRgn);}void HU_GenericGrowWindow( WindowPtr whichWindow, Point where){	Rect	growRect, windowPortRect;	long	newSize;	C2C_ScreenBits_GetBounds( &growRect);		growRect.top = growRect.left = 120;	newSize = GrowWindow((WindowPtr)whichWindow,		where ,&growRect);	if (newSize != 0)	{		SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,			(((newSize) >> 16) & 0xFFFF), true );//		EraseRect(&whichWindow->portRect);//		InvalRect( &whichWindow->portRect);		C2C_Window_GetPortBounds( whichWindow, &windowPortRect);		EraseRect( &windowPortRect);		InvalWindowRect( whichWindow, &windowPortRect);	}}