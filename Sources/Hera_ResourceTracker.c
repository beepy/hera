/******************************************\|**| Hera_ResourceTracker.c\******************************************/#pragma mark ¥¥INCLUDES¥¥/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Assert.h"#include "str_bp.h"#include "BP_Error.h"#include "BPMacOutput.h"#pragma mark _this library includes_/* - this project*******************************************/#include "Hera_Global.h"#include "Hera_ResourceTracker.h"#pragma mark ¥¥DEFINITIONS¥¥/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#pragma mark _macros_/* - macros*******************************************/#pragma mark ¥¥TYPEDEFS¥¥/******************************************\|**| typedefs\******************************************/#pragma mark ¥¥EXTERNAL GLOBALS¥¥/******************************************\|**| external globals\******************************************/extern heraGlobalType		*gHera;#pragma mark ¥¥PRIVATE GLOBALS¥¥/******************************************\|**| private globals\******************************************/#pragma mark ¥¥PRIVATE PROTOTYPES¥¥/******************************************\|**| private function prototypes\******************************************/static newResourceType *HRT_GetNewResource( heraScenarioFileType *heraFile,	OSType type);static void HRT_DeleteNewResource( newResourceType *t);static newResourceType *HRT_GetResource_ByID( heraScenarioFileType *heraFile,	OSType type, short id);static newResourceType *HRT_GetResource_ByOriginalID(	heraScenarioFileType *heraFile, OSType type,	short id);#pragma mark ¥¥PRIVATE FUNCTIONS¥¥/******************************************\|**| private functions\******************************************/static newResourceType *HRT_GetNewResource( heraScenarioFileType *heraFile,	OSType type){   	newResourceType	*result = (newResourceType *)NewPtr(						sizeof ( newResourceType)),					*t;			if ( result == nil) return nil;			t = heraFile->newResource;	if ( t == nil)	{		heraFile->newResource = result;		result->previous = nil;	} else	{		while ( t->next != nil) t = t->next;		t->next = result;		result->previous = t;	}	result->next = nil;	result->resource = nil;	result->title[0] = 0;	result->resID = -1;	result->originalResID = -1;	result->type = type;	result->ownerRefNum = heraFile->fileRefNum;	return result;}static void HRT_DeleteNewResource( heraScenarioFileType *heraFile,	newResourceType *t){	mAssert( t != nil);		if ( t->previous == nil)	{		heraFile->newResource = t->next;	} else	{		(t->previous)->next = t->next;	}		if ( t->next != nil)	{		(t->next)->previous = t->previous;	}		if ( t->resource != nil)	{		DisposeHandle( t->resource);	}		DisposePtr( (Ptr)t);	}static newResourceType *HRT_GetResource_ByID( heraScenarioFileType *heraFile,	OSType type, short id){	newResourceType	*result = heraFile->newResource;		if ( result == nil) return nil;		while (( result->next != nil) && ((( result->resID != id) ||		( result->type != type)) ||			( !mResOwner_IsOK( result->ownerRefNum, heraFile))))	{		result = result->next;	}	if (( result->resID == id) && ( result->type == type) &&		mResOwner_IsOK( result->ownerRefNum, heraFile))	{		return result;	}	return nil;}static newResourceType *HRT_GetResource_ByOriginalID(	heraScenarioFileType *heraFile,	OSType type,	short id){	newResourceType	*result = heraFile->newResource;		if ( result == nil) return nil;		while (( result->next != nil) && ((( result->originalResID != id) ||		( result->type != type) ||		(!mResOwner_IsOK( result->ownerRefNum, heraFile)))))	{			result = result->next;	}	if (( result->originalResID == id) && ( result->type == type) &&		mResOwner_IsOK( result->ownerRefNum, heraFile))	{		return result;	}	return nil;}#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/void HRT_AddNewResource( heraScenarioFileType *heraFile,	Handle newData, OSType type, short *id,	StringPtr title){	newResourceType		*newResource = nil;	short				originalResID = kHRT_Resource_New_ID;		// increase it until its legal	while (!HRT_IsIDLegal( heraFile, type, *id))	{		*id = *id + 1;	}		newResource = HRT_GetResource_ByOriginalID( heraFile, type, *id);	if ( newResource != nil)	{		if ( newResource->resID != kHRT_Resource_ToBeDeleted_ID)		{//			return;	// this should be impossible			newResource = HRT_GetNewResource( heraFile, type);		} else		{			originalResID = *id;			if ( newResource->resource != nil)				DisposeHandle( newResource->resource);		}	} else	{		newResource = HRT_GetNewResource( heraFile, type);	}	if ( newResource != nil)	{		newResource->originalResID = originalResID;		newResource->resID = *id;		if ( title == nil)			pstrcpy( newResource->title, "\p<untitled>");		else			pstrcpy( newResource->title, title);					newResource->resource = newData;		if ( newResource->resource != nil)			HandToHand( &newResource->resource);		else			newResource->resource = NewHandle( 0);				newResource->next = nil;		newResource->type = type;			}		// the list should be sorted after calling this, but not before	// 1st calling update list selection	return;AddNewResource_error:	if ( newResource != nil) DisposePtr( (Ptr)newResource);}void HRT_DeleteResource( heraScenarioFileType *heraFile, OSType type, short id){	newResourceType		*newResource = nil;	Handle				originalResource;		// find if any newresource already "belongs" to it	newResource = heraFile->newResource;		if ( newResource != nil)	{							while			(				(					newResource->next != nil				)				&&				(					(						newResource->type != type					)					||					(						!						(							(								newResource->resID == id							)//						||//							(//								(//									newResource->resID == kHRT_Resource_ToBeDeleted_ID//								)//							&&//								(//									newResource->originalResID == id//								)//							)						)					)				)			)		{			newResource = newResource->next;		}				// if we found one and it's already marked for deletion, exit		// (shouldn't be possible)		if ((newResource->resID == kHRT_Resource_ToBeDeleted_ID) && ( newResource->originalResID == id))			return;				// if we didn't find one, nil newResource		if ( newResource->resID != id) newResource = nil;	}		// if we didn't find one, then it's a resource that exists; make newResource	// to mark for deletion	if ( newResource == nil)	{		originalResource = GetResource( type, id);		if ( originalResource != nil)		{			ReleaseResource( originalResource);			newResource = HRT_GetNewResource( heraFile, type);			if ( newResource != nil)			{				newResource->resource = nil;				newResource->resID = kHRT_Resource_ToBeDeleted_ID;				newResource->originalResID = id;				newResource->next = nil;				newResource->title[0] = 0;				newResource->type = type;			} else return;	// error					}	}		// if we have one	if ( newResource != nil)	{		// and we haven't just marked it for deletion		if ( newResource->resID != kHRT_Resource_ToBeDeleted_ID)		{			newResource->resID = kHRT_Resource_ToBeDeleted_ID;				// if there's no original resid, then this is a resource resource			// that isn't in res file -- we made it, so no need to mark it			// for deletion; just remove it			if ( newResource->originalResID == kHRT_Resource_New_ID)			{				HRT_DeleteNewResource( heraFile, newResource);			}		}	}}/*	KeepChangedResource		if the resource has changed, this will append it to the list of changed resource*/unsigned long HRT_KeepChangedResource( heraScenarioFileType *heraFile,	Handle newResource, OSType type,	short originalResID, short newID, StringPtr newTitle){	Str255				originalTitle;	ResType				theType = type;	Handle				originalResource;	Boolean				different = false, titleDifferent = false,						idDifferent = false;	newResourceType		*originalKeepResource = nil;	unsigned long		result = 0;	long				error;		originalTitle[0] = 0;		originalKeepResource = HRT_GetResource_ByID( heraFile, type, originalResID);	if ( originalKeepResource != nil)	{		originalResource = originalKeepResource->resource;		pstrcpy( originalTitle, originalKeepResource->title);	} else if ( originalResID > 0)	{		originalResource = GetResource( type, originalResID);			if ( originalResource != nil)			GetResInfo( originalResource, &originalResID, &theType,				originalTitle);		else result = kHRT_ResourceDifferenceFlag_AllFlags;	} else	{		return 0;	}		if ( newResource != nil)	{		// if no original resource, then keep it		if ( originalResource == nil) different = true;		// else if the same length, then check contents		else if ( GetHandleSize( newResource) ==			GetHandleSize( originalResource))		{			char	*newc = *newResource,					*originalc = *originalResource;			long	length = GetHandleSize( newResource);						// if any difference, keep it			do			{				if ( *newc != *originalc) different = true;				newc++;				originalc++;				length--;			} while (( length > 0) && ( !different));		// else if not the same length, keep it		} else different = true;				if ( different) result |= kHRT_ResourceDifferenceFlag_Data;				// if no difference found yet, check the title		if (pstrcmp( originalTitle, newTitle) != 0)		{								 different = true;			 titleDifferent = true;			 result |= kHRT_ResourceDifferenceFlag_Title;		}		if ( newID != originalResID)		{			different = true;			idDifferent = true;			result |= kHRT_ResourceDifferenceFlag_ID;		}				// add to keep list if different		if ( different)		{			newResourceType		*keepResource;						if ( originalKeepResource == nil)			{				keepResource = HRT_GetNewResource( heraFile, type);				keepResource->originalResID = originalResID;//d->currentOriginalResID;			} else				keepResource = originalKeepResource;						if ( keepResource != nil)			{				keepResource->resID = newID;				if ( originalKeepResource == nil)					keepResource->resource = NewHandle( GetHandleSize(						newResource));				else				{					// not sure why this can be nil, but it can and					// I want to "ship"										if ( keepResource->resource == nil)					{						keepResource->resource = NewHandle( GetHandleSize(						newResource));						error = MemError();						if ( error != noErr)						{							BP_AnErrorOfTypeN_Literal("Memory Error",								"CouldnÕt properly preserve modified resource "								"(MemError() returned", error, " after "								"SetHandleSize()).");						}					} else					{						SetHandleSize( keepResource->resource, GetHandleSize(							newResource));						error = MemError();						if ( error != noErr)						{							BP_AnErrorOfTypeN_Literal("Memory Error",								"CouldnÕt properly preserve modified resource "								"(MemError() returned", error, " after "								"SetHandleSize()).");						}					}				}				if ( keepResource->resource != nil)				{					HLock( keepResource->resource);					BlockMove( *newResource, *keepResource->resource,						GetHandleSize( newResource));					HUnlock( keepResource->resource);				}				pstrcpy( keepResource->title, newTitle);				keepResource->ownerRefNum = heraFile->fileRefNum;			}					}	}	if (( originalKeepResource == nil) && ( originalResource != nil))		ReleaseResource( originalResource);		return result;}Boolean HRT_IsIDLegal( heraScenarioFileType *heraFile, OSType type, short theID){	newResourceType		*keepResource = nil;	Handle				resourceResource;	keepResource = HRT_GetResource_ByID( heraFile, type, theID);		// if already in use in changed resource list, is illegal, exit	if ( keepResource != nil) return false;		// if resource does not exist, is legal, exit	resourceResource = GetResource( type, theID);		if ( resourceResource == nil) return true;		// if resource exists & no changed resource list, is illegal, exit	keepResource = heraFile->newResource;	if ( keepResource == nil) return false;		// if resource exists & is "aliased" in changed resource list, is legal, exit	while (( keepResource->next != nil) &&				( keepResource->originalResID != theID))		keepResource = keepResource->next;		if ( keepResource->originalResID == theID) return true;		// otherwise is illegal	return false;}Handle HRT_Resource_GetHandle( heraScenarioFileType *heraFile,	OSType type, short theID, short *originalID,	StringPtr title){	return HRT_Resource_GetHandle_WithOwnerFile( heraFile, type, theID,			originalID, nil, title);}Handle HRT_Resource_GetEZ( heraScenarioFileType *heraFile, OSType type,	short id){	return HRT_Resource_GetHandle_WithOwnerFile( heraFile, type, id,		nil, nil, nil);}Handle HRT_Resource_GetHandle_WithOwnerFile( heraScenarioFileType *heraFile,	OSType type, short theID, short *originalID, short *returnHomeResFile,	StringPtr title){	Handle			result;	newResourceType	*newResource = HRT_GetResource_ByID( heraFile, type, theID);	short			newID, homeResFile;	Boolean			markedAsChanged = false;		if ( originalID != nil) *originalID = kHRT_Resource_New_ID;	if ( title != nil) title[0] = 0;	if ( newResource != nil)	{		if ( newResource->resource != nil)		{			result = newResource->resource;			if ( originalID != nil) *originalID = newResource->originalResID;			if ( title != nil) pstrcpy( title, newResource->title);			HandToHand( &result);			if ( MemError() != noErr) return nil;			if ( returnHomeResFile != nil)				*returnHomeResFile = newResource->ownerRefNum;			return result;		}	}	newID = theID;		if (HRT_Resource_GetChanges( heraFile, type, &newID, title))	{/*		short	oldResRefNum = CurResFile();				// if it's been marked as deleted or moved (new ID)		// then we should look in factory files 1st		UseResFile( gHera->default_soundFile_refNum);		UseResFile( gHera->default_interfaceFile_refNum);		UseResFile( gHera->default_spriteFile_refNum);		UseResFile( gHera->default_scenarioFile_refNum);				markedAsChanged = true;		result = GetResource( type, theID);				UseResFile( oldResRefNum);*/		return nil;	} else	{		result = GetResource( type, theID);	}	if ( result == nil) return result;		homeResFile = HomeResFile( result);	if ( returnHomeResFile != nil) *returnHomeResFile = homeResFile;	if (!mResOwner_IsOK( homeResFile, heraFile))	{		short oldResRefNum = CurResFile();				ReleaseResource( result);				// the resource doesn't belong to us, or to any of our built-ins		UseResFile( gHera->default_spriteFile_refNum); // the last														// factory file opened		result = GetResource( type, theID);		homeResFile = HomeResFile( result);				UseResFile( oldResRefNum);				if ( returnHomeResFile != nil) *returnHomeResFile = homeResFile;				if (!mResOwner_IsOK( homeResFile, heraFile))		{			ReleaseResource( result);					return nil;		} else			return result;	}		if (markedAsChanged)	{		if ( !mResOwner_IsFactory( homeResFile))		{			ReleaseResource( result);			return nil;		}	}	if ( originalID != nil) *originalID = theID;	if ( title != nil)	{		ResType	theType;		short	id;		GetResInfo( result, &id, &theType, title);	}	DetachResource( result);	return result;}Boolean HRT_Resource_GetChanges( heraScenarioFileType *heraFile, 	OSType type, short *theID, StringPtr title){	newResourceType *result = HRT_GetResource_ByOriginalID( heraFile,		type, *theID);		if ( result == nil) return false;	*theID = result->resID;	if ( title != nil) pstrcpy( title, result->title);	return true;}newResourceType *HRT_Resource_GetNextNew( heraScenarioFileType *heraFile,	OSType type, newResourceType *newResource, short *resID, StringPtr title){		if ( newResource == nil) newResource = heraFile->newResource;	else newResource = newResource->next;		while ( newResource != nil)	{		if (( newResource->type == type) &&			( newResource->originalResID == kHRT_Resource_New_ID) &&			( mResOwner_IsOK( newResource->ownerRefNum, heraFile)))		{			if ( title != nil) pstrcpy( title, newResource->title);			if ( resID != nil) *resID = newResource->resID;			return newResource;		}		newResource = newResource->next;	}	if ( title != nil) title[0] = 0;	if ( resID != nil) *resID = -1;	return nil;}OSErr HRT_WriteAllToDisk( heraScenarioFileType *heraFile){	newResourceType	*t = heraFile->newResource, *deleteNewResource = nil;	short			oldResRefNum = CurResFile(), homeResFile, err;	Handle			resource;		mAssert( heraFile->fileRefNum > 0);		UseResFile( heraFile->fileRefNum);	while (t != nil)	{		if ( t->originalResID != t->resID)		{			resource = GetResource( t->type, t->originalResID);			if ( resource != nil)			{				homeResFile = HomeResFile( resource);				if ( homeResFile == heraFile->fileRefNum)					RemoveResource( resource);			}		}		t = t->next;				}		UpdateResFile( heraFile->fileRefNum);		// go through and change all resources that have new titles or data			t = heraFile->newResource;	while (t != nil)	{		if (( t->originalResID == t->resID) && ( t->resource != nil))		{			resource = GetResource( t->type, t->originalResID);			homeResFile = HomeResFile( resource);			SetHandleSize( resource, GetHandleSize( t->resource));			err = MemError();			if ( err != noErr)			{				BP_AnErrorOfTypeN_Literal("Resource Error", "CouldnÕt resize an"					" existing resource because an error of type ", err,					" occurred.");			} else			{				BlockMove( *t->resource, *resource, GetHandleSize( t->resource));				SetResInfo( resource, t->resID, t->title);				if ( homeResFile == heraFile->fileRefNum)					ChangedResource( resource);				else					AddResource( t->resource,  t->type, t->resID, t->title);			}		} else if ( t->resID != kHRT_Resource_ToBeDeleted_ID)		{			if ( t->resource != nil)				AddResource( t->resource,  t->type, t->resID, t->title);		}		deleteNewResource = t;		t = t->next;				DisposePtr( (Ptr)deleteNewResource);			}	UpdateResFile( heraFile->fileRefNum);	err = ResError();	if ( err != noErr)	{		BP_AnErrorOfTypeN_Literal("Resource Error", "CouldnÕt save the changes"			" because an error of type ", err,			" occurred.");	}	heraFile->newResource = nil;		UseResFile( oldResRefNum);		return err;}void HRT_Debug_Printout( heraScenarioFileType *heraFile){	newResourceType	*t = heraFile->newResource;	unsigned char	typeString[5];	long			*typeL;		while ( t != nil)	{		BPMOWriteLong( t->originalResID);		BPMOWritePString("\p\t");		BPMOWriteLong( t->resID);		BPMOWritePString("\p\t");		typeString[0] = 4;		typeL = (long *)&(typeString[1]);		*typeL = t->type;		BPMOWritePString( typeString);			if ( t->resource != nil) BPMOWritePString("\p\t<res>\t");		else BPMOWritePString("\p\t-\t");		BPMOWritePString( t->title);		t = t->next;		BPMOWritePString("\p\r");	}}