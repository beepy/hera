	//	//	LEGAL NOTICE	//	============	//	// 	You may incorporate this sample code into your applications	// 	without restriction. This sample code has been provided "AS	// 	IS" and the responsibility for its operation is 100% yours.	// 	You are not permitted to redistribute the source as "Apple	// 	sample code" after having made changes. If you're going to	// 	re-distribute the source, we require that you make it clear	// 	in the source that the code was descended from Apple sample	// 	code, but that you've made changes.	//#define OLDROUTINELOCATIONS		0#define OLDROUTINENAMES			0#define SystemSevenOrLater		1#ifndef __ALIASES__#	include <Aliases.h>#endif#include "Technote.h"#include <Errors.h>static pascal Size MinimumBytesForFSSpec (const FSSpec *fss){	//	//	Some senders don't bother sending the unused bytes of the	//	file name. This function helps make sure the FSSpec is	//	minimally sane by computing the minimum number of bytes it	//	would take to store it.	//	//	THIS FUNCTION CANNOT MOVE MEMORY.	//	return sizeof (*fss) - sizeof (fss->name) + *(fss->name) + 1;}static pascal OSErr FSpGetDirInfo (const FSSpec *spec, CInfoPBPtr *cipbpp){	OSErr err = noErr;	CInfoPBPtr pbp = (CInfoPBPtr) NewPtrClear (sizeof (*pbp));	*cipbpp = nil;	if (!(err = MemError ( )))	{		pbp->dirInfo.ioVRefNum = spec->vRefNum;		pbp->dirInfo.ioDrDirID = spec->parID;		pbp->dirInfo.ioNamePtr = (StringPtr) spec->name;		err = PBGetCatInfoSync (pbp);		if (!err && !(pbp->hFileInfo.ioFlAttrib & ioDirMask))			err = dirNFErr;		if (err)			DisposePtr ((Ptr) pbp);		else			*cipbpp = pbp;	}	return err;}pascal OSErr TNGetDirID (const FSSpec *spec, long *dirID){	OSErr err = noErr;	CInfoPBPtr cipbp;	if (!(err = FSpGetDirInfo (spec,&cipbp)))	{		*dirID = cipbp->dirInfo.ioDrDirID;		DisposePtr ((Ptr) cipbp);		if (!err) err = MemError ( );	}	return err;}pascal OSErr GetDropDirectory (DragReference dragRef, FSSpecPtr fssOut){	OSErr err = noErr;	AEDesc dropLocAlias = { typeNull, nil };	if (!(err = GetDropLocation (dragRef,&dropLocAlias)))	{		if (dropLocAlias.descriptorType != typeAlias)			err = paramErr;		else		{			AEDesc dropLocFSS = { typeNull, nil };			if (!(err = AECoerceDesc (&dropLocAlias,typeFSS,&dropLocFSS)))			{							// assume MinimumBytesForFSSpec does not move memory#ifndef TARGET_API_MAC_CARBON								FSSpecPtr fss = (FSSpecPtr) *(dropLocFSS.dataHandle);				BlockMoveData (fss,fssOut,MinimumBytesForFSSpec(fss));#else				AEGetDescData( &dropLocFSS, (void *)fssOut, sizeof( FSSpec));			#endif TARGET_API_MAC_CARBON				err = AEDisposeDesc (&dropLocFSS);			}		}		if (dropLocAlias.dataHandle)		{			OSErr err2 = AEDisposeDesc (&dropLocAlias);			if (!err) err = err2;		}	}	return err;}static pascal OSErr FSpGetDInfo (const FSSpec *spec, DInfo *fndrInfo){	OSErr err = noErr;	CInfoPBPtr cipbp;	if (!(err = FSpGetDirInfo (spec,&cipbp)))	{		*fndrInfo = cipbp->dirInfo.ioDrUsrWds;		DisposePtr ((Ptr) cipbp);		if (!err) err = MemError ( );	}	return err;}static pascal OSErr FSpSetDInfo (const FSSpec *spec, const DInfo *fndrInfo){	OSErr err = noErr;	CInfoPBPtr cipbp;	if (!(err = FSpGetDirInfo (spec,&cipbp)))	{		cipbp->dirInfo.ioDrUsrWds	= *fndrInfo;		cipbp->dirInfo.ioDrDirID	= spec->parID;		err = PBSetCatInfoSync (cipbp);		DisposePtr ((Ptr) cipbp);		if (!err) err = MemError ( );	}	return err;}static pascal CreatePromisedFile	(const PromiseHFSFlavor *phfs, const FSSpec *fss, ScriptCode scriptTag){	OSErr err = noErr;	if (!(err = FSpCreate (fss,phfs->fileCreator,phfs->fileType,scriptTag)))	{		if (phfs->fdFlags)		{			FInfo finderInfo;			if (!(err = FSpGetFInfo (fss,&finderInfo)))			{				finderInfo.fdFlags = phfs->fdFlags;				err = FSpSetFInfo (fss,&finderInfo);			}		}	}	return err;}static pascal CreatePromisedFolder	(const PromiseHFSFlavor *phfs, const FSSpec *fss, ScriptCode scriptTag){	OSErr err = noErr;	long newDirID; // scratch	if (!(err = FSpDirCreate (fss,scriptTag,&newDirID)))	{		if (phfs->fdFlags)		{			DInfo finderInfo;			if (!(err = FSpGetDInfo (fss,&finderInfo)))			{				finderInfo.frFlags = phfs->fdFlags;				err = FSpSetDInfo (fss,&finderInfo);			}		}	}	return err;}pascal OSErr CreatePromisedFileOrFolder	(const PromiseHFSFlavor *phfs, const FSSpec *fss, ScriptCode scriptTag){	OSErr err = noErr;	if (phfs->promisedFlavor == kPromisedFlavorFindFile)		err = paramErr;	else if (phfs->fileType == 'fold' || phfs->fileType == 'disk')		err = CreatePromisedFolder (phfs,fss,scriptTag);	else		err = CreatePromisedFile (phfs,fss,scriptTag);	return err;}pascal OSErr SetPromisedHFSFlavorData	(DragReference dragRef, ItemReference itemRef,		const PromiseHFSFlavor *phfs, const FSSpec *fss){	return SetDragItemFlavorData		(dragRef,itemRef,phfs->promisedFlavor,fss,sizeof(*fss),0);}pascal OSErr ShouldCopyToDropLoc	(DragReference dragRef, FlavorType promisedFlavor, Boolean *shouldCopy){	OSErr err = noErr;	AEDesc dropLoc = { typeNull, nil };	*shouldCopy = false;	if (!(err = GetDropLocation (dragRef,&dropLoc)))	{		if (dropLoc.descriptorType == typeAlias)		{			// no hint or receiver missed it			*shouldCopy = true;		}		else if (dropLoc.descriptorType != typeNull)		{			// unknown drop location descriptor type			err = paramErr;		}		else if (promisedFlavor != kPromisedFlavorFindFile)		{			// null descriptor but no hint intended			err = dirNFErr;		}		if (dropLoc.dataHandle)		{			OSErr err2 = AEDisposeDesc (&dropLoc);			if (!err) err = err2;		}	}	return err;}pascal OSErr AddDragItemFlavorTypePromiseHFS	(DragReference dragRef, ItemReference itemRef,		OSType fileType, OSType fileCreator, UInt16 fdFlags, FlavorType promisedFlavor){	OSErr err = noErr;	PromiseHFSFlavor phfs;	phfs.fileType			= fileType;	phfs.fileCreator		= fileCreator;	phfs.fdFlags			= fdFlags;	phfs.promisedFlavor		= promisedFlavor;	if (!(err = AddDragItemFlavor		(dragRef,itemRef,flavorTypePromiseHFS,&phfs,sizeof(phfs),flavorNotSaved)))	{		err = AddDragItemFlavor (dragRef,itemRef,promisedFlavor,nil,0,flavorNotSaved);	}	return err;}pascal OSErr MakeHFSFlavor    (short vRefNum, long dirID, ConstStr255Param path, HFSFlavor register *hfsFlavorP){	OSErr err = noErr;	//	//	canonize the input parameters	//	if (!(err = FSMakeFSSpec (vRefNum,dirID,path,&(hfsFlavorP->fileSpec))))	{		//		//	get the Finder flags		//		register CInfoPBPtr cipbp = (CInfoPBPtr) NewPtrClear (sizeof (*cipbp));		if (!(err = MemError ( )))		{			cipbp->hFileInfo.ioVRefNum	= hfsFlavorP->fileSpec.vRefNum;			cipbp->hFileInfo.ioDirID	= hfsFlavorP->fileSpec.parID;			cipbp->hFileInfo.ioNamePtr	= hfsFlavorP->fileSpec.name;			if (!(err = PBGetCatInfoSync (cipbp)))			{				hfsFlavorP->fdFlags = cipbp->hFileInfo.ioFlFndrInfo.fdFlags;				//				//	now that we have the Finder flags, use them to				//	determine how to fill in the type and creator fields				//				if (hfsFlavorP->fileSpec.parID == fsRtParID)		// is it a volume?				{					hfsFlavorP->fileCreator		= 'MACS';					hfsFlavorP->fileType		= 'disk';				}				else if (cipbp->hFileInfo.ioFlAttrib & ioDirMask)	// is it a dir?				{					hfsFlavorP->fileCreator		= 'MACS';					hfsFlavorP->fileType		= 'fold';				}				else												// it must be a file				{					hfsFlavorP->fileCreator		= cipbp->hFileInfo.ioFlFndrInfo.fdCreator;					hfsFlavorP->fileType		= cipbp->hFileInfo.ioFlFndrInfo.fdType;				}			}			DisposePtr ((Ptr) cipbp);			if (!err) err = MemError ( );		}	}	return err;}pascal OSErr GetHFSFlavorFromDragReference	(DragReference dragRef, ItemReference itemRef, HFSFlavor *hfsFlavor){	OSErr err = noErr;	//	//	Attempt to get the data. We'll return errors to the caller,	//	who will be expected to interpret badDragFlavorErr as meaning	//	there was no flavorTypeHFS data to get.	//	Size size = sizeof (*hfsFlavor);	err = GetFlavorData (dragRef,itemRef,flavorTypeHFS,hfsFlavor,&size,0);	if (!err)	{		Size minSize = sizeof (*hfsFlavor) - sizeof (hfsFlavor->fileSpec);		minSize += MinimumBytesForFSSpec (&(hfsFlavor->fileSpec));		if (size < minSize)			err = cantGetFlavorErr;	}	return err;}static pascal OSErr SetFlavorTypePromiseHFSDropLocation	(DragReference dragRef, const FSSpec *folder){	OSErr err = noErr;	AliasHandle aliasH;	if (!(err = NewAliasMinimal (folder,&aliasH)))	{		HLockHi ((Handle) aliasH);		if (!(err = MemError ( )))		{			Size size = GetHandleSize ((Handle) aliasH);			if (!(err = MemError ( )))			{				AEDesc dropLoc;				if (!(err = AECreateDesc (typeAlias,*aliasH,size,&dropLoc)))				{					OSErr err2;					err = SetDropLocation (dragRef,&dropLoc);					err2 = AEDisposeDesc (&dropLoc);					if (!err) err = err2;				}			}		}		DisposeHandle ((Handle) aliasH);		if (!err) err = MemError ( );	}	return err;}static pascal OSErr GetHFSFlavorFromPromise    (DragReference dragRef, ItemReference itemRef,        HFSFlavor *hfs, Boolean isSupposedlyFromFindFile){    OSErr             err = noErr;    PromiseHFSFlavor  phfs;    Size              size = sizeof (phfs);    err = GetFlavorData        (dragRef,itemRef,flavorTypePromiseHFS,&phfs,&size,0);    if (!err)    {        if (size != sizeof (phfs))            err = cantGetFlavorErr;        else        {            Boolean isFromFindFile =                phfs.promisedFlavor == kPromisedFlavorFindFile;            if (isSupposedlyFromFindFile != isFromFindFile)                err = paramErr;            else            {                size = sizeof (hfs->fileSpec);                err = GetFlavorData                    (dragRef,itemRef,phfs.promisedFlavor,                        &(hfs->fileSpec),&size,0);                if (!err)                {                    Size minSize = MinimumBytesForFSSpec                        (&(hfs->fileSpec));                    if (size < minSize)                        err = cantGetFlavorErr;                    else                    {                        hfs->fileType     = phfs.fileType;                        hfs->fileCreator  = phfs.fileCreator;                        hfs->fdFlags      = phfs.fdFlags;                    }                }            }        }    }    return err;}pascal OSErr ReceivePromisedFile	(DragReference dragRef, ItemReference itemRef, HFSFlavor *hfsFlavor, const FSSpec *folder){	OSErr err = noErr;	if (folder)		err = SetFlavorTypePromiseHFSDropLocation (dragRef,folder);	if (!err)	{		Boolean isSupposedlyFromFindFile = (folder == nil);		err = GetHFSFlavorFromPromise (dragRef, itemRef, hfsFlavor, isSupposedlyFromFindFile);	}	return err;}pascal OSErr BogusFinderEventHandler (const AppleEvent *, AppleEvent *,  long){	return noErr; // just drop that bad boy on the floor}pascal OSErr InstallBogusFinderEventHandler (void){	OSErr err = noErr;	static AEEventHandlerUPP bogusFinderEventHandlerUPP;	if (!bogusFinderEventHandlerUPP)	{		bogusFinderEventHandlerUPP =			NewAEEventHandlerUPP (BogusFinderEventHandler);		if (!bogusFinderEventHandlerUPP)			err = nilHandleErr;		else		{			err = AEInstallEventHandler ('cwin','****',bogusFinderEventHandlerUPP,0,false);			if (err)			{#ifndef TARGET_API_MAC_CARBON				DisposeRoutineDescriptor (bogusFinderEventHandlerUPP);#else				DisposeAEEventHandlerUPP (bogusFinderEventHandlerUPP);#endif TARGET_API_MAC_CARBON				bogusFinderEventHandlerUPP = nil;			}		}	}	return err;}