/******************************************\|**| Scenario_Editor.c\******************************************//** Adapted from Michael Hecht's code.* This works around a bug in the PowerMacintosh ROM* click_loop_glue is a quick & dirty way of doing* inline 68K assembly from PowerPC code.* We need to do this because if we have the List Manager* call our native click loop directly,* it can fail because the List Manager doesn't actually* test the result in D0, it just checks the state of the Z-bit, * which Mixed Mode doesn't set for us.** Example:**Ê pascal Boolean ClickLoopProc(void);**Ê #ifdef powerc*Ê if (PPC_LClick(event->where, event->modifiers, list, ClickLoopProc)) { *Ê }*Ê #else*Ê (*list)->lClikLoop = ClickLoopProc;*Ê if (LClick(event->where, event->modifiers, list)) {*Ê }*Ê #endifBooleanPPC_LClick(Point where,short modifiers,ListHandle list,pascal Boolean (*click_loop)(void)){ListClickLoopUPP cl_upp;long result;static struct {Ê unsigned shortÊ cl_glue[6];Ê ListClickLoopUPP cl_upp;Ê // Storage for the UPP} click_loop_glue = {Ê {Ê 0x207A, 0x000A,Ê Ê // MOVEA.L click_loop_glue.cl_upp,A0Ê 0x4E90,Ê Ê Ê // JSRÊ (A0)Ê 0x4A00,Ê Ê Ê // TST.B D0Ê 0x4E75,Ê Ê Ê // RTSÊ 0x4E71Ê Ê Ê // NOPÊ -- pad to longwordÊ },Ê 0Ê Ê Ê Ê // cl_upp};Êcl_upp = NewListClickLoopProc(click_loop);click_loop_glue.cl_upp = cl_upp;cl_upp = (ListClickLoopUPP) &click_loop_glue;Ê(*list)->lClickLoop = cl_upp;Ê // Set up clikLoop routineÊresult = LClick(where, modifiers, list);Ê(*list)->lClickLoop = 0;Ê Ê // Remove clikLoop routineÊ//Ê * Put the real UPP back in the local so that we can dispose of itcl_upp = click_loop_glue.cl_upp;DisposeRoutineDescriptor((UniversalProcPtr) cl_upp);return (Boolean) result;}-- E-mail:Ê ÊÊ sears@netcom.comPhone:Ê Ê Ê 415.695.0650Address:Ê Ê 2440 16th Street #283Ê Ê Ê Ê Ê Ê San Francisco, CAÊ Ê Ê Ê Ê Ê 94103-4211This email message sent with 100% recycled bits*/#pragma mark ¥¥INCLUDES¥¥/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "BP_Error.h"#include "Assert.h"#include "BPMacOutput.h"#include "Window Dispatch.h"#include "Control Utilities.h"#include "Hewey.h"#include "Hewey_Main.h"#include "Hewey_Layout.h"#include "Hewey_Utilities.h"#include "str_bp.h"#include "Set Font By String.h"#include "strlist.h"#include "Hewey_Helpers.h"#include "PsuedoColumn_Utilities.h"#include "List_Utilities.h"#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/// ares#include "Scenario.h"// hera#include "Hera_Global.h"#include "Hera_Utilities.h"#include "Hera_Name_Maker.h"#include "Hera_Data.h"#include "Hera_ResourceTracker.h"#include "Button_Window.h"// editors#include "Scenario_Editor.h"#include "Condition_Editor.h"#include "Briefing_Editor.h"#include "Initial_Editor.h"#include "Starmap_Locator.h"#include "TEXTEditor.h"#include "STR_Editor.h"#include "Bit_Flipper.h"#pragma mark ¥¥DEFINITIONS¥¥/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kLarge_Tab_Width				80//112#define	kEditTextBigFieldWidth			((kLarge_Tab_Width * 2) - kControl_H_Space * 3)// 150#define	kEditTextHugeFieldWidth			((kLarge_Tab_Width * 2) + kEditTextFieldWidth)// 150#define	kEditTextFieldWidth				38#define	kEditTextSmallFieldWidth		16#define	kPopup_Field_Width				150#define	kControl_H_Space				4#define	kColNum							2#define	kRowNum							4#define	kMain_Cell_X					1#define	kMain_Cell_Y					0#define	kMain_ID_Offset					100#define	kSeparator_Cell_X				0#define	kSeparator_Cell_Y				2#define	kSeparator_ID					200#define	kButton_Cell_X					0#define	kButton_Cell_Y					3#define	kOK_Button_ID					1#define	kCancel_Button_ID				2#define	kList_ID						6#define	kList_Cell_X					0#define	kList_Cell_Y					0#define	kList_Button_Cell_X				0#define	kList_Button_Cell_Y				1#define	kList_Button_ID_Offset			300#define	kList_Remove_Button_ID			(kList_Button_ID_Offset + 1)#define	kList_Add_Button_ID				(kList_Button_ID_Offset + 2)#define	kMain_Master_ColNum				1#define	kMain_Master_RowNum				2#define	kMain_Main_Cell_X				0#define	kMain_Main_Cell_Y				0#define	kMain_Main_ID_Offset			1000#define	kMain_Main_playerNum			(kMain_Main_ID_Offset + 2)#define	kMain_Main_levelNameStrNum		(kMain_Main_ID_Offset + 4)#define	kMain_Player_Cell_X				0#define	kMain_Player_Cell_Y				1#define	kMain_Player_ColNum				1#define	kMain_Player_RowNum				1#define	kMain_Player_ID_Offset			2000#define	kMain_Player_Which_Player		kMain_Player_ID_Offset#define	kMain_Player_playerType			(kMain_Player_ID_Offset + 2)#define	kMain_Player_playerRace			(kMain_Player_ID_Offset + 4)#define	kMain_Player_earningPower		(kMain_Player_ID_Offset + 6)#define	kMain_Player_nameResID			(kMain_Player_ID_Offset + 8)#define	kMain_Player_nameStrNum			(kMain_Player_ID_Offset + 10)#define	kMain_Player_editNoShipsButton	(kMain_Player_ID_Offset + 12)#define	kMain_Player_raceMenu			(kMain_Player_ID_Offset + 14)#define	kMain_Player_nameField			(kMain_Player_ID_Offset + 16)#define	kMain_Player_nameChooseButton	(kMain_Player_ID_Offset + 18)#define	kMain_Player_netRaceFlags		(kMain_Player_ID_Offset + 20)#define	kMain_Player_netRaceFlags_setButton	(kMain_Player_ID_Offset + 22)#define	kData_ID_Offset					3000#define	kData_initialEdit				(kData_ID_Offset + 6)#define	kData_conditionEdit				(kData_ID_Offset + 14)#define	kData_briefPointEdit			(kData_ID_Offset + 22)#define	kData_movieNameStrNum			(kData_ID_Offset + 26)#define	kData_parKillRatio				(kData_ID_Offset + 28)#define	kData_parKills					(kData_ID_Offset + 30)#define	kData_parLosses					(kData_ID_Offset + 32)#define	kData_parTime					(kData_ID_Offset + 34)#define	kData_startTime					(kData_ID_Offset + 36)#define	kData_netRaceFlags				(kData_ID_Offset + 38)#define	kData_netRaceFlags_setButton	(kData_ID_Offset + 40)#define	kData_starMap_setButton			(kData_ID_Offset + 42)#define	kData_prologueID				(kData_ID_Offset + 44)#define	kData_epilogueID				(kData_ID_Offset + 46)#define	kData_songID					(kData_ID_Offset + 48)#define	kData_scoreStringResID			(kData_ID_Offset + 50)// new data fields#define	kData_chapterName				(kData_ID_Offset + 52)#define	kData_movieNameField			(kData_ID_Offset + 54)#define	kData_movieChooseButton			(kData_ID_Offset + 56)#define	kData_fixedAngleCheckBox		(kData_ID_Offset + 58)#define	kData_fixedAngleField			(kData_ID_Offset + 60)#define	kData_trainingOnlyCheckBox		(kData_ID_Offset + 62)#define	kData_prologueCheckBox			(kData_ID_Offset + 64)#define	kData_prologueField				(kData_ID_Offset + 66)#define	kData_prologueChooseButton		(kData_ID_Offset + 68)#define	kData_epilogueCheckBox			(kData_ID_Offset + 70)#define	kData_epilogueField				(kData_ID_Offset + 72)#define	kData_epilogueChooseButton		(kData_ID_Offset + 74)#define	kData_statusStringsField		(kData_ID_Offset + 76)#define	kData_statusStringsChooseButton	(kData_ID_Offset + 78)#define	kData_movieNameCheckBox			(kData_ID_Offset + 80)#define	kSmallFontSize					gHera->smallFontSize#define	kSmallFontNum					gHera->smallFontNum#define	kLargeFontNum					gHera->bigFontNum;#define kLargeFontSize					gHera->bigFontSize;#define	kStrResID						8028#define	kNoShipsTextIDOffset			10000#define	kNoShipsTextPlayerNumOffset		50#pragma mark _macros_/* - macros*******************************************/#pragma mark ¥¥TYPEDEFS¥¥/******************************************\|**| typedefs\******************************************/typedef struct Scenario_EditorWindowType{	heraScenarioFileType			*heraFile;	huiMasterControlType			*master;	huiMasterControlType			*mainMaster;	long							windowID;	scenarioType					scenario;	Handle							scenarioData;	long							scenarioIndex;	long							scenarioNumber;	Boolean							anyChanges;	short							resRefNum;	long							whichPlayer;	long							lastAllocatedReferenceNum;	short							dragFrom;	short							dragTo;	Str255							scenarioName;	long							callBack_initialChange_index;	long							callBack_initialChange_number;	long							callBack_initialChange_action;	Handle							raceStrList;	long							netRaceFlags_windowID;	Boolean							chooseOnly;	long							callerID;	Scenario_Editor_procPtr			callBack;	Str255							titlePrefix;} Scenario_EditorWindowType;#pragma mark ¥¥EXTERNAL GLOBALS¥¥/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark ¥¥PRIVATE GLOBALS¥¥/******************************************\|**| private globals\******************************************/#pragma mark ¥¥PRIVATE PROTOTYPES¥¥/******************************************\|**| private function prototypes\******************************************/static Boolean HandleEvent( EventRecord *, CWindowPtr, long, long);static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID);static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID);static void OK_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID);static void Cancel_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID);static void OK_Button( Scenario_EditorWindowType *d, CWindowPtr whichWindow,						Boolean closeWindow);static void Cancel_Button( Scenario_EditorWindowType *d);static void Revert_Button( Scenario_EditorWindowType *d);static void List_Click( CWindowPtr whichWindow, Point where,	Scenario_EditorWindowType *d, ControlHandle aControl);static void ConfirmListDragCallBack( long whichButton, long windowID);static void DeleteScenario( long windowID, CWindowPtr window);static void AddScenario( long windowID, CWindowPtr window);static void Window_SetScenario_FromControls( Scenario_EditorWindowType *d,	CWindowPtr window, long index);static void Window_SetControls_FromScenarioIndex( Scenario_EditorWindowType *d,	CWindowPtr window, long index);	static void Set_PlayerControls_FromTempScenario( Scenario_EditorWindowType *d,	CWindowPtr window);static void Set_TempScenario_FromPlayerControls( Scenario_EditorWindowType *d,	CWindowPtr window);static void SetScenarioField( Scenario_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioType *s, long id, Boolean draw);static void GetScenarioField( Scenario_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioType *s, long id);static void SetNetRaceFlags( long windowID, unsigned long bits);static void AddBitPopUp( huiPlainControlParamType *textParam,	huiPlainControlParamType *buttonParam, long id, short resID, short index,	Boolean newLine, short tabStart, Handle stringList);static void GetAllData( Scenario_EditorWindowType *d);static void ChapterString_NormalizeInPlace( StringPtr s);static StringPtr Scenario_Editor_ChildWindow_NameMaker( Scenario_EditorWindowType *d,	StringPtr destString);static short CompareCellsByChapterIndex( Ptr cell_a, long length_a, Ptr cell_b,	long length_b);static pascal Boolean NullClickLoop( void);static void StatusStringCallBack( long windowID, long resID, long stringNum);static void MovieStringCallBack( long windowID, long resID, long stringNum);static void PlayerNameStringCallBack( long windowID, long resID, long stringNum);static void PrologueTextCallBack( long windowID, long resID);static void EpilogueTextCallBack( long windowID, long resID);static short NoShipsText_ResID_GetFromChapterPlayerNumber( long chapterNumber,	long playerNumber);	static void Initial_Editor_CallBack( long dispatchID, long initialFirst,	long initialNum, long initialSelection, heraDataChangesType *changesList);static void Initial_Changes_ObjectWalker_CallBack( Handle discreteObjectData,	Handle discreteActionData, unsigned long userData);static void Condition_Editor_CallBack( long dispatchID, long conditionFirst,	long conditionNum, heraDataChangesType *changesList);static void Briefing_Editor_CallBack( long dispatchID, long briefFirst,	long briefNum);static void NetRaceFlag_CallBack( long windowID, unsigned long bits);static void Starmap_Locator_Callback( long windowID, long x, long y);static void Enable_Editing( Scenario_EditorWindowType *d, Boolean enable);#pragma mark ¥¥PRIVATE FUNCTIONS¥¥/******************************************\|**| private functions\******************************************/static Boolean HandleEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID, long command){	switch( command)	{		case kWD_Close_ForQuit_Command:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				Cancel_Button_From_WindowID( whichWindow, dispatchID);//					OK_Button_From_WindowID( whichWindow, dispatchID);							}			return false;			break;				case kWDProcessEventCommand:			return( ProcessEvent( theEvent, whichWindow, dispatchID));			break;				case kWDSaveWindowCommand:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{//				if ( Button_Window_Modal( "\pSave changes to these actions?",//										"\pBefore saving, the Action Editor "//										"must be closed. Click Cancel to "//										"abort the save.", nil, nil))				{					OK_Button_From_WindowID( whichWindow, dispatchID);								}// else				{			//		gHera->currentSave = nil;				}			}			return false;			break;		case kWDProcessMenuChoiceCommand:			return( ProcessMenuChoiceCommand( (unsigned long)theEvent,				whichWindow, dispatchID));			break;			}	return false;}static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Handle							data =										GetDispatchWindowDataHandle( dispatchID),									discreteDataSource = nil;	SignedByte						dataState;	Scenario_EditorWindowType		*d;	Boolean							result = false;	GrafPtr							oldPort;	short							menuID = ((menuData & 0xffff0000) >> 16),									menuItem = (menuData & 0x0000ffff);	huiPlainControlType				*hui = nil;	OSErr							err = noErr;	ControlHandle					aControl;		if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (Scenario_EditorWindowType *)*data;	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);	result = Generic_ProcessMenuChoiceCommand( menuData, whichWindow,												dispatchID);	if ( result)	{		goto ProcessMenuChoiceCommand_Return;	}	err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);	if (( err == noErr) && ( aControl != nil))	{		hui = (huiPlainControlType *)CU_GetControlReference( aControl);	}			switch( menuID)	{		case kEditMenuID:			switch( menuItem)			{				case kEdit_Undo_Item:					result = true;					break;									case kEdit_Cut_Item:					result = true;					break;									case kEdit_Copy_Item:					if ( hui != nil)					{						switch ( hui->generic.id)						{							case kList_ID:								Window_SetScenario_FromControls( d, whichWindow,										d->scenarioIndex);								gHera->clipboard.type = 0;								if ( gHera->clipboard.sourceData != nil)									DisposeHandle( gHera->clipboard.sourceData);								gHera->clipboard.sourceData =									d->scenarioData;								HandToHand( &gHera->clipboard.sourceData);								err = MemError();								if ( err != noErr)								{									BP_UserError_Literal("Scenario Editor",											"CouldnÕt allocate space for the "											"scenario on the clipboard.");									gHera->clipboard.sourceData = nil;								} else								{									gHera->clipboard.type = 'snro';									gHera->clipboard.dataID = d->scenarioIndex;									gHera->clipboard.dataRange = 0;									gHera->clipboard.sourceFile = d->heraFile;								}								break;														default:								if ( gHera->clipboard.sourceData != nil)									DisposeHandle( gHera->clipboard.sourceData);								gHera->clipboard.type = 0;								break;						}					}					result = true;					break;									case kEdit_Paste_Item:					if ( hui != nil)					{						switch ( hui->generic.id)						{							case kList_ID:								if (( gHera->clipboard.type ==											'snro')									&& ( gHera->clipboard.sourceData != nil))								{//									if ( gHera->clipboard.sourceFile->fileRefNum !=//										d->heraFile->fileRefNum)									{																				// if the source is from a 										// different file, we have to										// walk the object																				AddScenario( dispatchID, whichWindow);																				HD_DiscreteData_SetAllFlags(											d->heraFile, 0, 0, 0xffffffff);										HD_DiscreteData_ClearAllRealIndexes(											d->heraFile, 0);										if ( gHera->clipboard.sourceFile != nil)										{											HD_DiscreteData_SetAllFlags(												gHera->clipboard.sourceFile, 0, 0, 0xffffffff);											HD_DiscreteData_ClearAllRealIndexes(												gHera->clipboard.sourceFile, 0);										}											HD_Scenario_Copy( gHera->clipboard.sourceFile,											gHera->clipboard.sourceData,											gHera->clipboard.dataID,											d->heraFile, d->scenarioData, d->scenarioIndex);																				HD_DiscreteData_SetAllFlags(											d->heraFile, 0, 0, 0xffffffff);										HD_DiscreteData_ClearAllRealIndexes(											d->heraFile, 0);									}									/* else									{										Insert_Object( whichWindow, d,											d->whichObject + 1,											gHera->clipboard.sourceData,											gHera->clipboard.sourceFile);									}									*/									Window_SetControls_FromScenarioIndex(										d, whichWindow, d->scenarioIndex);								}								break;														default:								gHera->clipboard.type = 0;								break;						}					}					result = true;					break;									case kEdit_Clear_Item:					result = true;					break;									case kEdit_Select_All_Item:					result = true;					break;									case kEdit_Add_Item:					result = true;					break;									case kEdit_Delete_Item:					result = true;					break;									case kEdit_Delete_All_Item:					result = true;					break;			}							break;			}	ProcessMenuChoiceCommand_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);}static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Boolean							result = false;	ControlHandle					aControl, oldControl;	short							whichPart, oldValue;	WindowPtr						scratchWindow;	Point							where;	char							whichChar;	GrafPtr							oldPort;	OSStatus						err;	Scenario_EditorWindowType		*d;	ListHandle						list;	Str255							tString;		if ( data == nil) return false;	if ( theEvent == nil) return false;		dataState = HGetState( data);	HLock( data);	d = (Scenario_EditorWindowType *)*data;		if ( theEvent == nil) goto ProcessEvent_Return;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);		switch( theEvent->what)	{		case nullEvent:			IdleControls( (WindowPtr)whichWindow);						result = true;			break;					case updateEvt:				BeginUpdate ((WindowPtr)whichWindow);/*			SetPort( (WindowPtr)whichWindow);			CalcVis( (WindowPtr)whichWindow);			UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);*/			HU_GenericUpdateEventHandler( whichWindow);			EndUpdate ((WindowPtr)whichWindow);			result = true;			break;		case activateEvt:		{			Boolean	isActive = ((theEvent->modifiers & activeFlag) != 0);						if ( isActive)			{				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_scenarioFile_refNum);			}		}			// result != true so dispatch window will handle activation			// of controls etc.			break;					case mouseDown:			whichPart = FindWindow (theEvent->where, &scratchWindow);			switch( whichPart)			{				case inGrow:/*					{						Rect	growRect;						long	newSize;//						growRect = qd.screenBits.bounds;						C2C_ScreenBits_GetBounds( &growRect);						growRect.top = growRect.left = 120;						newSize = GrowWindow((WindowPtr)whichWindow,							theEvent->where ,&growRect);						if (newSize != 0)						{							SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,								(((newSize) >> 16) & 0xFFFF), true );							EraseRect(&whichWindow->portRect);							InvalRect( &whichWindow->portRect);						}					}*/					HU_GenericGrowWindow( whichWindow, theEvent->where);					result = true;					break;								case inContent:					where = theEvent->where;					scratchWindow = WD_FrontWindow();					if ( whichWindow != (CWindowPtr)scratchWindow)					{						goto ProcessEvent_Return;					}					SetPortWindowPort( (WindowPtr)whichWindow);					GlobalToLocal( &where);					whichPart = FindControl( where, (WindowPtr)whichWindow,						&aControl);					if ( aControl == nil)						goto ProcessEvent_Return;					oldValue = GetControlValue( aControl);					err = GetKeyboardFocus( (WindowPtr)whichWindow, &oldControl);					if (( err == noErr) && ( oldControl != aControl))					{						SetKeyboardFocus( (WindowPtr)whichWindow, aControl, whichPart);					}					if ( whichPart != 0)					{						huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);//						whichPart = HandleControlClick ( aControl, where,//							theEvent->modifiers,//	nil//													(ControlActionUPP)-1//							);												if ( !ListBox_Appearance_1_0_1_Hack( aControl, where,									&whichPart))						{							whichPart = HUI_Control_Click_Handle( hui, where,								theEvent->modifiers);														}													if ( whichPart != kControlNoPart) switch( hui->generic.id)						{							case kOK_Button_ID:								result = true;								OK_Button( d, whichWindow, true);								data = nil;								goto ProcessEvent_Return;								break;														case kCancel_Button_ID:								Cancel_Button( d);								data = nil;								result = true;								goto ProcessEvent_Return;								break;															case kList_ID:														List_Click( whichWindow, where, d, aControl);								result = true;								break;														case kList_Remove_Button_ID:								if ( HU_Confirm_Delete("\pAre you sure you "									"want to delete this scenario?",										theEvent->modifiers))								{									HSetState( data, dataState);									DeleteScenario( dispatchID, whichWindow);									HLock( data);								}								result = true;								break;															case kList_Add_Button_ID:								HSetState( data, dataState);								AddScenario( dispatchID, whichWindow);								HLock( data);								result = true;								break;															case kMain_Player_Which_Player:								Set_TempScenario_FromPlayerControls( d,									whichWindow);								d->whichPlayer = GetControlValue( aControl) - 1;								Set_PlayerControls_FromTempScenario( d,									whichWindow);								result = true;								break;														case kData_statusStringsChooseButton:								STR_Editor_NewWindow( d->heraFile,									"\pChoose Status Strings",									d->resRefNum, d->scenario.scoreStringResID,									1, true, true,									true, dispatchID,									StatusStringCallBack);								result = true;								break;														case kMain_Player_nameChooseButton:								STR_Editor_NewWindow( d->heraFile,									"\pChoose Player Name",									d->resRefNum,									d->scenario.player[d->whichPlayer].nameResID,									d->scenario.player[d->whichPlayer].nameStrNum,									true, true, true, dispatchID,									PlayerNameStringCallBack);								result = true;								break;														case kMain_Player_netRaceFlags:							{								unsigned long bit;																if (( whichPart == kControlMenuPart) && (									!(d->chooseOnly)))								{									oldValue = GetBevelMenuValue( aControl) - 1;									bit = 0x01 << oldValue;									d->scenario.player[d->whichPlayer].netRaceFlags ^=										bit;									HU_Menu_SetCheckFromBits( aControl,										d->scenario.player[d->whichPlayer].netRaceFlags,										oldValue, oldValue);								}							}								result = true;								break;														case kMain_Player_netRaceFlags_setButton://								gHera->modalMode++;								BitFlipper_NewWindow( &d->netRaceFlags_windowID,									"\pNet Races",									d->raceStrList,									d->scenario.player[d->whichPlayer].netRaceFlags,									dispatchID,									NetRaceFlag_CallBack);								result = true;								break;															case kData_prologueCheckBox:								if ( !GetControlValue( aControl))								{									TEXTEditor_NewWindow( d->heraFile,										"\pChoose Prologue",										d->resRefNum, dispatchID,										d->scenario.prologueID, true, true,										true, PrologueTextCallBack);								} else								{									PrologueTextCallBack( dispatchID, -1);								}								result = true;								break;														case kData_prologueChooseButton:									TEXTEditor_NewWindow( d->heraFile,										"\pChoose Prologue",										d->resRefNum, dispatchID,										d->scenario.prologueID, true, true,										true, PrologueTextCallBack);								result = true;								break;														case kData_starMap_setButton:								Starmap_Locator_NewWindow( d->heraFile,									"\pStarmap Locator", d->scenario.starMapH,									d->scenario.starMapV, dispatchID,									Starmap_Locator_Callback);								result = true;								break;															case kData_movieNameCheckBox:								if ( !GetControlValue( aControl))								{									STR_Editor_NewWindow( d->heraFile,										"\pChoose Movie Pathname",										d->resRefNum, 4500,										d->scenario.movieNameStrNum, false, true,										true, dispatchID, MovieStringCallBack);								} else								{									MovieStringCallBack( dispatchID, 4500, -1);								}								result = true;								break;														case kData_movieChooseButton:									STR_Editor_NewWindow( d->heraFile,										"\pChoose Movie Pathname",										d->resRefNum, 4500,										d->scenario.movieNameStrNum, false, true,										true, dispatchID, MovieStringCallBack);								result = true;								break;															case kData_epilogueCheckBox:								if ( !GetControlValue( aControl))								{									TEXTEditor_NewWindow( d->heraFile,										"\pChoose Epilogue",										d->resRefNum, dispatchID,										d->scenario.epilogueID, true, true,										true, EpilogueTextCallBack);								} else								{									EpilogueTextCallBack( dispatchID, -1);								}								result = true;								break;														case kData_epilogueChooseButton:									TEXTEditor_NewWindow( d->heraFile,										"\pChoose Epilogue",										d->resRefNum, dispatchID,										d->scenario.epilogueID, true, true,										true, EpilogueTextCallBack);								result = true;								break;															case kMain_Player_editNoShipsButton:							{								short	resID =											NoShipsText_ResID_GetFromChapterPlayerNumber(												d->scenario.levelNameStrNum,												d->whichPlayer);								Handle	dummy = HRT_Resource_GetHandle(											d->heraFile, 'TEXT', resID, nil, nil);																									if ( dummy == nil)								{									dummy = NewHandle( 0);									if ( dummy != nil)									{										HRT_AddNewResource( d->heraFile, dummy, 'TEXT',											&resID, nil);									}								}																if ( dummy != nil) DisposeHandle( dummy);								TEXTEditor_NewWindow( d->heraFile,									"\pEdit Player No Ships Text",										d->resRefNum, dispatchID,										NoShipsText_ResID_GetFromChapterPlayerNumber(												d->scenario.levelNameStrNum,												d->whichPlayer), false, true,										true, nil);							}								result = true;								break;														case kData_trainingOnlyCheckBox:								ReverseCheckBox( aControl);								if ( GetControlValue( aControl))								{									d->scenario.startTime |= kScenario_IsTraining_Bit;								} else								{									d->scenario.startTime = d->scenario.startTime &															kScenario_StartTimeMask;								}								result = true;								break;														case kData_briefPointEdit:							if ( d->scenarioNumber > 0)							{								Handle	briefPointData =											HD_Find_Discrete_Data(										d->heraFile,										d->scenario.briefPointFirst,										d->scenario.briefPointNum &											kScenarioBriefMask, nil,										kHera_BriefPoint_Type);																								if ( briefPointData == nil)								{									d->scenario.briefPointFirst =										HD_Get_NextID_From_Type(											d->heraFile,											kHera_BriefPoint_Type);									d->scenario.briefPointNum =										(d->scenario.briefPointNum &											~kScenarioBriefMask);									briefPointData =										HD_Create_Discrete_Data( d->heraFile,											nil, 0, 0,											d->scenario.briefPointFirst,											kHera_BriefPoint_Type);																		if ( briefPointData != nil)									{										d->scenario.briefPointFirst =											((heraDataHeaderType *)*briefPointData)->id;									}																		}																Scenario_Editor_ChildWindow_NameMaker( d, tString);																Briefing_Editor_NewWindow(	d->heraFile,									tString,									d->resRefNum, 0, d->scenario.briefPointNum &										kScenarioBriefMask,									briefPointData,									d->heraFile->scenarioData, d->scenarioIndex,									d->scenario.initialFirst,									dispatchID,									((heraDataHeaderType *)*briefPointData)->id,									Briefing_Editor_CallBack);							}								result = true;								break;														case kData_initialEdit:								Scenario_Editor_ChildWindow_NameMaker( d, tString);																Initial_Editor_NewWindow( d->heraFile,									tString,									d->resRefNum, d->scenario.initialFirst,									0, false, true, dispatchID,									Initial_Editor_CallBack);								result = true;								break;														case kData_conditionEdit:								Scenario_Editor_ChildWindow_NameMaker( d, tString);																Condition_Editor_NewWindow( d->heraFile,									tString,									d->resRefNum, d->scenario.conditionFirst,									false, true, dispatchID,									d->scenario.initialFirst,									Condition_Editor_CallBack);								result = true;								break;														case kData_fixedAngleCheckBox:								ReverseCheckBox( aControl);								if ( GetControlValue( aControl))								{									d->scenario.briefPointNum =										( d->scenario.briefPointNum &											kScenarioBriefMask) |											(1 << kScenarioAngleShift);								} else								{									d->scenario.briefPointNum =										( d->scenario.briefPointNum &											kScenarioBriefMask);								}								result = true;								break;																default:								break;						}					} else // not in control					{						where = theEvent->where;						GlobalToLocal( &where);					}			}			break;					case keyDown:		case autoKey:			whichChar = theEvent->message & charCodeMask;			whichPart = kControlNoPart;						err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);			if (( err == noErr) && ( aControl != nil))			{				whichPart = HandleControlKey( aControl,					(theEvent->message & keyCodeMask)>>16,					theEvent->message & charCodeMask, theEvent->modifiers);				{					huiGenericControlType *hui =						(huiGenericControlType *)CU_GetControlReference( aControl);										if ( hui->kind != hui_ScrollTextControl) whichPart =						kControlNoPart;										switch( hui->id)					{						case kList_ID:							oldValue = d->scenarioIndex;							d->scenarioIndex = HUI_Control_GetListValue(										d->master, 0, kList_Cell_X,										kList_Cell_Y,										kList_ID, d->scenarioIndex);							list = HUI_List_Get(  d->master, 0,								kList_Cell_X, kList_Cell_Y, kList_ID);							if ( list != nil)							{								d->scenarioIndex = PsuedoColumn_List_GetIndex(									list, d->scenarioIndex);																if ( d->scenarioIndex != oldValue)								{									Window_SetScenario_FromControls( d, whichWindow,										oldValue);									Window_SetControls_FromScenarioIndex(										d, whichWindow, d->scenarioIndex);								}							}							break;												case kData_chapterName:							whichPart = kControlEditTextPart;							break;					}				}			}			if (((whichChar=='\r') &&				( whichPart == kControlNoPart)) || ( whichChar==0x3))			{				// ok				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kOK_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);					result = true;					OK_Button( d, whichWindow, true);					data = nil;					goto ProcessEvent_Return;				}			} else if ((whichChar==0x1b) || ((whichChar=='.') && (theEvent->modifiers & cmdKey)))			{				// cancel				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kCancel_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);										Cancel_Button( d);					data = nil;					result = true;					goto ProcessEvent_Return;				}			} else if ( whichChar == '\t')			{				if ( theEvent->modifiers & shiftKey)					ReverseKeyboardFocus( (WindowPtr)whichWindow);				else					AdvanceKeyboardFocus( (WindowPtr)whichWindow);				result = true;				break;			} else if (( whichChar == 0x08) && ( !d->chooseOnly))			{				huiPlainControlType	*hui = nil;				err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);				hui = (huiPlainControlType	*)CU_GetControlReference( aControl);				if ( hui != nil)				{					if ( hui->generic.id == kList_ID)					{						if ( HU_Confirm_Delete("\pAre you sure you "							"want to delete this scenario?",								theEvent->modifiers))						{							HSetState( data, dataState);							DeleteScenario( dispatchID, whichWindow);							HLock( data);						}					}				}				result = true;			}									break;	}		ProcessEvent_Return:	SetPort( oldPort);	if ( data != nil)		HSetState( data, dataState);	return( result);	}static void Window_SetControls_FromScenarioIndex( Scenario_EditorWindowType *d,	CWindowPtr window, long index){	SignedByte					scenarioDataState;	GrafPtr						oldPort;	scenarioType				*aScenario;	huiPlainControlParamType	dummyParam;	Handle						scenarioNameStringList;		mAssert( d != nil);	mAssert( d->scenarioData != nil);	if ( d->scenarioNumber <= 0) return;			scenarioDataState = HGetState( d->scenarioData);	HLock( d->scenarioData);	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);		aScenario = (scenarioType *)*d->scenarioData + index;		BlockMoveData( aScenario, &d->scenario, sizeof( scenarioType));		scenarioNameStringList = HRT_Resource_GetHandle( d->heraFile, 'STR#', 4600, nil, nil);	if ( scenarioNameStringList != nil)	{		RetrieveIndString( scenarioNameStringList, d->scenario.levelNameStrNum,			d->scenarioName);		DisposeHandle( scenarioNameStringList);	}		dummyParam.layer = 0;	dummyParam.cellx = kMain_Main_Cell_X;	dummyParam.celly = kMain_Main_Cell_Y;	dummyParam.master = d->mainMaster;	SetScenarioField( d, &dummyParam, aScenario, kMain_Main_playerNum, true);	SetScenarioField( d, &dummyParam, aScenario, kMain_Main_levelNameStrNum, true);	SetScenarioField( d, &dummyParam, aScenario, kData_movieNameStrNum, true);	SetScenarioField( d, &dummyParam, aScenario, kData_parKillRatio, true);	SetScenarioField( d, &dummyParam, aScenario, kData_parKills, true);	SetScenarioField( d, &dummyParam, aScenario, kData_parLosses, true);	SetScenarioField( d, &dummyParam, aScenario, kData_parTime, true);	SetScenarioField( d, &dummyParam, aScenario, kData_startTime, true);	SetScenarioField( d, &dummyParam, aScenario, kData_prologueID, true);	SetScenarioField( d, &dummyParam, aScenario, kData_epilogueID, true);	SetScenarioField( d, &dummyParam, aScenario, kData_songID, true);	SetScenarioField( d, &dummyParam, aScenario, kData_scoreStringResID, true);	SetScenarioField( d, &dummyParam, aScenario, kData_netRaceFlags, true);	SetScenarioField( d, &dummyParam, aScenario, kData_chapterName, true);	SetScenarioField( d, &dummyParam, aScenario, kData_statusStringsField, true);	SetScenarioField( d, &dummyParam, aScenario, kData_prologueField, true);	SetScenarioField( d, &dummyParam, aScenario, kData_prologueCheckBox, true);	SetScenarioField( d, &dummyParam, aScenario, kData_epilogueField, true);	SetScenarioField( d, &dummyParam, aScenario, kData_epilogueCheckBox, true);	SetScenarioField( d, &dummyParam, aScenario, kData_movieNameField, true);	SetScenarioField( d, &dummyParam, aScenario, kData_movieNameCheckBox, true);	SetScenarioField( d, &dummyParam, aScenario, kData_trainingOnlyCheckBox, true);	SetScenarioField( d, &dummyParam, aScenario, kData_fixedAngleCheckBox, true);	SetScenarioField( d, &dummyParam, aScenario, kData_fixedAngleField, true);		HSetState( d->scenarioData, scenarioDataState);		SetPort( oldPort);	Set_PlayerControls_FromTempScenario( d, window);}static void Window_SetScenario_FromControls( Scenario_EditorWindowType *d,	CWindowPtr window, long index){	SignedByte					scenarioDataState;	GrafPtr						oldPort;	scenarioType				*aScenario;	huiPlainControlParamType	dummyParam;	Handle						scenarioNameStringList;	Str255						cleanName, numberString;	Ptr							data;	long						dataLength, cellReferenceNumber;	ListHandle					list;		mAssert( d != nil);	mAssert( d->scenarioData);		if ( d->scenarioNumber <= 0) return;		if ( d->chooseOnly) return;		Set_TempScenario_FromPlayerControls( d,		window);	scenarioDataState = HGetState( d->scenarioData);	HLock( d->scenarioData);	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);		aScenario = (scenarioType *)*d->scenarioData + index;	// set params		dummyParam.layer = 0;	dummyParam.cellx = kMain_Main_Cell_X;	dummyParam.celly = kMain_Main_Cell_Y;	dummyParam.master = d->mainMaster;		GetScenarioField( d, &dummyParam, &d->scenario, kMain_Main_playerNum);	GetScenarioField( d, &dummyParam, &d->scenario, kMain_Main_levelNameStrNum);	GetScenarioField( d, &dummyParam, &d->scenario, kData_movieNameStrNum);	GetScenarioField( d, &dummyParam, &d->scenario, kData_parKillRatio);	GetScenarioField( d, &dummyParam, &d->scenario, kData_parKills);	GetScenarioField( d, &dummyParam, &d->scenario, kData_parLosses);	GetScenarioField( d, &dummyParam, &d->scenario, kData_parTime);	GetScenarioField( d, &dummyParam, &d->scenario, kData_startTime);	GetScenarioField( d, &dummyParam, &d->scenario, kData_prologueID);	GetScenarioField( d, &dummyParam, &d->scenario, kData_epilogueID);	GetScenarioField( d, &dummyParam, &d->scenario, kData_songID);	GetScenarioField( d, &dummyParam, &d->scenario, kData_scoreStringResID);	GetScenarioField( d, &dummyParam, &d->scenario, kData_netRaceFlags);	GetScenarioField( d, &dummyParam, &d->scenario, kData_chapterName);	GetScenarioField( d, &dummyParam, &d->scenario, kData_trainingOnlyCheckBox);	GetScenarioField( d, &dummyParam, &d->scenario, kData_fixedAngleCheckBox);	GetScenarioField( d, &dummyParam, &d->scenario, kData_fixedAngleField);		scenarioNameStringList = HRT_Resource_GetHandle( d->heraFile, 'STR#', 4600, nil, nil);	if ( scenarioNameStringList != nil)	{		StringListRemove( scenarioNameStringList, d->scenario.levelNameStrNum);		StringListInstall( scenarioNameStringList, d->scenario.levelNameStrNum,			d->scenarioName);		HRT_KeepChangedResource( d->heraFile, scenarioNameStringList, 'STR#', 4600, 4600,			"\pChapter Name Strings");		DisposeHandle( scenarioNameStringList);	}	pstrcpy( cleanName, d->scenarioName);	ChapterString_NormalizeInPlace( cleanName);	if ( cleanName[0] == 0) pstrcpy( cleanName, "\puntitled");		NumToString( d->scenario.levelNameStrNum,		numberString);			list = HUI_List_Get( d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( list != nil)	{		cellReferenceNumber = PsuedoColumn_List_GetIndex( list,			d->scenario.levelNameStrNum - 1);					data = PsuedoColumn_Data_Make( &dataLength,			cellReferenceNumber, numberString, "\p\t",			cleanName, "\p");		if ( data != nil)		{			ControlHandle	aControl;						LSetCell( data, dataLength, (Point){d->scenario.levelNameStrNum - 1,						0}, list);			DisposePtr( data);						aControl = HUI_Control_Get( d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID);			if ( aControl != nil)				Draw1Control( aControl);		}	}	if ( !HU_Data_Is_Identical( (Ptr)&d->scenario, (Ptr)aScenario, sizeof( scenarioType)))	{		d->heraFile->changed = true;	}		BlockMoveData( &d->scenario, aScenario, sizeof( scenarioType));	HSetState( d->scenarioData, scenarioDataState);		SetPort( oldPort);}static void Set_PlayerControls_FromTempScenario( Scenario_EditorWindowType *d,	CWindowPtr window){	SignedByte					scenarioDataState;	GrafPtr						oldPort;	huiPlainControlParamType	dummyParam;			mAssert( d != nil);	mAssert( d->scenarioData != nil);		if ( d->scenarioNumber <= 0) return;		scenarioDataState = HGetState( d->scenarioData);	HLock( d->scenarioData);	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);		dummyParam.layer = 0;	dummyParam.master = d->mainMaster;	dummyParam.cellx = kMain_Player_Cell_X;	dummyParam.celly = kMain_Player_Cell_Y;	SetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_Which_Player, true);	SetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_playerType, true);	SetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_playerRace, true);	SetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_earningPower, true);//	SetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_nameResID, true);//	SetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_nameStrNum, true);	SetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_nameField, true);	SetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_netRaceFlags, true);	SetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_raceMenu, true);	SetPort( oldPort);	HSetState( d->scenarioData, scenarioDataState);}static void Set_TempScenario_FromPlayerControls( Scenario_EditorWindowType *d,	CWindowPtr window){	SignedByte					scenarioDataState;	GrafPtr						oldPort;	huiPlainControlParamType	dummyParam;			mAssert( d != nil);	mAssert( d->scenarioData != nil);		if ( d->scenarioNumber <= 0) return;		scenarioDataState = HGetState( d->scenarioData);	HLock( d->scenarioData);	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);		dummyParam.layer = 0;	dummyParam.master = d->mainMaster;	dummyParam.cellx = kMain_Player_Cell_X;	dummyParam.celly = kMain_Player_Cell_Y;	GetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_Which_Player);	GetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_playerType);	GetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_playerRace);	GetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_earningPower);	GetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_nameResID);	GetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_nameStrNum);	GetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_raceMenu);	SetPort( oldPort);	HSetState( d->scenarioData, scenarioDataState);} static void SetScenarioField( Scenario_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioType *s, long id, Boolean draw){	ControlHandle	aControl;	Str255			ts;		if ( dummyParam == nil) return;	if ( s == nil) return;	if ( id < 0) return;		aControl = HUI_Control_Get( dummyParam->master, dummyParam->layer,		dummyParam->cellx, dummyParam->celly, id);	if ( aControl == nil) return;		switch ( id)	{		case kMain_Main_playerNum:			SetControlTextItemLong( aControl, s->playerNum);			break;				case kMain_Main_levelNameStrNum:			SetControlValue( aControl, s->levelNameStrNum);			break;				case kData_movieNameStrNum:			SetControlValue( aControl, s->movieNameStrNum);			break;				case kData_parKillRatio:			SetControlTextItemSmallFixed( aControl, s->parKillRatio);			break;				case kData_parKills:			SetControlTextItemLong( aControl, s->parKills);			break;				case kData_parLosses:			SetControlTextItemLong( aControl, s->parLosses);			break;				case kData_parTime:			SetControlTextItemLong( aControl, s->parTime);			break;				case kData_startTime:			SetControlTextItemLong( aControl, s->startTime & kScenario_StartTimeMask);			break;				case kData_trainingOnlyCheckBox:			SetControlValue( aControl, (s->startTime & kScenario_IsTraining_Bit) ?				(1):(0));			break;					case kData_prologueID:			SetControlTextItemLong( aControl, s->prologueID);			break;				case kData_epilogueID:			SetControlTextItemLong( aControl, s->epilogueID);			break;				case kData_songID:			SetControlTextItemLong( aControl, s->songID);			break;				case kData_scoreStringResID:			SetControlTextItemLong( aControl, s->scoreStringResID);			break;				case kData_netRaceFlags:			SetNetRaceFlags( d->windowID, s->netRaceFlags);			break;				case kMain_Player_Which_Player://			SetControlValue( aControl, d->whichPlayer + 1);			break;				case kMain_Player_playerType:			SetControlValue( aControl, s->player[d->whichPlayer].playerType + 1);			break;					case kMain_Player_playerRace:			SetControlTextItemLong( aControl, s->player[d->whichPlayer].playerRace);			break;				case kMain_Player_earningPower:			SetControlTextItemSmallFixed( aControl, s->player[d->whichPlayer].earningPower);			break;				case kMain_Player_nameResID:			SetControlTextItemLong( aControl, s->player[d->whichPlayer].nameResID);			break;					case kMain_Player_nameStrNum:			SetControlTextItemLong( aControl, s->player[d->whichPlayer].nameStrNum);			break;		case kMain_Player_nameField:			SetControlTextItemString( aControl,				HU_GetOneIndString( d->heraFile, s->player[d->whichPlayer].nameResID,					s->player[d->whichPlayer].nameStrNum, ts));			break; 				case kMain_Player_netRaceFlags:			HU_HUIMenu_SetCheckFromBits( d->mainMaster, 0, kMain_Player_Cell_X,				kMain_Player_Cell_Y, kMain_Player_netRaceFlags,				s->player[d->whichPlayer].netRaceFlags, 0, 15);			break;				case kMain_Player_raceMenu:			SetControlValue( aControl, 				HD_RaceIndex_GetFrom_RaceID( d->heraFile, 					s->player[d->whichPlayer].playerRace) + 1);			break;					case kData_chapterName:			SetControlTextItemString( aControl, d->scenarioName);			break;				case kData_statusStringsField:			SetControlTextItemString( aControl,				HNM_Resource_Name_Make( d->heraFile, 'STR#', s->scoreStringResID, ts));			break;		case kData_prologueField:			SetControlTextItemString( aControl,				HNM_Resource_Name_Make( d->heraFile, 'TEXT', s->prologueID, ts));			break;		case kData_prologueCheckBox:			if ( s->prologueID > 0)				SetControlValue( aControl, 1);			else				SetControlValue( aControl, 0);			break;		case kData_epilogueField:			SetControlTextItemString( aControl,				HNM_Resource_Name_Make( d->heraFile, 'TEXT', s->epilogueID, ts));			break;		case kData_movieNameField:			SetControlTextItemString( aControl,				HU_GetOneIndString( d->heraFile, 4500,					s->movieNameStrNum, ts));			break;				case kData_epilogueCheckBox:			if ( s->epilogueID > 0)				SetControlValue( aControl, 1);			else				SetControlValue( aControl, 0);			break;					case kData_movieNameCheckBox:			if ( s->movieNameStrNum > 0)				SetControlValue( aControl, 1);			else				SetControlValue( aControl, 0);			break;				case kData_fixedAngleCheckBox:			if ( s->briefPointNum & kScenarioAngleMask)			{				SetControlValue( aControl, 1);			} else			{				SetControlValue( aControl, 0);			}			break;				case kData_fixedAngleField:			if ( s->briefPointNum & kScenarioAngleMask)			{				ActivateControl( aControl);				SetControlTextItemLong( aControl, (((s->briefPointNum &					kScenarioAngleMask) >> kScenarioAngleShift) - 1) * 2);			} else			{				DeactivateControl( aControl);				SetControlTextItemString( aControl,"\p");			}			break;	}		if ( draw) Draw1Control( aControl);}static void GetScenarioField( Scenario_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioType *s, long id){	ControlHandle	aControl;	long			i;		if ( dummyParam == nil) return;	if ( s == nil) return;	if ( id < 0) return;		aControl = HUI_Control_Get( dummyParam->master, dummyParam->layer,		dummyParam->cellx, dummyParam->celly, id);	if ( aControl == nil) return;		switch ( id)	{		case kMain_Main_playerNum:			s->playerNum = GetControlTextItemLong( aControl);			break;				case kMain_Main_levelNameStrNum:			s->levelNameStrNum = GetControlValue( aControl);			break;				case kData_movieNameStrNum://			s->movieNameStrNum = GetControlValue( aControl);			break;				case kData_parKillRatio:			s->parKillRatio = GetControlTextItemSmallFixed( aControl);			break;				case kData_parKills:			s->parKills = GetControlTextItemLong( aControl);			break;				case kData_parLosses:			s->parLosses = GetControlTextItemLong( aControl);			break;				case kData_parTime:			s->parTime = GetControlTextItemLong( aControl);			break;				case kData_startTime:			s->startTime = (s->startTime & ~kScenario_StartTimeMask) |							GetControlTextItemLong( aControl);			break;				case kData_trainingOnlyCheckBox:			s->startTime = (s->startTime & kScenario_StartTimeMask) |				((GetControlValue( aControl) ? (kScenario_IsTraining_Bit) : (0)));			break;					case kData_prologueID:			s->prologueID = GetControlTextItemLong( aControl);			break;				case kData_epilogueID:			s->epilogueID = GetControlTextItemLong( aControl);			break;				case kData_songID:			s->songID = GetControlTextItemLong( aControl);			break;				case kData_scoreStringResID:			s->scoreStringResID = GetControlTextItemLong( aControl);			break;				case kData_netRaceFlags://			s->netRaceFlags = GetNetRaceFlags( d->windowID);			break;				case kMain_Player_Which_Player://			d->whichPlayer = GetControlValue( aControl) - 1;			break;				case kMain_Player_playerType:			s->player[d->whichPlayer].playerType = GetControlValue( aControl) - 1;			break;					case kMain_Player_playerRace://			s->player[d->whichPlayer].playerRace = GetControlTextItemLong( aControl);			break;				case kMain_Player_raceMenu:			s->player[d->whichPlayer].playerRace =				HD_RaceID_GetFrom_RaceIndex( d->heraFile, GetControlValue( aControl) - 1);			break;					case kMain_Player_earningPower:			s->player[d->whichPlayer].earningPower = GetControlTextItemSmallFixed( aControl);			break;				case kMain_Player_nameResID:			s->player[d->whichPlayer].nameResID = GetControlTextItemLong( aControl);			break;					case kMain_Player_nameStrNum:			s->player[d->whichPlayer].nameStrNum = GetControlTextItemLong( aControl);			break;				case kData_chapterName:			GetControlTextItemString( aControl, d->scenarioName);			break;				case kData_fixedAngleCheckBox:			if ( GetControlValue( aControl))			{				s->briefPointNum = (s->briefPointNum & kScenarioBriefMask) |					(1 << kScenarioAngleShift);			} else			{				s->briefPointNum = (s->briefPointNum & kScenarioBriefMask);			}			break;				case kData_fixedAngleField:			if ( s->briefPointNum & kScenarioAngleMask)			{				i = GetControlTextItemLong( aControl);				if ( i < 0) i = 0;				if ( i > 359) i = 359;				s->briefPointNum = (s->briefPointNum & kScenarioBriefMask) |					(((i / 2) + 1) << kScenarioAngleShift);			}			break;				}	}static void OK_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Scenario_EditorWindowType		*d;		if ( data == nil) return;		dataState = HGetState( data);	HLock( data);	d = (Scenario_EditorWindowType *)*data;	OK_Button( d, whichWindow, false);	// data has been deleted; window is closed}static void Cancel_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Scenario_EditorWindowType		*d;#pragma unused( whichWindow)		if ( data == nil) return;		dataState = HGetState( data);	HLock( data);	d = (Scenario_EditorWindowType *)*data;//	Cancel_Button( d);	OK_Button( d, whichWindow, true);	// data has been deleted; window is closed}static void OK_Button( Scenario_EditorWindowType *d, CWindowPtr whichWindow,						Boolean closeWindow){	if ( d != nil)	{		Window_SetScenario_FromControls( d, whichWindow,										d->scenarioIndex);		if  ( closeWindow)		{			if ( d->raceStrList != nil)			{				DisposeHandle( d->raceStrList);			}		}		if ( d->scenarioData != nil)		{			if ( !d->chooseOnly)			{				if ( d->heraFile->scenarioData != nil)				{					DisposeHandle( d->heraFile->scenarioData);				}				 d->heraFile->scenarioData = d->scenarioData;				 HandToHand( & d->heraFile->scenarioData);			}			if ( closeWindow)				DisposeHandle( d->scenarioData);		}		if ( d->callBack != nil)		{			d->callBack( true, d->callerID);		}		if ( closeWindow)		{			HUI_MasterControl_Delete( d->master);			CloseDispatchWindow( d->windowID);		}	}}static void Cancel_Button( Scenario_EditorWindowType *d){	if ( d != nil)	{		if ( d->raceStrList != nil)		{			DisposeHandle( d->raceStrList);		}		if ( d->callBack != nil)		{			d->callBack( false, d->callerID);		}		HUI_MasterControl_Delete( d->master);		CloseDispatchWindow( d->windowID);	}}static void Revert_Button( Scenario_EditorWindowType *d){	CWindowPtr whichWindow = GetWindowPtrFromDispatchWindowID( d->windowID);		if ( whichWindow == nil) return;	if ( !Button_Window_Modal( "\pRevert this scenario?",							"\pClick Revert to restore this scenario to its "							"previous values. Click Cancel to "							"keep it as it is.", "\pRevert", nil))		return;	Window_SetControls_FromScenarioIndex(		d, whichWindow, d->scenarioIndex);}static void List_Click( CWindowPtr whichWindow, Point where,	Scenario_EditorWindowType *d, ControlHandle aControl){	ListHandle				list;	short					shortLength = 0, oldValue, dragTo, dragFrom;	Ptr						data = nil;	long					newValue, longLength;		BPMOWritePString("\pStarting List_Click\r");		GetListBoxListHandle( aControl, &list);	if ( list == nil) return;		BPMOWritePString("\pList_Reposition_Drag: ");	if ( !d->chooseOnly)		dragTo =  List_Reposition_Drag( list, where, aControl);	else		dragTo = -1;	oldValue = d->scenarioIndex;	BPMOWriteLong( dragTo);	BPMOWritePString("\p, ");	BPMOWriteLong( oldValue);	BPMOWritePString("\p\r");		dragFrom = d->scenarioIndex = HUI_Control_GetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->scenarioIndex);	BPMOWriteLong( dragFrom);	BPMOWritePString("\p\r");	{				HUI_Control_GetListCell(			d->master, 0, kList_Cell_X,			kList_Cell_Y, kList_ID,			0, d->scenarioIndex, &data, &longLength);		if ( data != nil)		{			PsuedoColumn_String_GetAll( data,				longLength, &newValue,				(StringPtr)-1);			d->scenarioIndex = newValue;			DisposePtr( data);		} else			d->scenarioIndex = oldValue;	}	if ( d->scenarioIndex != oldValue)	{		Window_SetScenario_FromControls( d, whichWindow, oldValue);		Window_SetControls_FromScenarioIndex(			d, whichWindow, d->scenarioIndex);				}		if ( dragTo != -1)	{		d->dragTo = dragTo;		d->dragFrom = dragFrom;//		Button_Window_NewWindow("\pChange Scenario Order", true, false, 8021,//			8033, ConfirmListDragCallBack, d->windowID);		ConfirmListDragCallBack( kOK_Button_ID, d->windowID);	}		}static void ConfirmListDragCallBack( long whichButton, long windowID){	Handle							wdata =										GetDispatchWindowDataHandle( windowID),									saveDragText[kScenarioPlayerNum];	SignedByte						dataState;	Scenario_EditorWindowType		*d;	ListHandle						list;	short							shortLength = 0, dragTo,									dragFrom, i, j, resID;	Ptr								data = nil;	long							newValue, longLength, dataIndex;	Str255							idString, nameString, resName, dragChapterName;	Handle							tempText, chapterNameStrings = nil;	ControlHandle					aControl;	scenarioType					*aScenario;		if ( wdata == nil) return;	dataState = HGetState( wdata);	HLock( wdata);	d = (Scenario_EditorWindowType *)*wdata;		mAssert( d->heraFile != nil);	d->heraFile->changed= true;	DispatchWindowDispatchWDEvent( kWD_CloseForScenarioOrder_Command);		dragFrom = d->dragFrom;	dragTo = d->dragTo;			aControl = HUI_Control_Get( d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID);	if ( aControl == nil) goto ConfirmListDragCallBack_error;		GetListBoxListHandle( aControl, &list);	if ( list == nil) goto ConfirmListDragCallBack_error;	if ( whichButton != 1) dragTo = -1;	if ( dragTo != -1)	{		data = List_Utilities_GetCell( list, (Point){dragFrom, 0}, &shortLength);		if ( data != nil)		{			LDelRow( 1, dragFrom, list);			if ( dragFrom < dragTo) dragTo--;			LAddRow( 1, dragTo, list);			LSetCell( data, shortLength, (Point){dragTo, 0}, list);			HUI_Control_SetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, dragTo);			DisposePtr( data);						chapterNameStrings = HRT_Resource_GetHandle( d->heraFile, 'STR#', 4600,				nil, nil);			if ( chapterNameStrings != nil)			{				RetrieveIndString( chapterNameStrings, dragFrom + 1,					dragChapterName);				StringListRemove( chapterNameStrings, dragFrom + 1);				StringListInstall( chapterNameStrings, dragTo + 1,					dragChapterName);			}						d->scenario.levelNameStrNum = dragTo + 1;						for ( j = 0; j < kScenarioPlayerNum; j++)			{				saveDragText[j] = HRT_Resource_GetHandle( d->heraFile, 					'TEXT', NoShipsText_ResID_GetFromChapterPlayerNumber(						dragFrom+1, j), nil, nil);				HRT_DeleteResource( d->heraFile, 'TEXT',					NoShipsText_ResID_GetFromChapterPlayerNumber(dragFrom+1, j));			}								if ( dragTo > dragFrom)			{				for ( i = dragFrom; i <= dragTo; i++)				{					data = List_Utilities_GetCell( list, (Point){i, 0},						&shortLength);					if ( data != nil)					{						PsuedoColumn_String_GetAll( data, shortLength,							&dataIndex, idString, nameString, (StringPtr)-1);						DisposePtr( data);												StringToNum( idString, &newValue);												if ( i != dragFrom)						{							// change the no ships text resource ids							for ( j = 0; j < kScenarioPlayerNum; j++)							{								tempText = HRT_Resource_GetHandle( d->heraFile, 'TEXT',									NoShipsText_ResID_GetFromChapterPlayerNumber(													i+1, j),										&resID, resName);								if ( tempText != nil)								{									HRT_KeepChangedResource( d->heraFile, tempText, 'TEXT',										NoShipsText_ResID_GetFromChapterPlayerNumber(													i+1, j),										NoShipsText_ResID_GetFromChapterPlayerNumber(													i, j),										resName);																		DisposeHandle( tempText);								}							}						}												// change the actual scenario data												NumToString( i + 1, idString);												data = PsuedoColumn_Data_Make( &longLength,							dataIndex, idString, "\p\t", nameString, "\p");												if ( data != nil)						{							LSetCell( data, longLength, (Point){i, 0}, list);							DisposePtr( data);						}												aScenario = (scenarioType *)*d->scenarioData + dataIndex;						if ( i != dragTo)							aScenario->levelNameStrNum--;						else							aScenario->levelNameStrNum = dragTo + 1;											}									}			} else if ( dragTo < dragFrom)			{				for ( i = dragFrom; i >= dragTo; i--)				{					data = List_Utilities_GetCell( list, (Point){i, 0},						&shortLength);					if ( data != nil)					{						PsuedoColumn_String_GetAll( data, shortLength,							&dataIndex, idString, nameString, (StringPtr)-1);						DisposePtr( data);						StringToNum( idString, &newValue);												// change the no ships text resource ids						for ( j = 0; j < kScenarioPlayerNum; j++)						{							tempText = HRT_Resource_GetHandle( d->heraFile, 'TEXT',								NoShipsText_ResID_GetFromChapterPlayerNumber(												i+1,												j),									&resID, resName);							if ( tempText != nil)							{								HRT_KeepChangedResource( d->heraFile, tempText, 'TEXT',									resID, NoShipsText_ResID_GetFromChapterPlayerNumber(												i+2,												j),									resName);																	DisposeHandle( tempText);							}						}						NumToString( i + 1, idString);												data = PsuedoColumn_Data_Make( &longLength,							dataIndex, idString, "\p\t", nameString, "\p");												if ( data != nil)						{							LSetCell( data, longLength, (Point){i, 0}, list);							DisposePtr( data);						}						aScenario = (scenarioType *)*d->scenarioData + dataIndex;						if ( i != dragTo)							aScenario->levelNameStrNum++;						else							aScenario->levelNameStrNum = dragTo + 1;					}									}			}						Draw1Control( aControl);		}		if ( chapterNameStrings != nil)		{			HRT_KeepChangedResource( d->heraFile, chapterNameStrings, 'STR#',				4600, 4600, "\pChapter Name Strings");		}		for ( j = 0; j < kScenarioPlayerNum; j++)		{			if ( saveDragText[j] != nil)			{				resID = NoShipsText_ResID_GetFromChapterPlayerNumber( dragTo + 1, j);				pstrcpy( nameString, "\pno ships ");				NumToString( dragTo + 1, idString);				pstrcat( nameString, idString);				pstrcat( nameString, "\p ");				NumToString( j + 1, idString);				pstrcat( nameString, idString);				HRT_AddNewResource( d->heraFile, saveDragText[j], 'TEXT', &resID, nameString);				DisposeHandle( saveDragText[j]);			}		}						}	HRT_Debug_Printout( d->heraFile);ConfirmListDragCallBack_error:	if ( wdata != nil)		HSetState( wdata, dataState);	if ( chapterNameStrings != nil)		DisposeHandle( chapterNameStrings);}static void DeleteScenario( long windowID, CWindowPtr window){	Handle							wdata =										GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Scenario_EditorWindowType		*d;	ListHandle						list;	short							shortLength = 0, deleteListRow,									i, j, resID;	Ptr								data = nil;	long							newValue, longLength, dataIndex,									deleteDataIndex, listValue = 0;	Str255							idString, nameString, resName;	Handle							tempText, chapterNameStrings = nil;	ControlHandle					aControl;	scenarioType					*aScenario;	short							oldResFile = CurResFile(), ownerFile = -1;		if ( wdata == nil) return;	dataState = HGetState( wdata);	HLock( wdata);	d = (Scenario_EditorWindowType *)*wdata;		d->heraFile->changed= true;		if ( d->scenarioNumber < 1) return;		if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);		deleteListRow = HUI_Control_GetListValue(										d->master, 0, kList_Cell_X,										kList_Cell_Y,										kList_ID, d->scenarioIndex);		aControl = HUI_Control_Get( d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID);	if ( aControl == nil) goto DeleteScenario_error;		GetListBoxListHandle( aControl, &list);	if ( list == nil) goto DeleteScenario_error;	if ( deleteListRow != -1)	{		data = List_Utilities_GetCell( list, (Point){deleteListRow, 0}, &shortLength);		if ( data != nil)		{			LDelRow( 1, deleteListRow, list);			listValue = HUI_Control_SetListValue( d->master, 0, kList_Cell_X,				kList_Cell_Y, kList_ID, deleteListRow);			PsuedoColumn_String_GetAll( data, shortLength,				&deleteDataIndex, idString, nameString, (StringPtr)-1);			DisposePtr( data);						chapterNameStrings = HRT_Resource_GetHandle( d->heraFile, 'STR#',				4600, nil, nil);			if ( chapterNameStrings != nil)			{				StringListRemove( chapterNameStrings, deleteListRow + 1);			}						for ( j = 0; j < kScenarioPlayerNum; j++)			{				tempText = HRT_Resource_GetHandle_WithOwnerFile( d->heraFile,					'TEXT',					NoShipsText_ResID_GetFromChapterPlayerNumber(						deleteListRow+1, j),					&resID, &ownerFile, resName);								if ( tempText != nil)				{//					if ( ownerFile == d->heraFile->fileRefNum)					{						HRT_DeleteResource( d->heraFile, 'TEXT',							NoShipsText_ResID_GetFromChapterPlayerNumber(								deleteListRow + 1, j));					}					DisposeHandle( tempText);				}			}						{				for ( i = 0; i < d->scenarioNumber - 1; i++)				{					data = List_Utilities_GetCell( list, (Point){i, 0},						&shortLength);					if ( data != nil)					{						PsuedoColumn_String_GetAll( data, shortLength,							&dataIndex, idString, nameString, (StringPtr)-1);						DisposePtr( data);												StringToNum( idString, &newValue);												if ( i >= deleteListRow)						{							// change the no ships text resource ids							for ( j = 0; j < kScenarioPlayerNum; j++)							{								tempText = HRT_Resource_GetHandle_WithOwnerFile									( d->heraFile,										'TEXT',										NoShipsText_ResID_GetFromChapterPlayerNumber(										i+2, j),									&resID, &ownerFile, resName);								if ( tempText != nil)								{//									if ( ownerFile == d->heraFile->fileRefNum)									{										HRT_KeepChangedResource( d->heraFile,											tempText, 'TEXT',											NoShipsText_ResID_GetFromChapterPlayerNumber(												i+2, j),											NoShipsText_ResID_GetFromChapterPlayerNumber(														i+1, j),											resName);									}																		DisposeHandle( tempText);								}							}						}																			NumToString( i + 1, idString);												data = PsuedoColumn_Data_Make( &longLength,							(dataIndex > deleteDataIndex) ?								( dataIndex - 1) : ( dataIndex),							idString, "\p\t", nameString, "\p");												if ( data != nil)						{							LSetCell( data, longLength, (Point){i, 0}, list);							DisposePtr( data);						}												// change the actual scenario data						aScenario = (scenarioType *)*d->scenarioData +									dataIndex;						if ( i >= deleteListRow)							aScenario->levelNameStrNum--;											}									}			}						LAutoScroll( list);			Draw1Control( aControl);		}		if ( chapterNameStrings != nil)		{			HRT_KeepChangedResource( d->heraFile, chapterNameStrings, 'STR#',				4600, 4600, "\pChapter Name Strings");		}						}	d->scenarioNumber--;		if ( d->scenarioNumber <= 0) Enable_Editing( d, false);		d->scenarioIndex = PsuedoColumn_List_GetIndex( list, listValue);	HU_Handle_DeleteData( deleteDataIndex, d->scenarioData,		sizeof( scenarioType), 0);			Window_SetControls_FromScenarioIndex(		d, window, d->scenarioIndex);		HRT_Debug_Printout( d->heraFile);	DeleteScenario_error:	if ( wdata != nil)		HSetState( wdata, dataState);	if ( chapterNameStrings != nil)		DisposeHandle( chapterNameStrings);	UseResFile ( oldResFile);	}static void AddScenario( long windowID, CWindowPtr window){	Handle							wdata =										GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Scenario_EditorWindowType		*d;	ListHandle						list;	short							shortLength = 0, addIndex, j;	Ptr								data = nil;	long							dataLength;	Str255							idString, nameString;	Handle							scenarioData, chapterNameStrings = nil;	ControlHandle					aControl;	scenarioType					*aScenario;		if ( wdata == nil) return;	dataState = HGetState( wdata);	HLock( wdata);	d = (Scenario_EditorWindowType *)*wdata;		d->heraFile->changed= true;	scenarioData = d->scenarioData;	HUnlock( wdata);	SetHandleSize( scenarioData, GetHandleSize( scenarioData) +		sizeof( scenarioType));	if ( MemError() != noErr) goto AddScenario_error;		HLock( wdata);	d = (Scenario_EditorWindowType *)*wdata;	addIndex = d->scenarioNumber;		if ( d->scenarioNumber <= 0) Enable_Editing( d, true);		aControl = HUI_Control_Get( d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID);	if ( aControl == nil) goto AddScenario_error;		GetListBoxListHandle( aControl, &list);	if ( list == nil) goto AddScenario_error;	if ( addIndex != -1)	{		pstrcpy(nameString, "\p\\i Chapter ");		NumToString( addIndex+1, idString);		pstrcat( nameString, idString);		pstrcat( nameString, "\p \r\\iUntitled");				data = PsuedoColumn_Data_Make( &dataLength,			addIndex, idString, "\p\t", nameString, "\p");		if ( data != nil)		{			LAddRow( 1, addIndex, list);			LSetCell( data, dataLength, (Point){addIndex, 0}, list);			HUI_Control_SetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, addIndex);			DisposePtr( data);						chapterNameStrings = HRT_Resource_GetHandle( d->heraFile, 'STR#', 4600,				nil, nil);			if ( chapterNameStrings != nil)			{				StringListInstall( chapterNameStrings, addIndex + 1,					nameString);			}						d->scenario.levelNameStrNum = addIndex + 1;			d->scenario.netRaceFlags = 0;			d->scenario.playerNum = 1;			d->scenario.scoreStringResID = -1;			d->scenario.initialFirst = -1;			d->scenario.prologueID = -1;			d->scenario.initialNum = 0;			d->scenario.songID = -1;			d->scenario.conditionFirst = -1;			d->scenario.epilogueID = -1;			d->scenario.conditionNum = 0;			d->scenario.starMapH = 0;			d->scenario.briefPointFirst = -1;			d->scenario.starMapV = 0;			d->scenario.briefPointNum = 0;			d->scenario.parTime = 0;			d->scenario.movieNameStrNum = -1;			d->scenario.parKills = -1;			d->scenario.parKillRatio = 0;			d->scenario.parLosses = 0;			d->scenario.startTime = 0;						for ( j = 0; j < kScenarioPlayerNum; j++)			{				d->scenario.player[j].playerType = kSingleHumanPlayer;				d->scenario.player[j].playerRace =					HD_RaceID_GetFrom_RaceIndex( d->heraFile, 0);				d->scenario.player[j].nameResID = -1;				d->scenario.player[j].nameStrNum = -1;				d->scenario.player[j].admiralNumber = j;				d->scenario.player[j].earningPower = 0;				d->scenario.player[j].netRaceFlags = 0;				d->scenario.player[j].reserved1 = 0;			}								aScenario = ((scenarioType *)*d->scenarioData) + addIndex;			BlockMove( &d->scenario, aScenario, sizeof( scenarioType));						LAutoScroll( list);			Draw1Control( aControl);		}		if ( chapterNameStrings != nil)		{			HRT_KeepChangedResource( d->heraFile, chapterNameStrings, 'STR#',				4600, 4600, "\pChapter Name Strings");		}						}	d->scenarioNumber++;	d->scenarioIndex = PsuedoColumn_List_GetIndex( list, addIndex);	Window_SetControls_FromScenarioIndex(		d, window, d->scenarioIndex);AddScenario_error:	if ( wdata != nil)		HSetState( wdata, dataState);	if ( chapterNameStrings != nil)		DisposeHandle( chapterNameStrings);} static void SetNetRaceFlags( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Scenario_EditorWindowType		*d;//	huiPlainControlParamType		dummyParam;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Scenario_EditorWindowType *)*data;	if ( d->chooseOnly)	{		HSetState( data, dataState);		return;	}		d->scenario.player[d->whichPlayer].netRaceFlags = bits;	HU_HUIMenu_SetCheckFromBits( d->mainMaster, 0, kMain_Main_Cell_X,		kMain_Main_Cell_Y,		kData_netRaceFlags, bits, 0, 15);		HSetState( data, dataState);}static void AddBitPopUp( huiPlainControlParamType *textParam,	huiPlainControlParamType *buttonParam, long id, short resID, short index,	Boolean newLine, short tabStart, Handle stringList){	//  label	textParam->id = id-1;	GetIndString( textParam->label, resID, index); // which base type	textParam->whichTabSet = 0;	textParam->whichTab = tabStart;	textParam->flags = (newLine)?(huiControlFlag_newLine):(huiControlFlag_none);	textParam->minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( textParam);		buttonParam->id = id;	buttonParam->special.menuStrList.strList = stringList;	buttonParam->special.menuStrList.menuID = HU_GetNewMenuID();//id;	buttonParam->special.menuStrList.cicnResID = 128;	buttonParam->special.menuStrList.multiSelect = true;	buttonParam->whichTabSet = 0;	buttonParam->whichTab = tabStart + 1;	buttonParam->flags = huiControlFlag_none;	buttonParam->space.left = 8;		HUI_BevelButtonMenu_New_StrList( buttonParam);	buttonParam->whichTabSet = -1;	buttonParam->whichTab = -1;	if ( buttonParam->special.menuStrList.strList != nil)		ReleaseResource( buttonParam->special.menuStrList.strList);			// set attributes button	buttonParam->id = id + 2;	GetIndString( buttonParam->label, kHera_AppStrResID, 8); // setÉ	buttonParam->space.left = 8;	buttonParam->minMaxBounds.right = kHUI_Pixel_Max;	buttonParam->minMaxBounds.left = 0;	HUI_PushButton_New_LiteralP( buttonParam);}static void GetAllData( Scenario_EditorWindowType *d){	short						oldResRefNum = 0;	ControlHandle				aControl;	ListHandle					list;	OSErr						err;	long						conditionNum = 0;		if ( d == nil) return;	oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);	/*	d->scenarioData = GetResource( 'snro', 500);	if ( d->scenarioData == nil) d->scenarioData = NewHandle(0);	else	{		DetachResource( d->scenarioData);	}*/	if (( d->scenarioData != nil) && ( d->scenarioData !=		d->heraFile->scenarioData))	{		DisposeHandle( d->scenarioData);			}	d->scenarioData = d->heraFile->scenarioData;	err = HandToHand( &d->scenarioData);	if (( d->scenarioData == nil) || ( err != noErr))	{		goto GetAllData_error;	}		aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Cell		cell;				d->scenarioNumber = GetHandleSize( d->scenarioData) /			sizeof( scenarioType);		d->scenarioIndex = 0;		GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			short	i = d->scenarioIndex, count = d->scenarioNumber;			Str255	chapterName, chapterIndex;			Ptr		data = nil;			long	dataLength;			Handle	chapterNameStringList = HRT_Resource_GetHandle( d->heraFile,												'STR#', 4600, nil, nil);			BPMOWritePString("\pchapter name list size: ");			BPMOWriteLong( GetHandleSize( chapterNameStringList));			BPMOWritePString("\p\r");						LDelRow( 0, 0, list);	// delete all rows//			List_ClickLoopProc_Install( list, NullClickLoop);			ImmediateReturn_ClickLoop_Install( list);						(*list)->selFlags = lOnlyOne;						cell.h = 0;			while ( count > 0)			{//				GetIndString( chapterName, 4600,//					((scenarioType *)*d->scenarioData + i)->levelNameStrNum);;				if ( chapterNameStringList != nil)				{					RetrieveIndString( chapterNameStringList,						((scenarioType *)*d->scenarioData + i)->levelNameStrNum,						chapterName);				}								ChapterString_NormalizeInPlace( chapterName);				if ( chapterName[0] == 0) pstrcpy( chapterName, "\puntitled");				NumToString( ((scenarioType *)*d->scenarioData + i)->levelNameStrNum,					chapterIndex);				data = PsuedoColumn_Data_Make( &dataLength,					i, chapterIndex, "\p\t",					chapterName, "\p");				if ( data != nil)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( data, dataLength, cell, list );					DisposePtr( data);				}				i ++;				count--;			}			if ( chapterNameStringList != nil)				DisposeHandle( chapterNameStringList);		}	}	{		OSErr err =			List_Utilities_QSort( list, (Point){0, 0},				(Point){(**list).dataBounds.bottom - 1, 0},				CompareCellsByChapterIndex);			if ( err != noErr) SysBeep(20);	}	d->scenarioIndex = HUI_Control_GetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, d->scenarioIndex);	if ( d->scenarioIndex >= d->scenarioNumber)		d->scenarioIndex = d->scenarioNumber - 1;//	Window_SetControls_FromConditionIndex( d,//		GetWindowPtrFromDispatchWindowID( d->windowID), d->scenarioIndex + d->startConditionIndex);	GetAllData_error:		UseResFile( oldResRefNum);}static void ChapterString_NormalizeInPlace( StringPtr s){	long	offset = 0, i = 1;		while ( i <= s[0])	{		if ( s[i] != '\\')		{			if (( s[i] == '\r') || ( s[i] == '\n'))				s[i-offset] = ' ';			else				s[i-offset] = s[i];			i++;		} else		{//			s[i-offset] = ' ';			offset += 2;			i += 2;		}	}	s[0] -= offset;}static StringPtr Scenario_Editor_ChildWindow_NameMaker( Scenario_EditorWindowType *d,	StringPtr destString){	Str255	tString2;		if (( d == nil) || ( destString == nil)) return nil;		pstrcpy( destString, d->titlePrefix);	pstrcat( destString, "\p: <");	NumToString( d->scenarioIndex, tString2);	pstrcat( destString, tString2);	pstrcat( destString, "\p> ");	pstrcpy( tString2, d->scenarioName);	ChapterString_NormalizeInPlace( tString2);	if ( tString2[0] > 10)	{		tString2[0] = 10;		tString2[tString2[0]] = 'É';	}	pstrcat( destString, tString2);		return destString;}	static short CompareCellsByChapterIndex( Ptr cell_a, long length_a,	Ptr cell_b, long length_b){	Str255	id_string_a, id_string_b;	long	id_a, id_b;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, id_string_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, id_string_b, -1);	StringToNum( id_string_a, &id_a);	StringToNum( id_string_b, &id_b);	if ( id_a < id_b)	{		return 1;	} else if ( id_a > id_b)	{		return -1;	} else	{		return 0;	}}static pascal Boolean NullClickLoop( void){	BPMOWritePString("\pclick loop!\r");	return false;}static void StatusStringCallBack( long windowID, long resID, long stringNum){	Handle						windowData =									GetDispatchWindowDataHandle( windowID);	SignedByte					dataState;	Scenario_EditorWindowType	*d;	huiPlainControlParamType	dummyParam;#pragma unused( stringNum)		if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);	d = (Scenario_EditorWindowType *)*windowData;		d->scenario.scoreStringResID = resID;	dummyParam.master = d->mainMaster;	dummyParam.layer = 0;	dummyParam.cellx = kMain_Main_Cell_X;	dummyParam.celly = kMain_Main_Cell_Y;			SetScenarioField( d, &dummyParam, &d->scenario, kData_statusStringsField,						true);	HSetState( windowData, dataState);}static void MovieStringCallBack( long windowID, long resID, long stringNum){	Handle						windowData =									GetDispatchWindowDataHandle( windowID);	SignedByte					dataState;	Scenario_EditorWindowType	*d;	huiPlainControlParamType	dummyParam;#pragma unused( resID)		if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);	d = (Scenario_EditorWindowType *)*windowData;		d->scenario.movieNameStrNum = stringNum;	dummyParam.master = d->mainMaster;	dummyParam.layer = 0;	dummyParam.cellx = kMain_Main_Cell_X;	dummyParam.celly = kMain_Main_Cell_Y;			SetScenarioField( d, &dummyParam, &d->scenario, kData_movieNameField,						true);	SetScenarioField( d, &dummyParam, &d->scenario, kData_movieNameCheckBox,						true);							HSetState( windowData, dataState);}static void PlayerNameStringCallBack( long windowID, long resID, long stringNum){	Handle						windowData =									GetDispatchWindowDataHandle( windowID);	SignedByte					dataState;	Scenario_EditorWindowType	*d;	huiPlainControlParamType	dummyParam;		if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);	d = (Scenario_EditorWindowType *)*windowData;		d->scenario.player[d->whichPlayer].nameResID = resID;	d->scenario.player[d->whichPlayer].nameStrNum = stringNum;		dummyParam.master = d->mainMaster;	dummyParam.layer = 0;	dummyParam.cellx = kMain_Player_Cell_X;	dummyParam.celly = kMain_Player_Cell_Y;			SetScenarioField( d, &dummyParam, &d->scenario, kMain_Player_nameField,						true);			HSetState( windowData, dataState);}static void PrologueTextCallBack( long windowID, long resID){	Handle						windowData =									GetDispatchWindowDataHandle( windowID);	SignedByte					dataState;	Scenario_EditorWindowType	*d;	huiPlainControlParamType	dummyParam;		if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);	d = (Scenario_EditorWindowType *)*windowData;		d->scenario.prologueID = resID;		dummyParam.master = d->mainMaster;	dummyParam.layer = 0;	dummyParam.cellx = kMain_Main_Cell_X;	dummyParam.celly = kMain_Main_Cell_Y;			SetScenarioField( d, &dummyParam, &d->scenario, kData_prologueField,						true);	SetScenarioField( d, &dummyParam, &d->scenario, kData_prologueCheckBox,						true);							HSetState( windowData, dataState);}static void EpilogueTextCallBack( long windowID, long resID){	Handle						windowData =									GetDispatchWindowDataHandle( windowID);	SignedByte					dataState;	Scenario_EditorWindowType	*d;	huiPlainControlParamType	dummyParam;		if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);	d = (Scenario_EditorWindowType *)*windowData;		d->scenario.epilogueID = resID;		dummyParam.master = d->mainMaster;	dummyParam.layer = 0;	dummyParam.cellx = kMain_Main_Cell_X;	dummyParam.celly = kMain_Main_Cell_Y;			SetScenarioField( d, &dummyParam, &d->scenario, kData_epilogueField,						true);	SetScenarioField( d, &dummyParam, &d->scenario, kData_epilogueCheckBox,						true);		HSetState( windowData, dataState);}static short NoShipsText_ResID_GetFromChapterPlayerNumber( long chapterNumber,	long playerNumber){	return (kNoShipsTextIDOffset + (playerNumber *			kNoShipsTextPlayerNumOffset) + chapterNumber);}/* Initial_Editor_CallBack	We have to "fix" all relevant references to initial objects by index;	this means we have to scan through all:		-	initial objects; some specialty objects have subject and direct			overrides which are initial indexes; we have to fix those		-	initial objects' actions; which refer to initial objects in any			way				-	initial objects' actions; any object which is cretaed or whose			type is changed				-	scenario conditions				-	the actions scenario conditions invoke, including the objects			they create or change				-	brief points references*/static void Initial_Editor_CallBack( long dispatchID, long initialFirst,	long initialNum, long initialSelection, heraDataChangesType *changesList){	Handle						discreteData = nil,								windowData =									GetDispatchWindowDataHandle( dispatchID);//	SignedByte					dataState;	Scenario_EditorWindowType	*d;	scenarioInitialType			*initial;	long						i, number;#pragma unused ( initialSelection)		mAssert( windowData != nil);	if ( windowData == nil) return;				d = (Scenario_EditorWindowType *)*windowData;	if ( d->chooseOnly) return;		discreteData = HD_DiscreteData_GetNextOfType( d->heraFile, nil,											kHera_Object_Type);	d->scenario.initialFirst = initialFirst;	d->scenario.initialNum = initialNum;	// repeat for each change recorded	while ( changesList != nil)	{				// first we have to clear all the flags from the object's discrete data		discreteData = HD_DiscreteData_GetNextOfType( d->heraFile, nil, kHera_Object_Type);		while ( discreteData != nil)		{			((heraDataHeaderType *)*discreteData)->flags = 0;			discreteData = HD_DiscreteData_GetNextOfType( d->heraFile, discreteData,								kHera_Object_Type);		}				// we also have to clear flags from all actions		discreteData = HD_DiscreteData_GetNextOfType( d->heraFile, nil, kHera_Action_Type);		while ( discreteData != nil)		{			((heraDataHeaderType *)*discreteData)->flags = 0;			discreteData = HD_DiscreteData_GetNextOfType( d->heraFile, discreteData,								kHera_Action_Type);		}				d = (Scenario_EditorWindowType *)*windowData;		d->callBack_initialChange_index = changesList->index;		d->callBack_initialChange_number = changesList->number;		d->callBack_initialChange_action = changesList->action;				// step through all initial objects and do an object walk for each		// we have to jump through hoops to support the building of objects		// from various races and objects with non-fixed races in net		// scenarios				discreteData = HD_Find_Discrete_Data( d->heraFile, initialFirst, initialNum,			nil, kHera_Initial_Type);				mAssert( discreteData != nil);		if ( discreteData != nil)		{			number = HD_DiscreteData_GetElementNumber( discreteData,				kHera_Initial_Type);			for ( i = 0; i < number; i++)			{				long			baseObjectClass;				Handle			discreteObjectData = nil;				baseObjectType	*base;								initial = (scenarioInitialType *)					HD_DiscreteData_GetNthElement( discreteData,						kHera_Initial_Type, i);								mAssert( initial != nil);								discreteObjectData = HD_Find_Discrete_Data( d->heraFile, initial->type,					1, nil, kHera_Object_Type);								mAssert( discreteObjectData != nil);				if ( discreteObjectData != nil)				{					long		baseClass, baseRace;										base = (baseObjectType *)HD_DiscreteData_GetNthElement(						discreteObjectData, kHera_Object_Type, 0);										mAssert( base != nil);					baseClass = base->baseClass;					baseRace = base->baseRace;										if ( base->attributes & kCanAcceptBuild)					{						long	m;												for ( m = 0; m < kMaxTypeBaseCanBuild; m++)						{							initial = (scenarioInitialType *)								HD_DiscreteData_GetNthElement( discreteData,									kHera_Initial_Type, i);							if ( initial->canBuild[m] > 0)							{								discreteObjectData =										HD_DiscreteData_GetNextOfType(												d->heraFile, nil, kHera_Object_Type);															while ( discreteObjectData != nil)								{									initial = (scenarioInitialType *)										HD_DiscreteData_GetNthElement( discreteData,											kHera_Initial_Type, i);									base = (baseObjectType *)										HD_DiscreteData_GetNthElement(										discreteObjectData, kHera_Object_Type, 0);									d = (Scenario_EditorWindowType *)*windowData;									if (											(												base->baseClass ==													initial->canBuild[m]											)											&&											(												HD_IsRaceLegalForScenarioPlayer(												d->heraFile,  d->scenarioData, d->scenarioIndex,												 base->baseRace,												 -1)											)										)									{										HD_ObjectWalker( d->heraFile, 											((heraDataHeaderType *)*discreteObjectData)->id,											dispatchID,											Initial_Changes_ObjectWalker_CallBack);									}									discreteObjectData =										HD_DiscreteData_GetNextOfType( d->heraFile, 												discreteObjectData, kHera_Object_Type);								}							}						}					} else if ((!( initial->attributes & kFixedRace)) &&						( baseObjectClass > 0) && ( HD_IsScenarioNetworkable(							d->scenarioData, d->scenarioIndex)) && ( initial->owner >= 0))					{						// if initial object's race is not fixed, we have to run through						// all objects that match specified class						discreteObjectData =								HD_DiscreteData_GetNextOfType( d->heraFile, 										nil, kHera_Object_Type);						while ( discreteObjectData != nil)						{							initial = (scenarioInitialType *)								HD_DiscreteData_GetNthElement( discreteData,									kHera_Initial_Type, i);							base = (baseObjectType *)								HD_DiscreteData_GetNthElement(								discreteObjectData, kHera_Object_Type, 0);														d = (Scenario_EditorWindowType *)*windowData;							if (( base->baseClass == baseClass) &&								( HD_IsRaceLegalForScenarioPlayer( d->heraFile, 									 d->scenarioData, d->scenarioIndex,									 base->baseRace,									 initial->owner)))							{								HD_ObjectWalker( d->heraFile, 									((heraDataHeaderType *)*discreteObjectData)->id,									dispatchID,									Initial_Changes_ObjectWalker_CallBack);							}							discreteObjectData =								HD_DiscreteData_GetNextOfType(d->heraFile, 										discreteObjectData, kHera_Object_Type);						}					}									initial = (scenarioInitialType *)						HD_DiscreteData_GetNthElement( discreteData,							kHera_Initial_Type, i);					HD_ObjectWalker( d->heraFile, initial->type, dispatchID,						Initial_Changes_ObjectWalker_CallBack);				}								// we don't have to worry about initial object's				// initial target; already taken care of			}		}				// now we'll check the scenario conditions and all of the		// actions they invoke		discreteData = HD_Find_Discrete_Data( d->heraFile, d->scenario.conditionFirst,											d->scenario.conditionNum,											nil, kHera_Condition_Type);		//		mAssert( discreteData != nil);		if ( discreteData != nil)		{			number = HD_DiscreteData_GetElementNumber( discreteData,				kHera_Condition_Type);			for ( i = 0; i < number; i++)			{				Handle					discreteActionData = nil;				scenarioConditionType	*condition;								condition = (scenarioConditionType *)					HD_DiscreteData_GetNthElement( discreteData,						kHera_Condition_Type, i);								mAssert( condition != nil);								if ( changesList->action == -1)				{					if ( changesList->index == condition->subjectObject)					{						condition->subjectObject = -1;					} else if ( changesList->index < condition->subjectObject)					{						condition->subjectObject--;					}										if ( changesList->index == condition->directObject)					{						condition->directObject = -1;					} else if ( changesList->index < condition->directObject)					{						condition->directObject--;					}				} else if ( changesList->action == 1)				{					if ( changesList->index < condition->subjectObject)					{						condition->subjectObject++;					}										if ( changesList->index < condition->directObject)					{						condition->directObject++;					}				}								if ( condition->startVerb >= 0)				{					discreteActionData = HD_Find_Discrete_Data(d->heraFile, 						condition->startVerb, condition->verbNum, nil,						kHera_Action_Type);										HD_ObjectWalker_ActionWalker( d->heraFile, discreteActionData,						dispatchID, Initial_Changes_ObjectWalker_CallBack);				}			}		}				// last, we'll check the brief points		changesList = changesList->next;	}}static void Initial_Changes_ObjectWalker_CallBack( Handle discreteObjectData,	Handle discreteActionData, unsigned long userData){	Handle						windowData = nil;	Scenario_EditorWindowType	*d;	long						actionNumber, i;	objectActionType			*action = nil;#pragma unused (discreteObjectData)		if ( discreteActionData == nil) return;		actionNumber = HD_DiscreteData_GetElementNumber( discreteActionData,		kHera_Action_Type);	windowData = GetDispatchWindowDataHandle( userData);	d = (Scenario_EditorWindowType *)*windowData;	if ( d->chooseOnly) return;		for ( i = 0; i < actionNumber; i++)	{		action = (objectActionType *)HD_DiscreteData_GetNthElement(				discreteActionData,				kHera_Action_Type, i);				mAssert( action != nil);				if ( d->callBack_initialChange_action < 0)		{			if ( action->initialSubjectOverride ==					d->callBack_initialChange_index)			{				action->initialSubjectOverride = -1;			} else if ( action->initialSubjectOverride >					d->callBack_initialChange_index)			{				action->initialSubjectOverride--;			}			if ( action->initialDirectOverride ==					d->callBack_initialChange_index)			{				action->initialDirectOverride = -1;			} else if ( action->initialDirectOverride >					d->callBack_initialChange_index)			{				action->initialDirectOverride--;			}		} else if ( d->callBack_initialChange_action > 0)		{			if ( action->initialSubjectOverride >					d->callBack_initialChange_index)			{				action->initialSubjectOverride++;			}			if ( action->initialDirectOverride >					d->callBack_initialChange_index)			{				action->initialDirectOverride++;			}		}				if ( action->verb == kAssumeInitialObject)		{			if ( d->callBack_initialChange_action < 0)			{				if ( action->argument.assumeInitial.whichInitialObject ==						d->callBack_initialChange_index)				{					action->argument.assumeInitial.whichInitialObject = -1;				} else if ( action->argument.assumeInitial.whichInitialObject >						d->callBack_initialChange_index)				{					action->argument.assumeInitial.whichInitialObject--;				}			} else if ( d->callBack_initialChange_action > 0)			{				if ( action->argument.assumeInitial.whichInitialObject >						d->callBack_initialChange_index)				{					action->argument.assumeInitial.whichInitialObject++;				}			}		} else if (( action->verb == kAlter) &&					( action->argument.alterObject.alterType == kAlterHidden))		{			if ( d->callBack_initialChange_action < 0)			{				if ( d->callBack_initialChange_index <					action->argument.alterObject.minimum)				{					action->argument.alterObject.minimum--;				} else if (( d->callBack_initialChange_index >=					action->argument.alterObject.minimum) &&					( d->callBack_initialChange_index <=					(action->argument.alterObject.minimum +						action->argument.alterObject.range)))				{					action->argument.alterObject.range--;				}			} else if ( d->callBack_initialChange_action > 0)			{				if ( d->callBack_initialChange_index <					action->argument.alterObject.minimum)				{					action->argument.alterObject.minimum++;				} else if (( d->callBack_initialChange_index >=					action->argument.alterObject.minimum) &&					( d->callBack_initialChange_index <=					(action->argument.alterObject.minimum +						action->argument.alterObject.range)))				{					action->argument.alterObject.range++;				}			}		}	}}static void Condition_Editor_CallBack( long dispatchID, long conditionFirst,	long conditionNum, heraDataChangesType *changesList){	Handle						discreteData = nil,								windowData =									GetDispatchWindowDataHandle( dispatchID);	Scenario_EditorWindowType	*d;#pragma unused ( changesList)		mAssert( windowData != nil);	if ( windowData == nil) return;				d = (Scenario_EditorWindowType *)*windowData;	if ( d->chooseOnly) return;	d->scenario.conditionFirst = conditionFirst;	d->scenario.conditionNum = conditionNum;}static void Briefing_Editor_CallBack( long dispatchID, long briefFirst,	long briefNum){	Handle						discreteData = nil,								windowData =									GetDispatchWindowDataHandle( dispatchID);	Scenario_EditorWindowType	*d;		mAssert( windowData != nil);	if ( windowData == nil) return;				d = (Scenario_EditorWindowType *)*windowData;	if ( d->chooseOnly) return;	d->scenario.briefPointFirst = briefFirst;	d->scenario.briefPointNum = (d->scenario.briefPointNum & ~kScenarioBriefMask) |		briefNum;}static void NetRaceFlag_CallBack( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Scenario_EditorWindowType					*d;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Scenario_EditorWindowType *)*data;		if ( d->chooseOnly)	{		HSetState( data, dataState);		return;	}		d->scenario.player[d->whichPlayer].netRaceFlags = bits;	HU_HUIMenu_SetCheckFromBits( d->mainMaster, 0, kMain_Player_Cell_X,		kMain_Player_Cell_Y, kMain_Player_netRaceFlags, bits, 0, 15);		HSetState( data, dataState);}static void Starmap_Locator_Callback( long windowID, long x, long y){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Scenario_EditorWindowType		*d;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Scenario_EditorWindowType *)*data;	if ( d->chooseOnly)	{		HSetState( data, dataState);		return;	}		d->scenario.starMapH = x;	d->scenario.starMapV = y;		HSetState( data, dataState);	}static void Enable_Editing( Scenario_EditorWindowType *d, Boolean enable){	HUI_Cell_Set_Enabled( d->master, 0, kMain_Cell_X, kMain_Cell_Y, enable);}#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/OSErr Scenario_Editor_NewWindow( heraScenarioFileType *heraFile,	StringPtr titlePrefix, short resRefNum, long callerID,	Scenario_Editor_procPtr callBack, long *myID){	Rect						bounds;	CWindowPtr					newWindow;	ControlHandle				rootControl, aControl;	huiPlainControlParamType	buttonParam, textParam, groupParam;	huiPlainControlType			*hui;	huiMasterControlParamType	masterParam;	OSStatus					err;	Handle						data, strList, tStrList;	Scenario_EditorWindowType		*d;	long						maxWidth = 0;	long						windowID = -1, i;	huiCellParamType			cellParam;	Str255						s;	ListHandle					list;	Str255						title;	#pragma unused ( err, textParam, aControl)			// create the new window	data = NewHandle( sizeof( Scenario_EditorWindowType));	if ( data == nil) return memFullErr;		HLock( data);	d = (Scenario_EditorWindowType *)*data;		if ( titlePrefix != nil)	{		pstrcpy( title, titlePrefix);		pstrcat( title, "\p: Scenarios");	} else	{		pstrcpy( title, "\pScenarios");	}		SetRect( &bounds, 64, 64, 128, 128);	newWindow = NewDispatchWindow( &bounds, title, false,		kWindowDocumentProc, (WindowPtr)-1, false,		HandleEvent, 0,		&windowID);	SetDispatchWindowDataHandle( windowID, data);	d->windowID = windowID;		if ( myID != nil) *myID = windowID;		d->master = nil;	d->mainMaster = nil;	d->scenarioData = nil;	d->scenarioIndex = 0;	d->scenarioNumber = 0;	d->anyChanges = false;	d->resRefNum = resRefNum;	d->whichPlayer = 0;	d->lastAllocatedReferenceNum = 0;	d->heraFile = heraFile;	d->callBack = callBack;	d->callerID = callerID;	if ( titlePrefix == nil) d->titlePrefix[0] = 0;	else pstrcpy( d->titlePrefix, titlePrefix);		if ( d->heraFile->fileRefNum <= 0)		d->chooseOnly = true;	else		d->chooseOnly = false;		SetThemeWindowBackground( (WindowPtr)newWindow,		kThemeActiveDialogBackgroundBrush, true);	SetPortWindowPort( (WindowPtr)newWindow);	CreateRootControl( (WindowPtr)newWindow, &rootControl);	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kRowNum;	masterParam.colNum = kColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->master = HUI_MasterControl_New( nil, 0, 0, 0, &masterParam);		mAssert( d->master != nil);	if ( d->master == nil) return memFullErr;	d->master->tab[0][0].h = 112;	d->master->tab[0][0].hAlign = hui_halign_right;	cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, -1, 12, -1);	SetRect( &cellParam.inSpace, 0, 0, 0, 0);	cellParam.colSpan = 1;	cellParam.rowSpan = 2;	HUI_Cell_Set( 0, kMain_Cell_X, kMain_Cell_Y, &cellParam);	// set up list cell	SetRect( &cellParam.outSpace, 12, -1, -1, 5);	SetRect( &cellParam.inSpace, 3, -1, 3, 3);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_right;	cellParam.minMaxBounds.top = 100;	HUI_Cell_Set( 0, kList_Cell_X, kList_Cell_Y, &cellParam);	cellParam.minMaxBounds.top = 0;	cellParam.minMaxBounds.top = 0;		// set up list button cells	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.baseLine = gHera->smallFontSize;	cellParam.hAlign = hui_halign_center;	d->master->rowDontExpand[kList_Button_Cell_Y] = true;	HUI_Cell_Set( 0, kList_Button_Cell_X, kList_Button_Cell_Y, &cellParam);	cellParam.minMaxBounds.bottom = kHUI_Pixel_Max;	// set up buttons, general	buttonParam.master = d->master;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask | kControlUseJustMask;	buttonParam.fontStyle.font = kSmallFontNum;	buttonParam.fontStyle.size = kSmallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = teCenter;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;	buttonParam.flags = huiControlFlag_none;		if ( d->chooseOnly)		buttonParam.enabled = false;		// set up text, general		textParam.master = d->master;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = kControl_H_Space;//8;	textParam.space.top = 12;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = -1;	textParam.cellx = kMain_Cell_X;	textParam.celly = kMain_Cell_Y;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;	if ( d->chooseOnly) textParam.enabled = false;		// make selection list	buttonParam.enabled = true;		buttonParam.id = kList_ID;	buttonParam.minMaxBounds.left = 240;	buttonParam.minMaxBounds.right = 240;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;//200;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.bottom = 200;	buttonParam.cellx = kList_Cell_X;	buttonParam.celly = kList_Cell_Y;	buttonParam.special.listBox.ldesResID = 130;	// psuedo-column ldef	buttonParam.special.listBox.refCon = 133;		// psuedo-column params	buttonParam.flags = huiControlFlag_useCellV;	HUI_ListBox_New_LiteralP( &buttonParam);	if ( d->chooseOnly)		buttonParam.enabled = false;		buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// set up list buttons		buttonParam.id = kList_Add_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 9);	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.id = kList_Remove_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 10);	HUI_PushButton_New_LiteralP( &buttonParam);	// set up main sub-master	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kMain_Master_RowNum;	masterParam.colNum = kMain_Master_ColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 9, 6, 9);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->mainMaster = HUI_MasterControl_New( d->master, 0, kMain_Cell_X,		kMain_Cell_Y, &masterParam);	mAssert( d->mainMaster != nil);	if ( d->mainMaster == nil) return memFullErr;	HUI_Master_ShowLayer( d->mainMaster, 0);	// normal 1st column tab	d->mainMaster->tab[0][0].h = kLarge_Tab_Width;	d->mainMaster->tab[0][0].hAlign = hui_halign_right;	d->mainMaster->tab[0][1].h = kLarge_Tab_Width;	d->mainMaster->tab[0][1].hAlign = hui_halign_left;	// normal 2nd column tab	d->mainMaster->tab[0][2].h = kLarge_Tab_Width * 3;	d->mainMaster->tab[0][2].hAlign = hui_halign_right;	d->mainMaster->tab[0][3].h = kLarge_Tab_Width * 3;	d->mainMaster->tab[0][3].hAlign = hui_halign_left;		// special tab for same-sized controls at 1st column	d->mainMaster->tab[1][0].h = kLarge_Tab_Width;	d->mainMaster->tab[1][0].hAlign = hui_halign_right;	d->mainMaster->tab[1][1].h = kLarge_Tab_Width;	d->mainMaster->tab[1][1].hAlign = hui_halign_left;	// special tabs for same-sized controls at left margin & 2nd column	d->mainMaster->tab[2][0].h = 0;	d->mainMaster->tab[2][0].hAlign = hui_halign_void;	d->mainMaster->tab[2][1].h = kLarge_Tab_Width * 3;	d->mainMaster->tab[2][1].hAlign = hui_halign_void;	// set up main sub cells	cellParam.master = d->mainMaster;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, 0, 12, 0, 0);	SetRect( &cellParam.inSpace, -1, 30, -1, 11);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	HUI_Cell_Set( 0, kMain_Player_Cell_X, kMain_Player_Cell_Y, &cellParam);	SetRect( &cellParam.outSpace, 0, 0, 0, 0);	SetRect( &cellParam.inSpace, -1, -1, -1, 11);	HUI_Cell_Set( 0, kMain_Main_Cell_X, kMain_Main_Cell_Y, &cellParam);		textParam.master = d->mainMaster;	buttonParam.master = d->mainMaster;		// set up main main cell		textParam.cellx = kMain_Main_Cell_X;	textParam.celly = kMain_Main_Cell_Y;	buttonParam.cellx = kMain_Main_Cell_X;	buttonParam.celly = kMain_Main_Cell_Y;		// scenario data group	groupParam.master = d->mainMaster;	groupParam.visible = true;	groupParam.enabled = true;	groupParam.whichTabSet = -1;	groupParam.whichTab = -1;	groupParam.layer = 0;	groupParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;	groupParam.fontStyle.font = gHera->smallFontNum;	groupParam.fontStyle.size = gHera->smallFontSize;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;	groupParam.helpStringResID = -1;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;		groupParam.cellx = kMain_Main_Cell_X;	groupParam.celly = kMain_Main_Cell_Y;	groupParam.id = kMain_Main_ID_Offset;	groupParam.special.group.isSecondary = false;	GetIndString( groupParam.label, kStrResID, 9); // qualifiers	HUI_Group_New_LiteralP( &groupParam);		// player number		textParam.id = kMain_Main_playerNum - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 1);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kMain_Main_playerNum;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.space.left = 12;	HUI_EditText_New_LiteralP( &textParam);	textParam.space.left = kControl_H_Space;		// data: fixed angle		buttonParam.id = kData_fixedAngleCheckBox;	buttonParam.flags = huiControlFlag_none;// huiControlFlag_newLine;	GetIndString( buttonParam.label, kStrResID, 30);	buttonParam.whichTabSet = -1;//0;	buttonParam.whichTab = -1;//0;	HUI_CheckBox_New_LiteralP( &buttonParam);		textParam.id = kData_fixedAngleField;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = -1;//0;	textParam.space.left = 12;	textParam.whichTab = -1;//1;	HUI_EditText_New_LiteralP( &textParam);		textParam.minMaxBounds.left = 0;	textParam.space.left = kControl_H_Space;	// data: training only		buttonParam.id = kData_trainingOnlyCheckBox;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kStrResID, 31);	buttonParam.whichTabSet = -1;//0;	buttonParam.whichTab = -1;//2;	HUI_CheckBox_New_LiteralP( &buttonParam);	// chapter/*		textParam.id = kMain_Main_levelNameStrNum - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 2);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = -1;//0;	textParam.whichTab = -1;//2;	textParam.space.left = kControl_H_Space;//8;	HUI_StaticText_New_LiteralP( &textParam);	textParam.id = kMain_Main_levelNameStrNum;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.whichTabSet = -1;//0;	textParam.whichTab = -1;//3;		tStrList = GetStringList( 4600);	strList = NewStringList();	if (( strList != nil) && ( tStrList != nil))	{		for ( i = 1; i <= StringListSize( tStrList); i += 1)		{			RetrieveIndString( tStrList, i, s);			ChapterString_NormalizeInPlace( s);			StringListAppend( strList, s);		}				StringListAppend( strList, "\p-");		StringListAppend( strList, "\pEdit This ListÉ");		textParam.special.menuStrList.strList = strList;		textParam.special.menuStrList.menuID = HU_GetNewMenuID();//999 + i;		textParam.minMaxBounds.right = kPopup_Field_Width;//kHUI_Pixel_Max;		textParam.minMaxBounds.left = 0;		HUI_PopupButton_New_StrList( &textParam);		textParam.minMaxBounds.right = kHUI_Pixel_Max;	}	if ( tStrList != nil) ReleaseResource( tStrList);	if ( strList != nil) DisposeHandle( strList);*/	// * chapter name	textParam.id = kData_chapterName - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 28);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kData_chapterName;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextHugeFieldWidth;	textParam.minMaxBounds.top = 24;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	hui = HUI_EditText_New_LiteralP( &textParam);	if ( hui != nil) SetEditTextKeyStandardFilter_AllowCR( hui->generic.control);//	HUI_ScrollText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;		// set up player cell	textParam.celly = kMain_Player_Cell_Y;	buttonParam.celly = kMain_Player_Cell_Y;		// set up which player group		groupParam.master = d->mainMaster;	groupParam.visible = true;	groupParam.enabled = true;	groupParam.whichTabSet = -1;	groupParam.whichTab = -1;	groupParam.layer = 0;	groupParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;	groupParam.fontStyle.font = gHera->smallFontNum;	groupParam.fontStyle.size = gHera->smallFontSize;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;	groupParam.helpStringResID = -1;	groupParam.id = kMain_Player_Which_Player;	groupParam.cellx = kMain_Player_Cell_X;	groupParam.celly = kMain_Player_Cell_Y;	groupParam.special.menuStrList.strList = GetStringList( 8029);	groupParam.fontStyle.style = gHera->smallFontStyle;	if ( groupParam.special.menuStrList.strList != nil)	{		groupParam.special.menuStrList.menuID = HU_GetNewMenuID();		groupParam.special.menuStrList.multiSelect = false;		SetRect( &groupParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);		groupParam.label[0] = 0;		HUI_Group_PopupButton_New_StrList( &groupParam);		ReleaseResource( groupParam.special.menuStrList.strList);	}		// player type		textParam.id = kMain_Player_playerType - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 3);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);	textParam.id = kMain_Player_playerType;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 1;		strList = GetStringList( 8030);	if ( strList != nil)	{		textParam.special.menuStrList.strList = strList;		textParam.special.menuStrList.menuID = HU_GetNewMenuID();//999 + i;		textParam.minMaxBounds.right = kHUI_Pixel_Max;		textParam.minMaxBounds.left = 0;		HUI_PopupButton_New_StrList( &textParam);		ReleaseResource( strList);		textParam.minMaxBounds.right = kHUI_Pixel_Max;	}	// player: edit no ships button		buttonParam.id = kMain_Player_editNoShipsButton;	GetIndString( buttonParam.label, kStrResID, 40);	buttonParam.flags = huiControlFlag_none;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	HUI_PushButton_New_LiteralP( &buttonParam);		// player race		textParam.id = kMain_Player_playerRace - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 4);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);	/*	textParam.id = kMain_Player_playerRace;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);*/	// create race str list -- save for use with net race flags	tStrList = HRT_Resource_GetHandle( d->heraFile, 'STR#', 4201, nil, nil);		//GetStringList( 4201);	d->raceStrList = NewStringList();	if (( tStrList != nil) && ( d->raceStrList != nil))	{		for ( i = 1; i <= StringListSize( tStrList); i += 4)		{			StringListAppend( d->raceStrList, RetrieveIndString( tStrList, i, s));		}//		AddBitPopUp( &textParam, &buttonParam, kData_netRaceFlags, kStrResID, 20,//			false, 2, strList);	}//	if ( strList != nil) DisposeHandle( strList);	if ( tStrList != nil) DisposeHandle( tStrList); //ReleaseResource( tStrList);		if ( d->raceStrList != nil)	{			textParam.special.menuStrList.strList = d->raceStrList;		textParam.special.menuStrList.menuID = HU_GetNewMenuID();		textParam.minMaxBounds.right = kHUI_Pixel_Max;		textParam.minMaxBounds.left = 0;				textParam.id = kMain_Player_raceMenu;		textParam.flags = huiControlFlag_none;		textParam.label[0] = 0;		textParam.whichTabSet = 0;		textParam.whichTab = 1;		HUI_PopupButton_New_StrList( &textParam);	}		// player earning		textParam.id = kMain_Player_earningPower - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 5);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = -1;//0;	textParam.whichTab = -1;//2;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kMain_Player_earningPower;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = -1;//0;	textParam.whichTab = -1;//3;	HUI_EditText_New_LiteralP( &textParam);		// player name res id	/*	textParam.id = kMain_Player_nameResID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 6);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kMain_Player_nameResID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		// player name index		textParam.id = kMain_Player_nameStrNum - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 7);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kMain_Player_nameStrNum;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 3;	HUI_EditText_New_LiteralP( &textParam);*/		// player name		textParam.id = kMain_Player_nameField - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 41);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kMain_Player_nameField;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	HUI_StaticText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;		// player: name choose button	buttonParam.id = kMain_Player_nameChooseButton;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 37);	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 3;	HUI_PushButton_New_LiteralP( &buttonParam);	buttonParam.enabled = true;	// player: net races bit pop-up	if ( d->raceStrList != nil)	{		AddBitPopUp( &textParam, &buttonParam, kMain_Player_netRaceFlags,			kStrResID, 20, true, 0, d->raceStrList);//		DisposeHandle( strList);//		strList = nil;	}	if ( d->chooseOnly)		buttonParam.enabled = false;		// set up data cell	textParam.celly = kMain_Main_Cell_Y;	buttonParam.celly = kMain_Main_Cell_Y;		// data: edit initial	buttonParam.enabled = true;		buttonParam.id = kData_initialEdit;	buttonParam.flags = (huiControlFlagType)((int)huiControlFlag_newLine | (int)huiControlFlag_useTabMaxWidth);	GetIndString( buttonParam.label, kStrResID, 8);	buttonParam.whichTabSet = 2;//1;	buttonParam.whichTab = 0;//1;	HUI_PushButton_New_LiteralP( &buttonParam);		// data: edit conditioins	buttonParam.id = kData_conditionEdit;	buttonParam.flags = (huiControlFlagType)( //(int)huiControlFlag_newLine |		(int)huiControlFlag_useTabMaxWidth);	GetIndString( buttonParam.label, kStrResID, 10);	buttonParam.whichTabSet = 2;//1;	buttonParam.whichTab = 1;//1;	HUI_PushButton_New_LiteralP( &buttonParam);		// data: edit briefing	buttonParam.id = kData_briefPointEdit;	buttonParam.flags = (huiControlFlagType)((int)huiControlFlag_newLine | (int)huiControlFlag_useTabMaxWidth);	GetIndString( buttonParam.label, kStrResID, 12);	buttonParam.whichTabSet = 2;//1;	buttonParam.whichTab = 0;//1;	HUI_PushButton_New_LiteralP( &buttonParam);		// data: set star map	buttonParam.id = kData_starMap_setButton;	buttonParam.flags = (huiControlFlagType)( //(int)huiControlFlag_newLine |		(int)huiControlFlag_useTabMaxWidth);	GetIndString( buttonParam.label, kStrResID, 21);	buttonParam.whichTabSet = 2;//1;	buttonParam.whichTab = 1;//1;	HUI_PushButton_New_LiteralP( &buttonParam);	if ( d->chooseOnly)		buttonParam.enabled = false;			// data movie name	/*	textParam.id = kData_movieNameStrNum - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 14);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);	textParam.id = kData_movieNameStrNum;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 1;		strList = GetStringList( 4500);	if ( strList != nil)	{		textParam.special.menuStrList.strList = strList;		textParam.special.menuStrList.menuID = HU_GetNewMenuID();		textParam.minMaxBounds.right = kHUI_Pixel_Max;		textParam.minMaxBounds.left = 0;				HUI_PopupButton_New_StrList( &textParam);		ReleaseResource( strList);		textParam.minMaxBounds.right = kHUI_Pixel_Max;	}*/	// movie name checkbox	buttonParam.id = kData_movieNameCheckBox;	buttonParam.flags = huiControlFlag_newLine;	GetIndString( buttonParam.label, kStrResID, 14);	buttonParam.minMaxBounds.left = 0;	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 0;	HUI_CheckBox_New_LiteralP( &buttonParam);	// move name field		textParam.id = kData_movieNameField;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.space.left = 12;	HUI_StaticText_New_LiteralP( &textParam);	textParam.space.left = kControl_H_Space;		// data: move name choose button		buttonParam.id = kData_movieChooseButton;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 29);	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 3;	HUI_PushButton_New_LiteralP( &buttonParam);		// data: par ratio		textParam.id = kData_parKillRatio - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 15);	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kData_parKillRatio;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		//  data: par kills		textParam.id = kData_parKills - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 16);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kData_parKills;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 3;	HUI_EditText_New_LiteralP( &textParam);		// data: par losses		textParam.id = kData_parLosses - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 17);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kData_parLosses;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		//  data: par time		textParam.id = kData_parTime - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 18);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kData_parTime;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 3;	HUI_EditText_New_LiteralP( &textParam);		// data: start time		textParam.id = kData_startTime - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 19);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kData_startTime;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		// data: net races/*		tStrList = GetStringList( 4201);	strList = NewStringList();	if (( tStrList != nil) && ( strList != nil))	{		for ( i = 1; i <= StringListSize( tStrList); i += 4)		{			StringListAppend( strList, RetrieveIndString( tStrList, i, s));		}		AddBitPopUp( &textParam, &buttonParam, kData_netRaceFlags, kStrResID, 20,			false, 2, strList);	}	if ( strList != nil) DisposeHandle( strList);	if ( tStrList != nil) ReleaseResource( tStrList);		// data: prlogue id		textParam.id = kData_prologueID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 24);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kData_prologueID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		//  data: epilogue id		textParam.id = kData_epilogueID - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 25);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kData_epilogueID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 3;	HUI_EditText_New_LiteralP( &textParam);*/	// data: song id		textParam.id = kData_songID - 1;	textParam.flags = huiControlFlag_none;//huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 26);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;//0;	textParam.whichTab = 2;//0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kData_songID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 3;//1;	HUI_EditText_New_LiteralP( &textParam);		textParam.minMaxBounds.left = 0;	// data: prologue checkBox		buttonParam.id = kData_prologueCheckBox;	buttonParam.flags = huiControlFlag_newLine;	GetIndString( buttonParam.label, kStrResID, 32);	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 0;	HUI_CheckBox_New_LiteralP( &buttonParam);		// data: prologue text field (id & title)		textParam.id = kData_prologueField;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_StaticText_New_LiteralP( &textParam);		textParam.minMaxBounds.left = 0;	// data: prologue choose button	buttonParam.id = kData_prologueChooseButton;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 33);	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 3;	HUI_PushButton_New_LiteralP( &buttonParam);		// data: epilogue checkBox		buttonParam.id = kData_epilogueCheckBox;	buttonParam.flags = huiControlFlag_newLine;	GetIndString( buttonParam.label, kStrResID, 34);	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 0;	HUI_CheckBox_New_LiteralP( &buttonParam);		// data: epilogue text field (id & title)		textParam.id = kData_epilogueField;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_StaticText_New_LiteralP( &textParam);		textParam.minMaxBounds.left = 0;	// data: epilogue choose button	buttonParam.id = kData_epilogueChooseButton;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 35);	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 3;	HUI_PushButton_New_LiteralP( &buttonParam);		// data: statusStrings label		textParam.id = kData_statusStringsField - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 36);	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		// data: statusStrings text field (id & title)		textParam.id = kData_statusStringsField;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_StaticText_New_LiteralP( &textParam);		textParam.minMaxBounds.left = 0;	// data: statusStrings choose button	buttonParam.id = kData_statusStringsChooseButton;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 37);	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 3;	HUI_PushButton_New_LiteralP( &buttonParam);		//  data: score str id	/*	textParam.id = kData_scoreStringResID - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 27);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kData_scoreStringResID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 3;	HUI_EditText_New_LiteralP( &textParam);*/	strList = GetStringList( kHera_DefaultMainButtonStrResID);	if ( strList != nil)	{		HUI_Main_Buttons_H_Setup( d->master, 0,			kSeparator_Cell_X, kColNum, kSeparator_Cell_Y, 1,				true, strList);				ReleaseResource( strList);	}		GetAllData( d);		d->scenarioIndex =  HUI_Control_SetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->scenarioIndex);	list = HUI_List_Get( d->master, 0, kList_Cell_X, kList_Cell_Y, kList_ID);	if ( list != nil)	{		d->scenarioIndex = PsuedoColumn_List_GetIndex( list, 0);		if ( d->scenarioIndex < 0) d->scenarioIndex = 0;	}		ShowWindow( (WindowPtr)newWindow);	HUI_Master_Layout( d->master, (Point){0, 0}, (Point){0, 0});		Window_SetControls_FromScenarioIndex(		d, newWindow, d->scenarioIndex);	HUI_Master_ShowLayer( d->master, 0);	if ( d->scenarioNumber <= 0) Enable_Editing( d, false);		HUnlock( data);	return noErr;}