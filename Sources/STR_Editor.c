/******************************************\|**| STR_Editor.c\******************************************/#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Window Dispatch.h"#include "Control Utilities.h"#include "Hewey.h"#include "Hewey_Main.h"#include "Hewey_Layout.h"#include "Hewey_Utilities.h"#include "str_bp.h"#include "Set Font By String.h"#include "strlist.h"#include "Hewey_Helpers.h"#include "BP_Error.h"#include "Assert.h"#include "BPMacOutput.h"#include "Hera_Global.h"#include "Hera_Utilities.h"#include "Hera_ResourceTracker.h"#include "PsuedoColumn_Utilities.h"#include "List_Utilities.h"#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/#include "STR_Editor.h"#include "Button_Window.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kLarge_Tab_Width				80//112#define	kEditTextBigFieldWidth			150#define	kEditTextFieldWidth				38#define	kEditTextSmallFieldWidth		16#define	kEditTextHugeFieldWidth			((kLarge_Tab_Width * 2) + kEditTextFieldWidth)// 150#define	kPopup_Field_Width				150#define	kControl_H_Space				8#define	kColNum							2#define	kRowNum							6#define	kStrData_Cell_X					1#define	kStrData_Cell_Y					0#define	kStrData_ID_Offset				100#define	kStrContent_TextTitle			( kStrData_ID_Offset + 4)#define	kStrContent_TextID				( kStrData_ID_Offset + 6)#define	kStrContent_Cell_X				1#define	kStrContent_Cell_Y				2#define	kStrContent_ID_Offset			500#define	kStrContent_Text				(kStrContent_ID_Offset + 2)#define	kStrContent_Length				(kStrContent_ID_Offset + 4)#define	kList_ID						6#define	kList_Cell_X					0#define	kList_Cell_Y					0#define	kList_Button_Cell_X				0#define	kList_Button_Cell_Y				3#define	kList_Button_ID_Offset			300#define	kList_Remove_Button_ID			(kList_Button_ID_Offset + 2)#define	kList_Add_Button_ID				(kList_Button_ID_Offset + 4)#define	kList_SortBy_Menu_ID			(kList_Button_ID_Offset + 6)#define	kStringList_ID					8#define	kStringList_Cell_X				1#define	kStringList_Cell_Y				1#define	kStringList_Button_Cell_X		1#define	kStringList_Button_Cell_Y		3#define	kStringList_Button_ID_Offset	400#define	kStringList_Remove_Button_ID	(kStringList_Button_ID_Offset + 2)#define	kStringList_Add_Button_ID		(kStringList_Button_ID_Offset + 4)#define	kStringList_SortBy_Menu_ID		(kStringList_Button_ID_Offset + 6)#define	kSeparator_Cell_X				0#define	kSeparator_Cell_Y				4#define	kSeparator_ID					200#define	kButton_Cell_X					0#define	kButton_Cell_Y					5#define	kOK_Button_ID					1#define	kCancel_Button_ID				2#define	kRevert_Button_ID				3#define	kSmallFontSize					gHera->smallFontSize#define	kSmallFontNum					gHera->smallFontNum#define	kLargeFontNum					gHera->bigFontNum;#define kLargeFontSize					gHera->bigFontSize;#define	kStrResID						8034#define	kSortByID						1#define	kSortByName						2#pragma mark _macros_/* - macros*******************************************/#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/typedef struct STR_EditorWindowType{	heraScenarioFileType			*heraFile;	huiMasterControlType			*master;	long							windowID;	short							resRefNum;	short							index;	short							stringIndex;	short							currentOriginalResID;	long							currentReferenceNum;	long							lastAllotedReferenceNum;	long							sortBy;	long							dragTo;	long							dragFrom;	Handle							currentStringList;	Boolean							chooseRes;	Boolean							chooseButton;	Boolean							isModal;	Boolean							chooseOnly;	short							theResID;	long							columnFix;	long							callerID;	STR_Editor_Callback_procPtr		callBack;} STR_EditorWindowType;#pragma mark 본EXTERNAL GLOBALS본/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark 본PRIVATE GLOBALS본/******************************************\|**| private globals\******************************************/#pragma mark 본PRIVATE PROTOTYPES본/******************************************\|**| private function prototypes\******************************************/static Boolean HandleEvent( EventRecord *, CWindowPtr, long, long);static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID);static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID);static void OK_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID);static void OK_Button( STR_EditorWindowType *d);static void Cancel_Button( STR_EditorWindowType *d);static Boolean UpdateListSelection( STR_EditorWindowType *d, Boolean forceUpdate);static Boolean UpdateStringListSelection( STR_EditorWindowType *d, Boolean forceUpdate);static OSErr ChangeWhichString( STR_EditorWindowType *d, Boolean checkFirst);static void KeepChangedString( STR_EditorWindowType *d);static void AddNewString( STR_EditorWindowType *d);static void RemoveString( STR_EditorWindowType *d);static void SetUpList( STR_EditorWindowType *d);static void SetUpStringSelectionList( STR_EditorWindowType *d, Boolean draw);static void Revert_Button( STR_EditorWindowType *d);static OSErr ChangeWhichStringList( STR_EditorWindowType *d, Boolean checkFirst);static short GetCellData( STR_EditorWindowType *d, short stringListIndex,	long *referenceNumber, StringPtr title);static void KeepChangedStringList( STR_EditorWindowType *d);static void AddNewStringList( STR_EditorWindowType *d);static void DeleteStringList( STR_EditorWindowType *d);static OSErr SortStringListList( STR_EditorWindowType *d, Boolean draw);static short CompareCellsByName( Ptr cell_a, long length_a, Ptr cell_b, long length_b);static short CompareCellsByID( Ptr cell_a, long length_a, Ptr cell_b, long length_b);static Boolean IsIDStringListLegal( STR_EditorWindowType *d, short *resID);static void UpdateLengthField( STR_EditorWindowType *d, Boolean draw);static void StringList_Click( CWindowPtr whichWindow, Point where,	STR_EditorWindowType *d, ControlHandle aControl);pascal Boolean NullClickLoop( void);#pragma mark 본PRIVATE FUNCTIONS본/******************************************\|**| private functions\******************************************/static Boolean HandleEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID, long command){	switch( command)	{		case kWDCloseWindowCommand:			break;				case kWDProcessEventCommand:			return( ProcessEvent( theEvent, whichWindow, dispatchID));			break;				case kWDSaveWindowCommand:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these strings?",										"\pBefore saving, the STR Editor "										"must be closed. Click Cancel to "										"abort the save.", nil, nil))				{					OK_Button_From_WindowID( whichWindow, dispatchID);				} else				{					gHera->currentSave = nil;				}			}			return false;			break;				case kWD_Close_ForQuit_Command:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these strings?",										"\pBefore quitting, the STR Editor "										"must be closed. Click Cancel to "										"abort the quit.", nil, nil))				{					OK_Button_From_WindowID( whichWindow, dispatchID);				} else				{					gHera->currentSave = nil;					return true;				}			}			return false;			break;				case kWDProcessMenuChoiceCommand:			{				GrafPtr	oldPort;				Boolean	result = false;								GetPort( &oldPort);				SetPortWindowPort( whichWindow);												result = Generic_ProcessMenuChoiceCommand(					(unsigned long)theEvent,					whichWindow, dispatchID);									SetPort( oldPort);								return( result);			}			break;			}	return false;}static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Boolean							result = false;	ControlHandle					aControl, oldControl;	short							whichPart, oldValue;	WindowPtr						scratchWindow;	Point							where;	char							whichChar;	GrafPtr							oldPort;	OSStatus						err;	STR_EditorWindowType				*d;		if ( data == nil) return false;	if ( theEvent == nil) return false;		dataState = HGetState( data);	HLock( data);	d = (STR_EditorWindowType *)*data;		if ( theEvent == nil) goto ProcessEvent_Return;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);		switch( theEvent->what)	{		case nullEvent:			IdleControls( (WindowPtr)whichWindow);						result = true;			break;					case updateEvt:				BeginUpdate ((WindowPtr)whichWindow);/*			SetPort( (WindowPtr)whichWindow);			CalcVis( (WindowPtr)whichWindow);			UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);*/			HU_GenericUpdateEventHandler( whichWindow);			EndUpdate ((WindowPtr)whichWindow);			result = true;			break;		case activateEvt:		{			Boolean	isActive = ((theEvent->modifiers & activeFlag) != 0);						if ( isActive)			{				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_scenarioFile_refNum);			}		}			// result != true so dispatch window will handle activation			// of controls etc.			break;					case mouseDown:			whichPart = FindWindow (theEvent->where, &scratchWindow);			switch( whichPart)			{				case inGrow:/*					{						Rect	growRect;						long	newSize;//						growRect = qd.screenBits.bounds;						C2C_ScreenBits_GetBounds( &growRect);						growRect.top = growRect.left = 120;						newSize = GrowWindow((WindowPtr)whichWindow,							theEvent->where ,&growRect);						if (newSize != 0)						{							SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,								(((newSize) >> 16) & 0xFFFF), true );							EraseRect(&whichWindow->portRect);							InvalRect( &whichWindow->portRect);						}					}*/					HU_GenericGrowWindow( whichWindow, theEvent->where);					result = true;					break;								case inContent:					where = theEvent->where;					scratchWindow = WD_FrontWindow();					if ( whichWindow != (CWindowPtr)scratchWindow)					{						goto ProcessEvent_Return;					}					SetPortWindowPort( (WindowPtr)whichWindow);					GlobalToLocal( &where);					whichPart = FindControl( where, (WindowPtr)whichWindow,						&aControl);					if ( aControl == nil)						goto ProcessEvent_Return;					oldValue = GetControlValue( aControl);					err = GetKeyboardFocus( (WindowPtr)whichWindow, &oldControl);					if (( err == noErr) && ( oldControl != aControl))					{						SetKeyboardFocus( (WindowPtr)whichWindow, aControl, whichPart);					}					if ( whichPart != 0)					{						huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);//						whichPart = HandleControlClick ( aControl, where,//							theEvent->modifiers, (ControlActionUPP)-1//nil//							);							if ( !ListBox_Appearance_1_0_1_Hack( aControl, where,									&whichPart))						{							whichPart = HUI_Control_Click_Handle( hui, where,								theEvent->modifiers);														}						if ( whichPart != kControlNoPart) switch( hui->generic.id)						{							case kOK_Button_ID:								result = true;								OK_Button( d);								data = nil;								goto ProcessEvent_Return;								break;														case kCancel_Button_ID:								Cancel_Button( d);								data = nil;								result = true;								goto ProcessEvent_Return;								break;														case kRevert_Button_ID:								Revert_Button( d);								break;															case kList_Add_Button_ID:								AddNewStringList( d);								UpdateListSelection( d, false);								SortStringListList( d, true);								d->index =  HUI_Control_GetListValue(									d->master, 0, kList_Cell_X, kList_Cell_Y,									kList_ID, d->index);								SetUpStringSelectionList( d, true);								UpdateStringListSelection( d, false);								result = true;								break;														case kList_Remove_Button_ID:								if ( HU_Confirm_Delete("\pAre you sure you "									"want to delete this string list?",										theEvent->modifiers))								{									DeleteStringList( d);									ChangeWhichStringList( d, false);								}								result = true;								break;															case kList_ID:								UpdateListSelection( d, false);								result = true;								break;														case kStringList_ID:								UpdateStringListSelection( d, false);								StringList_Click( whichWindow, where, d, aControl);								result = true;								break;							case kList_SortBy_Menu_ID:								oldValue = d->sortBy;																d->sortBy = HUI_Control_GetValueShort(									d->master, 0, kList_Button_Cell_X,									kList_Button_Cell_Y, kList_SortBy_Menu_ID);																	if ( d->sortBy != oldValue)								{									SortStringListList( d, true);								}								break;														case kStringList_Add_Button_ID:								AddNewString( d);								UpdateStringListSelection( d, false);								break;														case kStringList_Remove_Button_ID:								RemoveString( d);								break;															default:								break;						}					} else // not in control					{						where = theEvent->where;						GlobalToLocal( &where);					}			}			break;					case keyDown:		case autoKey:			whichChar = theEvent->message & charCodeMask;			whichPart = kControlNoPart;						err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);			if (( err == noErr) && ( aControl != nil))			{				BPMOWritePString("\pkeyCodeMask: ");				BPMOWriteLong( (theEvent->message & keyCodeMask)>>16);				BPMOWritePString("\p\tcharCodeMask:");				BPMOWriteLong( theEvent->message & charCodeMask);				BPMOWritePString("\p\r");				whichPart = HandleControlKey( aControl,					(theEvent->message & keyCodeMask)>>16,					theEvent->message & charCodeMask, theEvent->modifiers);								if ( whichPart != kControlNoPart) result = true;								{					huiGenericControlType *hui =						(huiGenericControlType *)CU_GetControlReference( aControl);										if ( hui->kind != hui_ScrollTextControl) whichPart =						kControlNoPart;										switch( hui->id)					{						case kList_ID:							UpdateListSelection( d, false);							break;												case kStringList_ID:							UpdateStringListSelection( d, false);							break;												case kStrContent_Text:							UpdateLengthField( d, true);							whichPart = kControlEditTextPart;							break;					}				}			}						{				if (((whichChar=='\r') && ( whichPart == kControlNoPart))					 || (whichChar==0x3))				{					// ok					long			soon = TickCount()+5;										aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,						kButton_Cell_Y, kOK_Button_ID);					if ( aControl != nil)					{						ActivateControl( aControl);						while ( TickCount() < soon){ /* do nothing */}						DeactivateControl( aControl);						result = true;						OK_Button( d);						data = nil;						goto ProcessEvent_Return;					}				} else if ((whichChar==0x1b) || ((whichChar=='.') && (theEvent->modifiers & cmdKey)))				{					// cancel					long			soon = TickCount()+5;										aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,						kButton_Cell_Y, kCancel_Button_ID);					if ( aControl != nil)					{						ActivateControl( aControl);						while ( TickCount() < soon){ /* do nothing */}						DeactivateControl( aControl);												Cancel_Button( d);						data = nil;						result = true;						goto ProcessEvent_Return;					}				} else if ( whichChar == '\t')				{					if ( theEvent->modifiers & shiftKey)						ReverseKeyboardFocus( (WindowPtr)whichWindow);					else					{						AdvanceKeyboardFocus( (WindowPtr)whichWindow);					}					result = true;					break;				} else if (( whichChar == 0x08) && ( !d->chooseOnly))				{					huiPlainControlType	*hui = nil;					err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);					hui = (huiPlainControlType	*)CU_GetControlReference( aControl);					if ( hui != nil)					{						if ( hui->generic.id == kList_ID)						{							if ( HU_Confirm_Delete("\pAre you sure you "								"want to delete this string list?",								theEvent->modifiers))							{								DeleteStringList( d);								ChangeWhichStringList( d, false);							}						} else if ( hui->generic.id == kStringList_ID)						{							if ( HU_Confirm_Delete("\pAre you sure you "								"want to delete this string?",								theEvent->modifiers))								RemoveString( d);						}					}					result = true;				}			}			break;	}		ProcessEvent_Return:	SetPort( oldPort);	if ( data != nil)		HSetState( data, dataState);	return( result);	}static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Boolean	result = false;		result = Generic_ProcessMenuChoiceCommand( menuData, whichWindow,												dispatchID);	return result;}static void OK_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	STR_EditorWindowType			*d;#pragma unused( whichWindow)	if ( data == nil) return;		dataState = HGetState( data);	HLock( data);	d = (STR_EditorWindowType *)*data;	OK_Button( d);	// data has been deleted; window is closed}static void OK_Button( STR_EditorWindowType *d){	short		oldResRefNum;		mAssert ( d != nil);	if ( !UpdateListSelection( d, true)) return;		oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);		if ( d->isModal) gHera->modalMode--;	if ( d->callBack != nil)		d->callBack( d->callerID,		HUI_Control_GetTextItemLong( d->master, 0, kStrData_Cell_X - d->columnFix,			kStrData_Cell_Y, kStrContent_TextID),		d->stringIndex + 1);			HUI_MasterControl_Delete( d->master);	CloseDispatchWindow( d->windowID);	UseResFile( oldResRefNum);}static void Cancel_Button( STR_EditorWindowType *d){	if ( d->isModal) gHera->modalMode--;	HUI_MasterControl_Delete( d->master);	CloseDispatchWindow( d->windowID);}static void Revert_Button( STR_EditorWindowType *d){	CWindowPtr whichWindow = GetWindowPtrFromDispatchWindowID( d->windowID);		if ( whichWindow == nil) return;	if ( !Button_Window_Modal( "\pRevert this STR# resource?",							"\pClick Revert to restore this STR# resource to its "							"previous state. Click Cancel to "							"keep it as it is.", "\pRevert", nil))		return;	ChangeWhichStringList( d, false);}static Boolean UpdateListSelection( STR_EditorWindowType *d, Boolean forceUpdate){	long	oldValue, newValue;	short	resID;		if ( !d->chooseRes)	{		ChangeWhichStringList( d, true);		return true;	}		oldValue = d->index;	newValue =  HUI_Control_GetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->index);	if (( oldValue != newValue) || ( forceUpdate))	{				if ( IsIDStringListLegal( d, &resID))			ChangeWhichStringList( d, true);		else		{			d->index =  HUI_Control_SetListValue(					d->master, 0, kList_Cell_X, kList_Cell_Y,					kList_ID, oldValue);			HUI_Control_SetFocus( d->master, 0,				kStrData_Cell_X - d->columnFix, kStrData_Cell_Y, kStrContent_TextID);			BP_UserError_Literal("Illegal value",				"%s%d%s", "The resource ID ", resID,				" is already in use. Please enter a"				" different ID.");			return false;		}	}		return true;}static Boolean UpdateStringListSelection( STR_EditorWindowType *d, Boolean forceUpdate){	long	oldValue, newValue;		oldValue = d->stringIndex;	newValue =  HUI_Control_GetListValue(			d->master, 0, kStringList_Cell_X - d->columnFix, kStringList_Cell_Y,			kStringList_ID, d->stringIndex);	if (( oldValue != newValue) || ( forceUpdate))	{		ChangeWhichString( d, true);	}		return true;}static void AddNewStringList( STR_EditorWindowType *d){	long			dataLength;	ControlHandle	aControl;	ListHandle		list;	Ptr				data = nil;	Str255			ids;	Point			cell;	short			id;		mAssert( d != nil);		// 1st get our current id	id = GetCellData( d, d->index, nil, nil);		if ( d->currentStringList != nil)	{		DisposeHandle( d->currentStringList);		d->currentStringList = nil;	}	d->currentStringList = NewStringList();	HRT_AddNewResource( d->heraFile, d->currentStringList, 'STR#', &id, "\p<untitled>");			{						aControl = HUI_Control_Get( 			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID);		if ( aControl != nil)		{			GetListBoxListHandle( aControl, &list);					if ( list != nil)			{				NumToString( id, ids);				data = PsuedoColumn_Data_Make( &dataLength,					d->lastAllotedReferenceNum++, ids, "\p\t", "\p<untitled>", "\p");				if ( data != nil)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.h = 0;					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( data, dataLength, cell, list );					DisposePtr( data);					HUI_Control_SetListValue( d->master, 0, kList_Cell_X,						kList_Cell_Y, kList_ID, (**list).dataBounds.bottom - 1);				} else					goto AddNewStringList_error;			} else				goto AddNewStringList_error;		} else			goto AddNewStringList_error;	}		// the list should be sorted after calling this, but not before	// 1st calling update list selection	return;AddNewStringList_error:	if ( data != nil) DisposePtr( data);}static void DeleteStringList( STR_EditorWindowType *d){	long			id;		mAssert( d != nil);	// 1st get our current id	id = GetCellData( d, d->index, nil, nil);			HRT_DeleteResource( d->heraFile, 'STR#', id);		HUI_Control_DeleteListRows(		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, 1, d->index);	HUI_Control_SetListValue(		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, d->index);}static void SetUpList( STR_EditorWindowType *d){	short						oldResRefNum = 0;	ControlHandle				aControl;	ListHandle					list;	long						stringListNum = 0;		if ( d == nil) return;	oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);		stringListNum = CountResources('STR#');			aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Cell		cell;				GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			short	i = 1, count = stringListNum, theID, resHomeFile;			Str255	ids, ns;			Handle	stringList;			ResType	theType;			Ptr		data = nil;			long	dataLength;			Boolean			done = false, dataExists;			newResourceType	*hrtPtr = nil;						LDelRow( 0, 0, list);	// delete all rows			(*list)->selFlags = lOnlyOne;						stringListNum = 0;			cell.h = 0;			do			{				dataExists = false;								if ( count > 0)				{					stringList = GetIndResource( 'STR#', i);					if ( stringList != nil)					{						GetResInfo( stringList, &theID, &theType, ns);						resHomeFile = HomeResFile( stringList);						if (( theID > 0) &&							( mResOwner_IsOK( resHomeFile, d->heraFile)))						{							HRT_Resource_GetChanges( d->heraFile, 'STR#',								&theID, ns);							if ( theID > 0)								dataExists = true;						}						ReleaseResource( stringList);					}					count--;				} else				{					hrtPtr = HRT_Resource_GetNextNew( d->heraFile, 'STR#',						hrtPtr, &theID, ns);					if ( hrtPtr == nil)					{						done = true;					} else dataExists = true;				}				if ( dataExists)				{					if ( theID > 0 )					{						NumToString( theID, ids);						if ( ns[0] == 0) pstrcpy( ns, "\p<untitled>");											data = PsuedoColumn_Data_Make( &dataLength,							d->lastAllotedReferenceNum++, ids, "\p\t", ns, "\p");					} else data = nil;				} else data = nil;								if ( data != nil)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( data, dataLength, cell, list );					DisposePtr( data);					data = nil;					stringListNum++;				}				i++;			} while (!done);		}	}	if ( d->chooseRes)	{		OSErr err =			List_Utilities_QSort( list, (Point){0, 0}, (Point){stringListNum - 1, 0},				CompareCellsByID);			if ( err != noErr) SysBeep(20);	}		GetAllData_error:		UseResFile( oldResRefNum);}static void SetUpStringSelectionList( STR_EditorWindowType *d, Boolean draw){	short						oldResRefNum = 0;	ControlHandle				aControl;	ListHandle					list;	long						stringNum = 0;		if ( d == nil) return;	if ( d->currentStringList == nil) return;	oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);		stringNum = StringListSize( d->currentStringList);			aControl = HUI_Control_Get( 		d->master, 0, kStringList_Cell_X - d->columnFix, kStringList_Cell_Y,		kStringList_ID);	if ( aControl != nil)	{		Cell		cell;				GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			short	i = 1, count = stringNum;			Str255	ids, ns;			Ptr		data = nil;			long	dataLength;						LDelRow( 0, 0, list);	// delete all rows//			List_ClickLoopProc_Install( list, NullClickLoop);			ImmediateReturn_ClickLoop_Install( list);			(*list)->selFlags = lOnlyOne;						stringNum = 1;			cell.h = 0;			while ( count > 0)			{				{					RetrieveIndString( d->currentStringList, stringNum, ns);					{						NumToString( stringNum, ids);						if ( ns[0] == 0) pstrcpy( ns, "\p-");												data = PsuedoColumn_Data_Make( &dataLength,							d->lastAllotedReferenceNum++, ids, "\p\t", ns, "\p");					}				}				if ( data != nil)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( data, dataLength, cell, list );					DisposePtr( data);					data = nil;					stringNum++;				}				i++;				count--;			}		}		if ( draw) Draw1Control( aControl);	}	GetAllData_error:		UseResFile( oldResRefNum);}static OSErr ChangeWhichStringList( STR_EditorWindowType *d, Boolean checkFirst){	ControlHandle		aControl;	Str255				s;	short				theID, oldResRefNum, originalResID;	long				oldIndex;		mAssert( d != nil);		oldIndex = d->index;		oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);	s[0] = 0;		mAssert( d != nil);		if ( checkFirst)	{		ChangeWhichString( d, true);		KeepChangedStringList( d);	}	if ( d->currentStringList != nil)	{		DisposeHandle( d->currentStringList);		d->currentStringList = nil;	}		if ( d->chooseRes)	{		d->index = HUI_Control_GetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->index);		mAssert( d->index >= 0);		// get the id by looking it up in the list		theID = GetCellData( d, d->index, &d->currentReferenceNum, nil);	} else	{		theID = d->theResID;	}			if ( d->index != oldIndex)			d->stringIndex = 0;		d->currentStringList = HRT_Resource_GetHandle( d->heraFile,		'STR#', theID, &originalResID, s);	if ( d->currentStringList == nil)	{		return memFullErr;	} else	{		d->currentOriginalResID = theID;	}	SetUpStringSelectionList( d, true);	aControl = HUI_Control_Get( d->master, 0, kStrData_Cell_X - d->columnFix,					kStrData_Cell_Y, kStrContent_TextTitle);	if ( aControl != nil)	{		SetControlTextItemString( aControl, s);		Draw1Control( aControl);	}	aControl = HUI_Control_Get( d->master, 0, kStrData_Cell_X - d->columnFix,					kStrData_Cell_Y, kStrContent_TextID);	if ( aControl != nil)	{		NumToString( theID, s);		SetControlTextItemString( aControl, s);		Draw1Control( aControl);	}	ChangeWhichString( d, false);	UseResFile( oldResRefNum);	return noErr;	}static OSErr ChangeWhichString( STR_EditorWindowType *d, Boolean checkFirst){	ControlHandle		aControl;	Str255				s;	ListHandle			list;		s[0] = 0;		mAssert( d != nil);		if ( checkFirst)		KeepChangedString( d);		if ( d->currentStringList == nil) return noErr;		d->stringIndex = HUI_Control_GetListValue( d->master, 0, kStringList_Cell_X - d->columnFix,			kStringList_Cell_Y,			kStringList_ID, d->stringIndex);	list = HUI_List_Get(  d->master, 0, kStringList_Cell_X - d->columnFix,			kStringList_Cell_Y,			kStringList_ID);	if ( list != nil)		LAutoScroll( list);			mAssert( d->stringIndex >= 0);	mAssert( d->currentStringList != nil);		aControl = HUI_Control_Get( d->master, 0, kStrContent_Cell_X - d->columnFix,					kStrContent_Cell_Y, kStrContent_Text);	if ( aControl != nil)	{		RetrieveIndString( d->currentStringList, d->stringIndex + 1, s);		SetControlTextItemString( aControl, s);		Draw1Control( aControl);	}	UpdateLengthField( d, true);		BPMOWritePString("\pChangeWhichString:\t");	BPMOWriteLong( HUI_Control_GetListValue( d->master, 0, kStringList_Cell_X - d->columnFix,			kStringList_Cell_Y,			kStringList_ID, d->stringIndex));	BPMOWritePString("\p\r");	return noErr;	}static void KeepChangedString( STR_EditorWindowType *d){	Str255			oldString, newString;	Ptr				data;	long			dataLength, cellReferenceNum;	ListHandle		list;	ControlHandle	aControl;		mAssert( d != nil);	if ( d->stringIndex < 0) return;		if ( d->currentStringList == nil) return;		if ( d->chooseOnly) return;		mAssert( d->currentStringList != nil);	if ( StringListSize( d->currentStringList) <= 0) return;	RetrieveIndString( d->currentStringList, d->stringIndex + 1, oldString);		aControl = HUI_Control_Get( d->master, 0, kStrContent_Cell_X - d->columnFix,					kStrContent_Cell_Y, kStrContent_Text);	if ( aControl == nil) return;		GetControlTextItemString( aControl, newString);		if ( pstrcmp( oldString, newString) == 0) return;		StringListRemove( d->currentStringList, d->stringIndex + 1);	StringListInstall( d->currentStringList, d->stringIndex + 1, newString);		aControl = HUI_Control_Get( d->master, 0, kStringList_Cell_X - d->columnFix, kStringList_Cell_Y,		kStringList_ID);	if ( aControl == nil) return;		GetListBoxListHandle( aControl, &list);	if ( list == nil) return;		cellReferenceNum = PsuedoColumn_List_GetIndex( list, d->stringIndex);	NumToString( d->stringIndex + 1, oldString);	PsuedoColumn_PString_CleanInPlace( newString);	if ( newString[0] == 0) pstrcpy( newString, "\p-");	data = PsuedoColumn_Data_Make( &dataLength,		cellReferenceNum, oldString, "\p\t", newString, "\p");	if ( data == nil) return;	LSetCell( data, dataLength, (Point){d->stringIndex, 0}, list );		Draw1Control( aControl);		DisposePtr( data);}static void AddNewString( STR_EditorWindowType *d){	Str255			s, nums;	ListHandle		list;	ControlHandle	aControl;	long			dataLength, cellReferenceNum, i;	Ptr				data;		mAssert( d != nil);	mAssert( d->currentStringList != nil);		KeepChangedString( d);		if ( StringListSize( d->currentStringList) > 0)	{		RetrieveIndString( d->currentStringList, d->stringIndex + 1, s);		d->stringIndex++;	} else	{		d->stringIndex = 0;		pstrcpy( s, "\p");	}	StringListInstall( d->currentStringList, d->stringIndex + 1, s);	PsuedoColumn_PString_CleanInPlace( s);		aControl = HUI_Control_Get( d->master, 0, kStringList_Cell_X - d->columnFix, kStringList_Cell_Y,		kStringList_ID);	if ( aControl == nil) return;	GetListBoxListHandle( aControl, &list);	if ( list == nil) return;		NumToString( d->stringIndex + 1, nums);	data = PsuedoColumn_Data_Make( &dataLength,		d->lastAllotedReferenceNum++, nums, "\p\t", s, "\p");	if ( data == nil) return;	LAddRow( 1, d->stringIndex, list );	LSetCell( data, dataLength, (Point){d->stringIndex, 0}, list );	DisposePtr( data);		for ( i = d->stringIndex; i < (**list).dataBounds.bottom; i++)	{		RetrieveIndString( d->currentStringList, i + 1, s);		PsuedoColumn_PString_CleanInPlace( s);		NumToString( i + 1, nums);		cellReferenceNum = PsuedoColumn_List_GetIndex( list, i);		data = PsuedoColumn_Data_Make( &dataLength,			cellReferenceNum, nums, "\p\t", s, "\p");		if ( data != nil)		{			LSetCell( data, dataLength, (Point){i, 0}, list );			DisposePtr( data);		}	}	HUI_Control_SetFocus( d->master, 0,		kStrContent_Cell_X - d->columnFix, kStrContent_Cell_Y, kStrContent_Text);		d->stringIndex = HUI_Control_SetListValue( d->master, 0, kStringList_Cell_X - d->columnFix, kStringList_Cell_Y,		kStringList_ID, d->stringIndex);	LAutoScroll( list);	Draw1Control( aControl);}static void RemoveString( STR_EditorWindowType *d){	ListHandle		list;	ControlHandle	aControl;	long			dataLength, cellReferenceNum, i;	Ptr				data;	Str255			s, nums;		mAssert( d != nil);	mAssert( d->currentStringList != nil);		if ( StringListSize( d->currentStringList) < 1) return;		aControl = HUI_Control_Get( d->master, 0, kStringList_Cell_X - d->columnFix, kStringList_Cell_Y,		kStringList_ID);	if ( aControl == nil) return;	GetListBoxListHandle( aControl, &list);	if ( list == nil) return;		LDelRow( 1, d->stringIndex, list);	// delete all rows	StringListRemove( d->currentStringList, d->stringIndex + 1);		for ( i = d->stringIndex; i < (**list).dataBounds.bottom; i++)	{		RetrieveIndString( d->currentStringList, i + 1, s);		PsuedoColumn_PString_CleanInPlace( s);		NumToString( i + 1, nums);		cellReferenceNum = PsuedoColumn_List_GetIndex( list, i);		data = PsuedoColumn_Data_Make( &dataLength,			cellReferenceNum, nums, "\p\t", s, "\p");		if ( data != nil)		{			LSetCell( data, dataLength, (Point){i, 0}, list );			DisposePtr( data);		}	}		if (( d->stringIndex > 0) && ( d->stringIndex >= (**list).dataBounds.bottom))	{		d->stringIndex = HUI_Control_SetListValue( d->master, 0, kStringList_Cell_X - d->columnFix, kStringList_Cell_Y,			kStringList_ID, d->stringIndex - 1);	}	if ( (**list).visible.top > 0) LScroll( 0, -1, list);	LAutoScroll( list);	Draw1Control( aControl);	ChangeWhichString( d, false);}static short GetCellData( STR_EditorWindowType *d, short stringListIndex,	long *referenceNumber, StringPtr title){	ControlHandle		aControl;	Str255				s;	ListHandle			list;	short				result = -1;	mAssert( d != nil);			aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			long	tl;			short	length;			Ptr		data = List_Utilities_GetCell( list, (Point){stringListIndex, 0}, &length);						if ( data != nil)			{				PsuedoColumn_String_GetAll( data, length, referenceNumber, s, title, -1);								DisposePtr( data);				StringToNum( s, &tl);				result = tl;			}		}	}	return result;}/*	KeepChangedStringList		if the StringList has changed, this will append it to the list of changed StringList;	id must be confirmed as being legal 1st*/static void KeepChangedStringList( STR_EditorWindowType *d){	ControlHandle		aControl;	Str255				newTitle;	short				originalResID = -1, newID, oldResRefNum;	Handle				newStringList;	Boolean				different = false, titleDifferent = false,						idDifferent = false;	unsigned long		textChanges = 0;		mAssert( d != nil);		if ( d->chooseOnly) return;		aControl = HUI_Control_Get( d->master, 0, kStrData_Cell_X - d->columnFix,					kStrData_Cell_Y, kStrContent_TextID);	if ( aControl != nil)	{		newID = GetControlTextItemLong( aControl);	}//	aControl = HUI_Control_Get( d->master, 0, kStrContent_Cell_X - d->columnFix,//					kStrContent_Cell_Y, kStrContent_Text);//	if ( aControl != nil)	{		// get the TEHandle		newStringList = d->currentStringList;//HUI_ScrollText_GetFromControl( aControl);//		if ( newStringList != nil)		{			// get the text of the TEHandle//			newText = (Handle)TEGetText( text);			if ( newStringList != nil)			{				aControl = HUI_Control_Get( d->master, 0, kStrData_Cell_X - d->columnFix,								kStrData_Cell_Y, kStrContent_TextTitle);				if ( aControl != nil)				{					GetControlTextItemString( aControl, newTitle);				}								oldResRefNum = CurResFile();				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_scenarioFile_refNum);				textChanges = HRT_KeepChangedResource( d->heraFile,					newStringList, 'STR#',					d->currentOriginalResID, newID, newTitle);				UseResFile( oldResRefNum);							// make changes to list						{							Ptr		data;							Str255	ids;							long	dataLength;														NumToString( newID, ids);							data = PsuedoColumn_Data_Make( &dataLength,								d->currentReferenceNum, ids, "\p\t",								newTitle, "\p");							if ( data != nil)							{								HUI_Control_SetListCell( d->master, 0, kList_Cell_X,									kList_Cell_Y, kList_ID, 0, d->index, data,									dataLength);								HUI_Control_Draw( d->master, 0, kList_Cell_X,									kList_Cell_Y, kList_ID);								DisposePtr( data);							}						}					// we have to resort if the relevant field has been changed					if ( ((textChanges & kHRT_ResourceDifferenceFlag_Title) &&						( d->sortBy == kSortByName)) ||						(( textChanges & kHRT_ResourceDifferenceFlag_ID) &&						( d->sortBy == kSortByID)))					{						SortStringListList( d, true);					}							}		}	}}static OSErr SortStringListList( STR_EditorWindowType *d, Boolean draw){	short			currentSelectionIndex = 0, dataLength = 0;	long			currentSelectionReference = 0, i = 0, thisReference;	Ptr				data = nil;	OSErr			err = noErr;	ControlHandle	aControl = nil;	ListHandle		list = nil;	Boolean 		done, found;		// in order to preserve the selection,	// we have to get it's arbitrary reference #		currentSelectionIndex =  HUI_Control_GetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->index);		aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);			if ( aControl == nil) return paramErr;	GetListBoxListHandle( aControl, &list);		if ( list == nil) return paramErr;		data = List_Utilities_GetCell(list, (Point){currentSelectionIndex, 0},		&dataLength);		if ( data == nil) return memFullErr;		PsuedoColumn_String_GetAll( data, dataLength,		&currentSelectionReference, (StringPtr)-1);	DisposePtr( data);		if ( d->sortBy == kSortByName)		err = List_Utilities_QSort( list, (Point){0, 0},			(Point){(**list).dataBounds.bottom - 1, 0},			CompareCellsByName);	else if ( d->sortBy == kSortByID)		err = List_Utilities_QSort( list, (Point){0, 0},			(Point){(**list).dataBounds.bottom - 1, 0},			CompareCellsByID);		// now we have to find our selection; we may as well start with its original	// position		done = found = false;	i = 0;		while (( !done) && ( !found))	{		if ( (currentSelectionIndex + i) < (**list).dataBounds.bottom)		{			data = List_Utilities_GetCell(list, (Point){currentSelectionIndex + i, 0},				&dataLength);			if ( data != nil)			{				PsuedoColumn_String_GetAll( data, dataLength,					&thisReference, (StringPtr)-1);								if ( thisReference == currentSelectionReference)				{					found = true;					currentSelectionIndex = currentSelectionIndex + i;				}				DisposePtr( data);			}		} else done = true;		if ( (currentSelectionIndex - i) >= 0)		{			data = List_Utilities_GetCell(list, (Point){currentSelectionIndex - i, 0},				&dataLength);			if ( data != nil)			{				PsuedoColumn_String_GetAll( data, dataLength,					&thisReference, (StringPtr)-1);								if ( thisReference == currentSelectionReference)				{					found = true;					currentSelectionIndex = currentSelectionIndex - i;				}				DisposePtr( data);			}			done = false;		} else		{			// do nothing; if done was previously true, keep it true			// if it was false, keep it false		}		i++;	}	d->index = HUI_Control_SetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, currentSelectionIndex);	LAutoScroll( list);	if ( draw) Draw1Control( aControl);		return err;}static Boolean IsIDStringListLegal( STR_EditorWindowType *d, short *theID){	ControlHandle	aControl;		/* to determine if id is legal:		0.	legal if unchanged from original		1.	illegal if any newText has the same current id;		2.	illegal if any TEXT resource of same id exists AND there is no			newText with same original id			(there could be a newText with same original id and same current id,			but we ruled those out in 1)	*/	aControl = HUI_Control_Get( d->master, 0, kStrData_Cell_X - d->columnFix,					kStrData_Cell_Y, kStrContent_TextID);	if ( aControl != nil)	{		*theID = GetControlTextItemLong( aControl);	} else	{		*theID = 0;		return false;	}	// if unchanged, is legal, exit	if ( *theID == d->currentOriginalResID) return true;	return ( HRT_IsIDLegal( d->heraFile, 'STR#', *theID));}static short CompareCellsByName( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	name_a, name_b;	long	result;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, nil, name_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, nil, name_b, -1);	result = pstrcmp_nocase( name_a, name_b);	return -result;}static short CompareCellsByID( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	id_string_a, id_string_b;	long	id_a, id_b;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, id_string_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, id_string_b, -1);	StringToNum( id_string_a, &id_a);	StringToNum( id_string_b, &id_b);	if ( id_a < id_b)	{		return 1;	} else if ( id_a > id_b)	{		return -1;	} else	{		return 0;	}}static void UpdateLengthField( STR_EditorWindowType *d, Boolean draw){	ControlHandle	aControl;	Str255			s;	mAssert ( d != nil);		aControl = HUI_Control_Get( d->master, 0, kStrContent_Cell_X - d->columnFix,					kStrContent_Cell_Y, kStrContent_Text);	if ( aControl == nil) return;		GetControlTextItemString( aControl, s);	NumToString(s[0], s);	pstrcat( s, "\p/255");	aControl = HUI_Control_Get( d->master, 0, kStrContent_Cell_X - d->columnFix,					kStrContent_Cell_Y, kStrContent_Length);	if ( aControl == nil) return;		SetControlTextItemString( aControl, s);	if ( draw) Draw1Control( aControl);}static void StringList_Click( CWindowPtr whichWindow, Point where,	STR_EditorWindowType *d, ControlHandle aControl){	ListHandle				list;	short					shortLength = 0, oldValue, dragTo, dragFrom;	Ptr						data = nil;	long					newValue, longLength, i, dataIndex;	Str255					idString, s1, s2;#pragma unused( whichWindow)	GetListBoxListHandle( aControl, &list);	if ( list == nil) return;		BPMOWritePString("\pBefore Drag:\t");	BPMOWriteLong( HUI_Control_GetListValue( d->master, 0, kStringList_Cell_X - d->columnFix,			kStringList_Cell_Y,			kStringList_ID, d->stringIndex));	BPMOWritePString("\p\r");	dragTo =  List_Reposition_Drag( list, where, aControl);	oldValue = d->stringIndex;		BPMOWritePString("\pAfter Drag:\t");	BPMOWriteLong( HUI_Control_GetListValue( d->master, 0, kStringList_Cell_X - d->columnFix,			kStringList_Cell_Y,			kStringList_ID, d->stringIndex));	BPMOWritePString("\p\r");	dragFrom = d->stringIndex = HUI_Control_GetListValue(			d->master, 0, kStringList_Cell_X - d->columnFix, kStringList_Cell_Y,			kStringList_ID, d->stringIndex);	{				HUI_Control_GetListCell(			d->master, 0, kStringList_Cell_X - d->columnFix, kStringList_Cell_Y,			kStringList_ID,			0, d->stringIndex, &data, &longLength);		if ( data != nil)		{			PsuedoColumn_String_GetAll( data,				longLength, &newValue,				(StringPtr)-1);	//		d->stringIndex = newValue;			DisposePtr( data);		} else			d->stringIndex = oldValue;	}	if ( d->stringIndex != oldValue)	{				}		if ( dragTo != -1)	{		data = List_Utilities_GetCell( list, (Point){dragFrom, 0}, &shortLength);		if ( data != nil)		{			LDelRow( 1, dragFrom, list);			if ( dragFrom < dragTo) dragTo--;			LAddRow( 1, dragTo, list);			LSetCell( data, shortLength, (Point){dragTo, 0}, list);			d->stringIndex = HUI_Control_SetListValue( d->master, 0, kStringList_Cell_X - d->columnFix, kStringList_Cell_Y,				kStringList_ID, dragTo);			DisposePtr( data);						if ( d->currentStringList != nil)				RetrieveIndString(  d->currentStringList, dragFrom + 1,					s2);						if ( dragTo > dragFrom)			{				for ( i = dragFrom; i <= dragTo; i++)				{						// change the chapter name str#s												if (  d->currentStringList != nil)						{							if ( i != dragTo)							{								RetrieveIndString(  d->currentStringList,									i + 2, s1);							} else							{								pstrcpy( s1, s2);														}							StringListRemove(  d->currentStringList,								i + 1);							StringListInstall(  d->currentStringList,								i + 1, s1);						}												// change the actual scenario data												NumToString( i + 1, idString);												data = PsuedoColumn_Data_Make( &longLength,							dataIndex, idString, "\p\t", s1, "\p");												if ( data != nil)						{							LSetCell( data, longLength, (Point){i, 0}, list);							DisposePtr( data);						}									}			} else if ( dragTo < dragFrom)			{				for ( i = dragFrom; i >= dragTo; i--)				{						// change the chapter name str#s												if (  d->currentStringList != nil)						{							if ( i != dragTo)							{								RetrieveIndString(  d->currentStringList,									i, s1);							} else							{								pstrcpy( s1, s2);														}							StringListRemove(  d->currentStringList,								i + 1);							StringListInstall(  d->currentStringList,								i + 1, s1);						}						NumToString( i + 1, idString);												data = PsuedoColumn_Data_Make( &longLength,							dataIndex, idString, "\p\t", s1, "\p");												if ( data != nil)						{							LSetCell( data, longLength, (Point){i, 0}, list);							DisposePtr( data);						}									}			}						Draw1Control( aControl);		}	}}pascal Boolean NullClickLoop( void){	return false;}#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/OSErr STR_Editor_NewWindow( heraScenarioFileType *heraFile,	StringPtr title, short resRefNum, short defaultResID,	short defaultStringNumber, Boolean chooseRes, Boolean chooseButton,	Boolean isModal, long callerID, STR_Editor_Callback_procPtr callBack){	Rect						bounds;	CWindowPtr					newWindow;	ControlHandle				rootControl, aControl;	huiPlainControlParamType	buttonParam, textParam;	huiMasterControlParamType	masterParam;	OSStatus					err;	Handle						data, strList;	STR_EditorWindowType		*d;	long						maxWidth = 0;	long						windowID = -1, extraColumn;	huiCellParamType			cellParam;	huiPlainControlType			*hui;	ListHandle					list;	#pragma unused ( err, textParam, aControl)			// create the new window	data = NewHandle( sizeof( STR_EditorWindowType));	if ( data == nil) return memFullErr;		HLock( data);	d = (STR_EditorWindowType *)*data;		SetRect( &bounds, 64, 64, 128, 128);	if ( isModal)	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowMovableModalDialogProc, (WindowPtr)-1, false,			HandleEvent, 0,			&windowID);	} else	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowDocumentProc, (WindowPtr)-1, false,			HandleEvent, 0,			&windowID);	}	SetDispatchWindowDataHandle( windowID, data);	d->windowID = windowID;	d->resRefNum = resRefNum;	d->index = 0;	d->stringIndex = 0;	d->currentOriginalResID = -1;	d->currentStringList = nil;	d->sortBy = kSortByID;	d->currentReferenceNum = 0;	d->lastAllotedReferenceNum = 0;	d->dragTo = d->dragFrom = -1;	d->chooseRes = chooseRes;	d->chooseButton = chooseButton;	d->theResID = defaultResID;	if ( d->chooseRes) d->columnFix = 0;	else d->columnFix = 1;	d->heraFile = heraFile;	if ( heraFile->fileRefNum <= 0) d->chooseOnly = true;	else d->chooseOnly = false;		d->callerID = callerID;	d->isModal = isModal;	d->callBack = callBack;		SetThemeWindowBackground( (WindowPtr)newWindow,		kThemeActiveDialogBackgroundBrush, true);	SetPortWindowPort( (WindowPtr)newWindow);	CreateRootControl( (WindowPtr)newWindow, &rootControl);	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kRowNum;	masterParam.colNum = kColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->master = HUI_MasterControl_New( nil, 0, 0, 0, &masterParam);		mAssert( d->master != nil);	if ( d->master == nil) return memFullErr;	d->master->tab[0][0].h = kLarge_Tab_Width;	d->master->tab[0][0].hAlign = hui_halign_right;	d->master->tab[0][1].h = kLarge_Tab_Width;	d->master->tab[0][1].hAlign = hui_halign_left;	if ( d->chooseRes) extraColumn = 0;	else extraColumn = 1;		// set up str# data cell	cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_right;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, 9, 12, 3);	SetRect( &cellParam.inSpace, -1, 6, 3, 3);	cellParam.colSpan = 1 + extraColumn;	cellParam.rowSpan = 1;	HUI_Cell_Set( 0, kStrData_Cell_X - d->columnFix, kStrData_Cell_Y, &cellParam);	if ( d->chooseRes)	{		// set up str# selection list cell		SetRect( &cellParam.outSpace, 12, 12, 3, 5);		SetRect( &cellParam.inSpace, 3, 3, 3, 3);		cellParam.colSpan = 1;		cellParam.rowSpan = 3;		cellParam.hAlign = hui_halign_right;		cellParam.minMaxBounds.top = 100;		HUI_Cell_Set( 0, kList_Cell_X, kList_Cell_Y, &cellParam);		cellParam.minMaxBounds.top = 0;			// set up str# selection list button cells		SetRect( &cellParam.outSpace, 12, -1, 3, 3);		SetRect( &cellParam.inSpace, -1, -1, 3, 3);		cellParam.colSpan = 1;		cellParam.rowSpan = 1;		cellParam.baseLine = gHera->smallFontSize;		cellParam.hAlign = hui_halign_center;		cellParam.vAlign = hui_valign_top;		d->master->rowDontExpand[kList_Button_Cell_Y] = true;		HUI_Cell_Set( 0, kList_Button_Cell_X, kList_Button_Cell_Y, &cellParam);		cellParam.minMaxBounds.bottom = kHUI_Pixel_Max;	}		// set up string selection list cell	cellParam.hAlign = hui_halign_right;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	cellParam.minMaxBounds.top = 100;	cellParam.colSpan = 1 + extraColumn;	cellParam.rowSpan = 1;	SetRect( &cellParam.outSpace, -1, -1,12, -1);	SetRect( &cellParam.inSpace, -1, -1, 3, -1);	HUI_Cell_Set( 0, kStringList_Cell_X - d->columnFix, kStringList_Cell_Y, &cellParam);	cellParam.minMaxBounds.top = 0;	// set up string content cell	cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_right;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, -1, 12, 3);	SetRect( &cellParam.inSpace, -1, -1, 3, 3);	cellParam.colSpan = 1 + extraColumn;	cellParam.rowSpan = 1;	HUI_Cell_Set( 0, kStrContent_Cell_X - d->columnFix, kStrContent_Cell_Y, &cellParam);	// set up string selection list button cells	SetRect( &cellParam.outSpace, -1, -1, 12, -1);	SetRect( &cellParam.inSpace, -1, -1, 3, -1);	cellParam.colSpan = 1 + extraColumn;	cellParam.rowSpan = 1;	cellParam.baseLine = gHera->smallFontSize;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_top;	d->master->rowDontExpand[kStringList_Button_Cell_Y] = true;	HUI_Cell_Set( 0, kStringList_Button_Cell_X - d->columnFix, kStringList_Button_Cell_Y, &cellParam);		cellParam.minMaxBounds.bottom = kHUI_Pixel_Max;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	// set up str data cell//	cellParam.colSpan = 1;//	cellParam.rowSpan = 2;//	HUI_Cell_Set( 0, kStrData_Cell_X - d->columnFix, kStrData_Cell_Y, &cellParam);		// set up buttons, general	buttonParam.master = d->master;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask | kControlUseJustMask;	buttonParam.fontStyle.font = kSmallFontNum;	buttonParam.fontStyle.size = kSmallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = teCenter;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;	buttonParam.flags = huiControlFlag_none;		// set up text, general		textParam.master = d->master;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = kControl_H_Space;//8;	textParam.space.top = 12;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = -1;	textParam.cellx = kStrData_Cell_X - d->columnFix;	textParam.celly = kStrData_Cell_Y;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;	// make STR# selection list	buttonParam.id = kList_ID;	buttonParam.minMaxBounds.left = 240;	buttonParam.minMaxBounds.right = 240;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;//200;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.bottom = 200;	buttonParam.cellx = kList_Cell_X;	buttonParam.celly = kList_Cell_Y;	buttonParam.special.listBox.ldesResID = 130;	// psuedo-column ldef	buttonParam.special.listBox.refCon = 131;		// psuedo-column params	buttonParam.flags = (huiControlFlagType )((int)huiControlFlag_useCellV |		(int)huiControlFlag_useCellH);	buttonParam.space.left = 4;	buttonParam.space.top = 4;	if ( d->chooseRes)		HUI_ListBox_New_LiteralP( &buttonParam);		buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// set up list buttons		buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	textParam.cellx =  kList_Button_Cell_X;	textParam.celly =  kList_Button_Cell_Y;	// sort by menu		textParam.id = kList_SortBy_Menu_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 2);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	if ( d->chooseRes)		HUI_StaticText_New_LiteralP( &textParam);	textParam.id = kList_SortBy_Menu_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;		strList = GetStringList( 8032);	if ( strList != nil)	{		textParam.special.menuStrList.strList = strList;		textParam.special.menuStrList.menuID = HU_GetNewMenuID();		textParam.minMaxBounds.right = kHUI_Pixel_Max;		textParam.minMaxBounds.left = 0;				if ( d->chooseRes)			HUI_PopupButton_New_StrList( &textParam);		ReleaseResource( strList);		textParam.minMaxBounds.right = kHUI_Pixel_Max;	}	if ( d->chooseOnly) buttonParam.enabled = false;	if ( d->chooseOnly) textParam.enabled = false;	buttonParam.id = kList_Add_Button_ID;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 9);	if ( d->chooseRes)		HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.id = kList_Remove_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 10);	if ( d->chooseRes)		HUI_PushButton_New_LiteralP( &buttonParam);	// text title		textParam.cellx = kStrData_Cell_X - d->columnFix;	textParam.celly = kStrData_Cell_Y;	buttonParam.cellx = kStrData_Cell_X - d->columnFix;	buttonParam.celly = kStrData_Cell_Y;	textParam.id = kStrContent_TextTitle - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 1);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kStrContent_TextTitle;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	if ( d->chooseRes)		HUI_EditText_New_LiteralP( &textParam);		else		HUI_StaticText_New_LiteralP( &textParam);	// text id		textParam.id = kStrContent_TextID - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 3);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kStrContent_TextID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.space.left = 2;	if ( d->chooseRes)	{		HUI_EditText_New_LiteralP( &textParam);		} else		HUI_StaticText_New_LiteralP( &textParam);	textParam.space.left = kControl_H_Space;		// make string selection list	buttonParam.enabled = true;	buttonParam.id = kStringList_ID;	buttonParam.minMaxBounds.left = 240;	buttonParam.minMaxBounds.right = 240;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;//200;	buttonParam.minMaxBounds.top = 200;//	buttonParam.minMaxBounds.bottom = 200;	buttonParam.cellx = kStringList_Cell_X - d->columnFix;	buttonParam.celly = kStringList_Cell_Y;	buttonParam.special.listBox.ldesResID = 130;	// psuedo-column ldef	buttonParam.special.listBox.refCon = 131;		// psuedo-column params	buttonParam.flags = (huiControlFlagType )((int)huiControlFlag_useCellV |		(int)huiControlFlag_useCellH);	buttonParam.space.left = 4;	buttonParam.space.top = 4;	HUI_ListBox_New_LiteralP( &buttonParam);		if ( d->chooseOnly) buttonParam.enabled = false;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// set up list buttons		buttonParam.cellx =  kStringList_Button_Cell_X - d->columnFix;	buttonParam.celly =  kStringList_Button_Cell_Y;	textParam.cellx =  kStringList_Button_Cell_X - d->columnFix;	textParam.celly =  kStringList_Button_Cell_Y;	// string add button	buttonParam.id = kStringList_Add_Button_ID;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kStrResID, 6);	HUI_PushButton_New_LiteralP( &buttonParam);		// string remove button	buttonParam.id = kStringList_Remove_Button_ID;	buttonParam.cellx =  kStringList_Button_Cell_X - d->columnFix;	buttonParam.celly =  kStringList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kStrResID, 7);	HUI_PushButton_New_LiteralP( &buttonParam);	// set up the string content controls	textParam.cellx = kStrContent_Cell_X - d->columnFix;	textParam.celly = kStrContent_Cell_Y;		// the string content text field	textParam.id = kStrContent_Text - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 4);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kStrContent_Text;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextHugeFieldWidth;	textParam.minMaxBounds.top = 84;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.space.left = 2;	hui = HUI_EditText_New_LiteralP( &textParam);		if ( hui != nil) SetEditTextKeyStandardFilter_AllowCR( hui->generic.control);	textParam.space.left = kControl_H_Space;	textParam.minMaxBounds.top = 0;	// string content text length		textParam.id = kStrContent_Length - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 5);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kStrContent_Length;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextHugeFieldWidth;	textParam.space.left = 2;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_StaticText_New_LiteralP( &textParam);		textParam.space.left = kControl_H_Space;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	if ( chooseButton)	{		strList = GetStringList( kHera_ChooseMainButtonsStrResID);	} else	{		strList = GetStringList( kHera_DefaultMainButtonStrResID);	}	if ( strList != nil)	{		HUI_Main_Buttons_H_Setup( d->master, 0,			kSeparator_Cell_X, kColNum, kSeparator_Cell_Y, 1,				true, strList);				ReleaseResource( strList);	}		SetUpList( d);	HUI_Master_Layout( d->master, (Point){0, 0}, (Point){0, 0});		list = HUI_List_Get( d->master, 0, kList_Cell_X, kList_Cell_Y, kList_ID);	if ( list != nil)	{		d->index = PsuedoColumn_CellV_FindFromNumber( list, 0, defaultResID);		if ( d->index < 0) d->index = 0;	}		d->index =  HUI_Control_SetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->index);	if ( list != nil)	{		LAutoScroll( list);	}		// set the string index here, even though we set it again below	// this looks better when we're not selecting resID		if ( defaultStringNumber > 0) d->stringIndex = defaultStringNumber - 1;	else d->stringIndex = 0;		ChangeWhichStringList( d, false);	if ( defaultStringNumber > 0) d->stringIndex = defaultStringNumber - 1;	else d->stringIndex = 0;	d->stringIndex = HUI_Control_SetListValue( d->master, 0,			kStringList_Cell_X - d->columnFix, kStringList_Cell_Y,			kStringList_ID, d->stringIndex);	ChangeWhichString( d, false);		HUI_Master_ShowLayer( d->master, 0);	ShowWindow( (WindowPtr)newWindow);	if ( isModal) gHera->modalMode++;	HUnlock( data);	return noErr;}