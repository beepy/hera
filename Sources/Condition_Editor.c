/******************************************\|**| Condition_Editor.c\******************************************/#pragma mark ¥¥INCLUDES¥¥/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Window Dispatch.h"#include "Control Utilities.h"#include "Hewey.h"#include "Hewey_Main.h"#include "Hewey_Layout.h"#include "Hewey_Utilities.h"#include "str_bp.h"#include "Set Font By String.h"#include "BP_Error.h"#include "Assert.h"#include "strlist.h"#include "Hewey_Helpers.h"#include "Hera_Global.h"#include "Classic2Carbon_Helpers.h"#include "Scenario.h"#pragma mark _this library includes_/* - this project*******************************************/#include "Condition_Editor.h"#include "Hera_Name_Maker.h"#include "Hera_Utilities.h"#include "Hera_Data.h"#include "Bit_Flipper.h"#include "Button_Window.h"#include "Action_Editor.h"#include "Initial_Editor.h"#pragma mark ¥¥DEFINITIONS¥¥/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kLarge_Tab_Width				80//112#define	kEditTextBigFieldWidth			150#define	kEditTextFieldWidth				38#define	kEditTextSmallFieldWidth		16#define	kColNum							2#define	kRowNum							4#define	kMain_Cell_X					1#define	kMain_Cell_Y					0#define	kMain_ID_Offset					100#define	kMain_Master_ColNum				1#define	kMain_Master_RowNum				2#define	kCondition_Master_ColNum		1#define	kCondition_Master_RowNum		1#define	kCondition_Master_Cell_X		0#define	kCondition_Master_Cell_Y		0#define	kQualifier_Master_Cell_X		0#define	kQualifier_Master_Cell_Y		1#define	kSeparator_Cell_X				0#define	kSeparator_Cell_Y				2#define	kSeparator_ID					200#define	kList_ID						6#define	kList_Cell_X					0#define	kList_Cell_Y					0#define	kList_Button_Cell_X				0#define	kList_Button_Cell_Y				1#define	kList_Button_ID_Offset			300#define	kList_Remove_Button_ID			(kList_Button_ID_Offset + 1)#define	kList_Add_Button_ID				(kList_Button_ID_Offset + 2)#define	kCondition_Popup_ID				400#define	kButton_Cell_X					0#define	kButton_Cell_Y					3#define	kOK_Button_ID					1#define	kCancel_Button_ID				2#define	kRevert_Button_ID				3#define	kSmallFontSize					gHera->smallFontSize#define	kSmallFontNum					gHera->smallFontNum#define	kLargeFontNum					gHera->bigFontNum;#define kLargeFontSize					gHera->bigFontSize;#define	kCondition_Panel_Num			25#define	kPanel_ID_Multiplier			100#define	kPanel_ID_Offset				2000#define	kCondition_Main_Cell_X			0#define	kCondition_Main_Cell_Y			0#define	kLC_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kLocationCondition ))#define	kCI_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kCounterCondition ))#define	kPX_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kProximityCondition ))#define	kOW_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kOwnerCondition ))#define	kDE_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kDestructionCondition ))#define	kAG_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kAgeCondition  ))#define	kTM_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kTimeCondition  ))#define	kRN_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kRandomCondition ))#define	kHH_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kHalfHealthCondition ))#define	kAX_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kIsAuxiliaryObject ))#define	kTG_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kIsTargetObject ))#define	kCG_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kCounterGreaterCondition ))#define	kCN_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kCounterNotCondition ))#define	kDG_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kDistanceGreaterCondition ))#define	kVE_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kVelocityLessThanEqualToCondition ))#define	kNS_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kNoShipsLeftCondition ))#define	kCM_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kCurrentMessageCondition ))#define	kCC_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kCurrentComputerCondition ))#define	kZL_ID				(kPanel_ID_Offset + (kPanel_ID_Multiplier * kZoomLevelCondition ))#define	kQualifier_Cell_X				0#define	kQualifier_Cell_Y				1#define	kQualifier_ID_Offset			600#define	kQualifier_Subject_ID			602#define	kQualifier_Direct_ID			604#define	kQualifier_Action_Index_ID		608#define	kQualifier_Action_Num_ID		610#define	kQualifier_Action_Edit_ID		612#define	kQualifier_Action_Set_ID		614#define	kQualifier_Flag_ID				616#define	kQualifier_Flag_Set_ID			618#define	kQualifier_Subject_Is_Player_ID	620#define	kQualifier_Subject_Choose_ID	622#define	kQualifier_Direct_Choose_ID		624#define	kQualifier_Action_Choose_ID		626#define	kStrResID						8018#pragma mark _macros_/* - macros*******************************************/#pragma mark ¥¥TYPEDEFS¥¥/******************************************\|**| typedefs\******************************************/typedef struct Condition_EditorWindowType{	heraScenarioFileType			*heraFile;	huiMasterControlType			*master;	huiMasterControlType			*mainMaster;	huiMasterControlType			*conditionValues;	long							windowID;	scenarioConditionType			condition;	Handle							conditionData;	long							conditionIndex;	long							whatCondition;	long							startConditionIndex;	long							conditionNumber;	short							resRefNum;	long							setConditionFlags_WindowID;	Boolean							anyChanges;	Handle							discreteData;	long							discreteDataID;	Boolean							modal;	Boolean							chooseOnly;	Condition_Editor_Callback_procPtr	callBack;	long							callerID;		heraDataChangesType				*dataChanges;	long							scenario_initialDataID;	Str255							titlePrefix;} Condition_EditorWindowType;#pragma mark ¥¥EXTERNAL GLOBALS¥¥/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark ¥¥PRIVATE GLOBALS¥¥/******************************************\|**| private globals\******************************************/#pragma mark ¥¥PRIVATE PROTOTYPES¥¥/******************************************\|**| private function prototypes\******************************************/static Boolean HandleEvent( EventRecord *, CWindowPtr, long, long);static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID);static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID);static void OK_Button( Condition_EditorWindowType *d);static void Cancel_Button( Condition_EditorWindowType *d);static void Revert_Button( Condition_EditorWindowType *d);static void ChangeWhichCondition( Condition_EditorWindowType *d, long newCondtion);static void Window_SetControls_FromConditionIndex( Condition_EditorWindowType *d, CWindowPtr window,	long index);static void Window_SetCondition_FromControls( Condition_EditorWindowType *d, CWindowPtr window,	long index);static void SetConditionField( Condition_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioConditionType *c, long id, Boolean draw);static void GetConditionField( Condition_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioConditionType *c, long id);static void Setup_ConditionValues_Panel( Condition_EditorWindowType *d, CWindowPtr window);static void AddBitPopUp(  huiPlainControlParamType *textParam, 	huiPlainControlParamType *buttonParam, long id, short resID, short index,	Boolean newLine, short menuStrResID);static void GetAllData( Condition_EditorWindowType *d);static void SetConditionFlags( long windowID, unsigned long bits);static void OKConfirmCallBack( long whichButton, long windowID);static void CancelConfirmCallBack( long whichButton, long windowID);static void Initial_Subject_CallBack( long dispatchID, long initialFirst,	long initialNum, long initialSelection, heraDataChangesType *changesList);static void Initial_Direct_CallBack( long dispatchID, long initialFirst,	long initialNum, long initialSelection, heraDataChangesType *changesList);static void Action_Editor_CallBack( long dispatchID, long actionID,	long actionNum);//static void InsertSelectedCondition( Condition_EditorWindowType *d);static void InsertCondition( Condition_EditorWindowType *d, CWindowPtr whichWindow);static void DeleteCondition( Condition_EditorWindowType *d, CWindowPtr whichWindow);static void Enable_Editing( Condition_EditorWindowType *d, Boolean enable);static StringPtr Condition_Editor_ChildWindow_NameMaker(	Condition_EditorWindowType *d, StringPtr destString);	#pragma mark ¥¥PRIVATE FUNCTIONS¥¥/******************************************\|**| private functions\******************************************/static Boolean HandleEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID, long command){	switch( command)	{		case kWDCloseWindowCommand:			break;				case kWDProcessEventCommand:			return( ProcessEvent( theEvent, whichWindow, dispatchID));			break;				case kWDSaveWindowCommand:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these conditions?",										"\pBefore saving, the Condition Editor "										"must be closed. Click Cancel to "										"abort the save.", nil, nil))				{					OKConfirmCallBack( 1, dispatchID);									} else				{					gHera->currentSave = nil;				}			}			return false;			break;				case kWD_Close_ForQuit_Command:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these conditions?",										"\pBefore quitting, the Condition Editor "										"must be closed. Click Cancel to "										"abort the quit.", nil, nil))				{					OKConfirmCallBack( 1, dispatchID);									} else				{					gHera->currentSave = nil;					return true;				}			}			return false;			break;				case kWDProcessMenuChoiceCommand:			return( ProcessMenuChoiceCommand( (unsigned long)theEvent,				whichWindow, dispatchID));			break;	}	return false;}static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	SignedByte						dataState;	Condition_EditorWindowType			*d;	Boolean							result = false;	GrafPtr							oldPort;	short							menuID = ((menuData & 0xffff0000) >> 16),									menuItem = (menuData & 0x0000ffff);										if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (Condition_EditorWindowType *)*data;	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);	result = Generic_ProcessMenuChoiceCommand( menuData, whichWindow,												dispatchID);	if ( result)	{		goto ProcessMenuChoiceCommand_Return;	}		switch( menuID)	{		case kEditMenuID:			switch( menuItem)			{				case kEdit_Undo_Item:					result = true;					break;				case kEdit_Add_Item:					result = true;					break;									case kEdit_Delete_Item:					result = true;					break;									case kEdit_Delete_All_Item:					result = true;					break;			}							break;		}	ProcessMenuChoiceCommand_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);}static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Boolean							result = false;	ControlHandle					aControl, oldControl;	short							whichPart, oldValue;	WindowPtr						scratchWindow;	Point							where;	char							whichChar;	GrafPtr							oldPort;	OSStatus						err;	Condition_EditorWindowType				*d;	Str255							tString;		if ( data == nil) return false;	if ( theEvent == nil) return false;		dataState = HGetState( data);	HLock( data);	d = (Condition_EditorWindowType *)*data;		if ( theEvent == nil) goto ProcessEvent_Return;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);		switch( theEvent->what)	{		case nullEvent:			IdleControls( (WindowPtr)whichWindow);						result = true;			break;					case updateEvt:				BeginUpdate ((WindowPtr)whichWindow);/*			SetPort( (WindowPtr)whichWindow);			CalcVis( (WindowPtr)whichWindow);			UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);*/			HU_GenericUpdateEventHandler( whichWindow);			EndUpdate ((WindowPtr)whichWindow);			result = true;			break;		case activateEvt:		{			Boolean	isActive = ((theEvent->modifiers & activeFlag) != 0);						if ( isActive)			{				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_scenarioFile_refNum);			}		}			// result != true so dispatch window will handle activation			// of controls etc.			break;					case mouseDown:			whichPart = FindWindow (theEvent->where, &scratchWindow);			switch( whichPart)			{				case inGrow:/*					{						Rect	growRect;						long	newSize;//						growRect = qd.screenBits.bounds;						C2C_ScreenBits_GetBounds( &growRect);						growRect.top = growRect.left = 120;						newSize = GrowWindow((WindowPtr)whichWindow,							theEvent->where ,&growRect);						if (newSize != 0)						{							SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,								(((newSize) >> 16) & 0xFFFF), true );							EraseRect(&whichWindow->portRect);							InvalRect( &whichWindow->portRect);						}					}*/					HU_GenericGrowWindow( whichWindow, theEvent->where);					result = true;					break;								case inContent:					where = theEvent->where;					scratchWindow = WD_FrontWindow();					if ( whichWindow != (CWindowPtr)scratchWindow)					{						goto ProcessEvent_Return;					}					SetPortWindowPort( (WindowPtr)whichWindow);					GlobalToLocal( &where);					whichPart = FindControl( where, (WindowPtr)whichWindow,						&aControl);					if ( aControl == nil)						goto ProcessEvent_Return;					if ( aControl != nil)						oldValue = GetControlValue( aControl);					err = GetKeyboardFocus( (WindowPtr)whichWindow, &oldControl);					if (( err == noErr) && ( oldControl != aControl))					{						SetKeyboardFocus( (WindowPtr)whichWindow, aControl, whichPart);					}					if ( whichPart != 0)					{						huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);//						whichPart = HandleControlClick ( aControl, where,//							theEvent->modifiers, (ControlActionUPP)-1);						if ( !ListBox_Appearance_1_0_1_Hack( aControl, where,									&whichPart))						{							whichPart = HUI_Control_Click_Handle( hui, where,								theEvent->modifiers);														}							if ( whichPart != kControlNoPart) switch( hui->generic.id)						{							case kOK_Button_ID:								Window_SetCondition_FromControls( d,									whichWindow, d->conditionIndex + d->startConditionIndex);								result = true;								OK_Button( d);								data = nil;								goto ProcessEvent_Return;								break;														case kCancel_Button_ID:								Cancel_Button( d);								data = nil;								result = true;								goto ProcessEvent_Return;								break;															case kRevert_Button_ID:								Revert_Button( d);								break;																					case kCondition_Popup_ID:								ChangeWhichCondition( d, GetControlValue( aControl) - 1);								result = true;								break;									case kQualifier_Flag_Set_ID:								BitFlipper_NewWindow( &d->setConditionFlags_WindowID,									"\pCondition Flags",									GetStringList( 8019),									d->condition.flags, dispatchID,									SetConditionFlags);								result = true;								break;														case kQualifier_Flag_ID:							{								unsigned long bit;																if (( whichPart == kControlMenuPart) &&									(!d->chooseOnly))								{									oldValue = GetBevelMenuValue( aControl) - 1;									bit = 0x01 << oldValue;									d->condition.flags ^= bit;									HU_Menu_SetCheckFromBits( aControl,										d->condition.flags, oldValue, oldValue);								}							}								break;														case kQualifier_Subject_Is_Player_ID:								ReverseCheckBox( aControl);								{//									ControlHandle	tControl = HUI_Control_Get( d->mainMaster, 0,//														 kQualifier_Cell_X,//														kQualifier_Cell_Y, kQualifier_Subject_ID);									//									if ( tControl != nil)									{										if ( GetControlValue( aControl))										{											HUI_Control_Hilite(												d->mainMaster,												0,												kQualifier_Cell_X,												kQualifier_Cell_Y,												kQualifier_Subject_ID,												0);											HUI_Control_Hilite(												d->mainMaster,												0,												kQualifier_Cell_X,												kQualifier_Cell_Y,												kQualifier_Subject_Choose_ID,												0);										} else if ( !d->chooseOnly)										{											HUI_Control_Hilite(												d->mainMaster,												0,												kQualifier_Cell_X,												kQualifier_Cell_Y,												kQualifier_Subject_ID,												1);											HUI_Control_Hilite(												d->mainMaster,												0,												kQualifier_Cell_X,												kQualifier_Cell_Y,												kQualifier_Subject_Choose_ID,												1);										}									}								}								break;															case kList_ID:								oldValue = d->conditionIndex;																d->conditionIndex = HUI_Control_GetListValue(										d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, d->conditionIndex);								if ( d->conditionIndex != oldValue)								{																	Window_SetCondition_FromControls( d,										whichWindow, oldValue + d->startConditionIndex);									Window_SetControls_FromConditionIndex(										d, whichWindow, d->conditionIndex + d->startConditionIndex);															//									ChangePanelNumber( d, d->currentPanel); // auto corrects if not									// showing right special panel								}								result = true;								break;							case kList_Add_Button_ID:								InsertCondition(d, whichWindow);								result = true;								break;							case kList_Remove_Button_ID:								if ( HU_Confirm_Delete("\pAre you sure you "									"want to delete this condition?",										theEvent->modifiers))									DeleteCondition(d, whichWindow);								result = true;																break;							case kQualifier_Action_Choose_ID:								Action_Editor_NewWindow( d->heraFile,									Condition_Editor_ChildWindow_NameMaker(										d, tString), d->resRefNum,										-1, -1,										d->condition.startVerb,										true, dispatchID,										Action_Editor_CallBack);								result = true;								break;														case kQualifier_Subject_Choose_ID:								Initial_Editor_NewWindow( d->heraFile,									Condition_Editor_ChildWindow_NameMaker(										d, tString),									d->resRefNum, d->scenario_initialDataID,									d->condition.subjectObject,									true, true, dispatchID,									Initial_Subject_CallBack);								result = true;								break;															case kQualifier_Direct_Choose_ID:								Initial_Editor_NewWindow( d->heraFile,									Condition_Editor_ChildWindow_NameMaker(										d, tString),									d->resRefNum, d->scenario_initialDataID,									d->condition.directObject,									true, true, dispatchID,									Initial_Direct_CallBack);								result = true;								break;															default:								break;						}					} else // not in control					{						where = theEvent->where;						GlobalToLocal( &where);					}			}			break;					case keyDown:		case autoKey:			whichChar = theEvent->message & charCodeMask;			if ((whichChar=='\r' || whichChar==0x3))			{				// ok				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kOK_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);					result = true;					OK_Button( d);					data = nil;					goto ProcessEvent_Return;				}			} else if ((whichChar==0x1b) || ((whichChar=='.') && (theEvent->modifiers & cmdKey)))			{				// cancel				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kCancel_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);										Cancel_Button( d);					data = nil;					result = true;					goto ProcessEvent_Return;				}			} else if ( whichChar == '\t')			{				if ( theEvent->modifiers & shiftKey)					ReverseKeyboardFocus( (WindowPtr)whichWindow);				else					AdvanceKeyboardFocus( (WindowPtr)whichWindow);				result = true;				break;			} else if (( whichChar == 0x08) && ( !d->chooseOnly))			{				huiPlainControlType	*hui = nil;				err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);				hui = (huiPlainControlType	*)CU_GetControlReference( aControl);				if ( hui != nil)				{					if ( hui->generic.id == kList_ID)					{						if ( HU_Confirm_Delete("\pAre you sure you "							"want to delete this condition?",								theEvent->modifiers))							DeleteCondition( d, whichWindow);					}				}				result = true;			}									err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);			if (( err == noErr) && ( aControl != nil))			{				whichPart = HandleControlKey( aControl,					(theEvent->message & keyCodeMask)>>16,					theEvent->message & charCodeMask, theEvent->modifiers);				{					huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);					switch( hui->generic.id)					{													case kList_ID:							oldValue = d->conditionIndex;							d->conditionIndex = HUI_Control_GetListValue(									d->master, 0, kList_Cell_X, kList_Cell_Y,									kList_ID, d->conditionIndex);														if ( d->conditionIndex != oldValue)							{								Window_SetCondition_FromControls( d,									whichWindow, oldValue + d->startConditionIndex);//								ChangeWhichCondition( d, 5);								Window_SetControls_FromConditionIndex(									d, whichWindow, d->conditionIndex + d->startConditionIndex									);							}							break;					}				}			}			break;	}		ProcessEvent_Return:	SetPort( oldPort);	if ( data != nil)		HSetState( data, dataState);	return( result);	}static void OK_Button( Condition_EditorWindowType *d){//	Button_Window_NewWindow("\pSave Changes to Conditions", true, false, 8021,//		8022, OKConfirmCallBack, d->windowID);	OKConfirmCallBack( kOK_Button_ID, d->windowID);}static void Cancel_Button( Condition_EditorWindowType *d){//	Button_Window_NewWindow("\pDiscard Changes to Conditions", true, false, 8023,//		8024, CancelConfirmCallBack, d->windowID);	CancelConfirmCallBack( kOK_Button_ID, d->windowID);}static void Revert_Button( Condition_EditorWindowType *d){	CWindowPtr whichWindow = GetWindowPtrFromDispatchWindowID( d->windowID);		if ( whichWindow == nil) return;	if ( !Button_Window_Modal( "\pRevert this condition?",							"\pClick Revert to restore this condition to its "							"previous values. Click Cancel to "							"keep it as it is.", "\pRevert", nil))		return;	Window_SetControls_FromConditionIndex(			d, whichWindow, d->conditionIndex + d->startConditionIndex);}static void ChangeWhichCondition( Condition_EditorWindowType *d, long newCondition){		long oldPanel = d->whatCondition;		d->whatCondition = newCondition;		if ( d->whatCondition != oldPanel)		{			HUI_Master_ShowLayer( d->conditionValues, d->whatCondition);			if ( oldPanel >= 0)				HUI_Master_HideLayer( d->conditionValues, oldPanel);		}//			if ( oldPanel >= 0)//				HUI_Master_HideLayer( d->conditionValues, oldPanel);//		for ( short i = 0; i < kCondition_Panel_Num; i++)//		{//			if ( i != newCondition)//				HUI_Master_HideLayer( d->conditionValues, i);//		}		HU_AutoDefocus( GetWindowPtrFromDispatchWindowID( d->windowID));}static void Window_SetControls_FromConditionIndex( Condition_EditorWindowType *d, CWindowPtr window,	long index){	SignedByte					conditionDataState;	GrafPtr						oldPort;	scenarioConditionType		*aCondition;	huiPlainControlParamType	dummyParam;		mAssert( d != nil);		if (( d->conditionData == nil) || ( d->conditionNumber <= 0)) return;		mAssert( d->conditionData != nil);		conditionDataState = HGetState( d->conditionData);	HLock( d->conditionData);	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);		aCondition = (scenarioConditionType *)*d->conditionData + index;		BlockMoveData( aCondition, &d->condition, sizeof( scenarioConditionType));	// set qualifiers	dummyParam.layer = 0;	dummyParam.cellx = kQualifier_Cell_X;	dummyParam.celly = kQualifier_Cell_Y;	dummyParam.master = d->mainMaster;		SetConditionField( d, &dummyParam, aCondition, kQualifier_Subject_ID, true);	SetConditionField( d, &dummyParam, aCondition, kQualifier_Subject_Is_Player_ID, true);	SetConditionField( d, &dummyParam, aCondition, kQualifier_Flag_ID, true);	d->condition.flags = aCondition->flags;	SetConditionField( d, &dummyParam, aCondition, kQualifier_Direct_ID, true);	SetConditionField( d, &dummyParam, aCondition, kQualifier_Action_Index_ID, true);	SetConditionField( d, &dummyParam, aCondition, kQualifier_Action_Num_ID, true);		dummyParam.layer = 0;	dummyParam.cellx = kCondition_Master_Cell_X;	dummyParam.celly = kCondition_Master_Cell_Y;	SetConditionField( d, &dummyParam, aCondition, kCondition_Popup_ID, true);		dummyParam.layer = aCondition->condition;	dummyParam.cellx = kCondition_Main_Cell_X;	dummyParam.celly = kCondition_Main_Cell_Y;	dummyParam.master = d->conditionValues;	SetConditionField( d, &dummyParam, aCondition, 		(kPanel_ID_Offset + (kPanel_ID_Multiplier * aCondition->condition )), true);	SetConditionField( d, &dummyParam, aCondition, 		(kPanel_ID_Offset + (kPanel_ID_Multiplier * aCondition->condition ))+2, true);	SetConditionField( d, &dummyParam, aCondition, 		(kPanel_ID_Offset + (kPanel_ID_Multiplier * aCondition->condition ))+4, true);	HSetState( d->conditionData, conditionDataState);}static void Window_SetCondition_FromControls( Condition_EditorWindowType *d, CWindowPtr window,	long index){	SignedByte					conditionDataState;	GrafPtr						oldPort;	scenarioConditionType		*aCondition;	huiPlainControlParamType	dummyParam;		mAssert( d != nil);	if (( d->conditionData == nil) || ( d->conditionNumber <= 0)) return;	if ( d->chooseOnly) return;		mAssert( d->conditionData != nil);		conditionDataState = HGetState( d->conditionData);	HLock( d->conditionData);	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);		aCondition = (scenarioConditionType *)*d->conditionData + index;		BlockMoveData( &d->condition, aCondition, sizeof( scenarioConditionType));		// set qualifiers	dummyParam.layer = 0;	dummyParam.cellx = kQualifier_Cell_X;	dummyParam.celly = kQualifier_Cell_Y;	dummyParam.master = d->mainMaster;		aCondition->flags = d->condition.flags;	GetConditionField( d, &dummyParam, aCondition, kQualifier_Subject_ID);	GetConditionField( d, &dummyParam, aCondition, kQualifier_Subject_Is_Player_ID);	GetConditionField( d, &dummyParam, aCondition, kQualifier_Flag_ID);	GetConditionField( d, &dummyParam, aCondition, kQualifier_Direct_ID);	GetConditionField( d, &dummyParam, aCondition, kQualifier_Action_Index_ID);	GetConditionField( d, &dummyParam, aCondition, kQualifier_Action_Num_ID);		dummyParam.layer = 0;	dummyParam.cellx = kCondition_Master_Cell_X;	dummyParam.celly = kCondition_Master_Cell_Y;	GetConditionField( d, &dummyParam, aCondition, kCondition_Popup_ID);		dummyParam.layer = aCondition->condition;	dummyParam.cellx = kCondition_Main_Cell_X;	dummyParam.celly = kCondition_Main_Cell_Y;	dummyParam.master = d->conditionValues;	GetConditionField( d, &dummyParam, aCondition, 		(kPanel_ID_Offset + (kPanel_ID_Multiplier * aCondition->condition )));	GetConditionField( d, &dummyParam, aCondition, 		(kPanel_ID_Offset + (kPanel_ID_Multiplier * aCondition->condition ))+2);	GetConditionField( d, &dummyParam, aCondition, 		(kPanel_ID_Offset + (kPanel_ID_Multiplier * aCondition->condition ))+4);		BlockMoveData( aCondition, &d->condition, sizeof( scenarioConditionType));	HSetState( d->conditionData, conditionDataState);}static void SetConditionField( Condition_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioConditionType *c, long id, Boolean draw){	ControlHandle	aControl;	Str255			s;		if ( dummyParam == nil) return;	if ( c == nil) return;	if ( id < 0) return;		aControl = HUI_Control_Get( dummyParam->master, dummyParam->layer, dummyParam->cellx,		dummyParam->celly, id);	if ( aControl == nil) return;		switch( id)	{		case kCondition_Popup_ID:			SetControlValue( aControl, c->condition + 1);			ChangeWhichCondition( d, c->condition);			break;					// qualifiers		case kQualifier_Flag_ID:			HU_Menu_SetCheckFromBits( aControl, c->flags, 0, 2);			break;					case kQualifier_Subject_ID:			SetControlTextItemLong( aControl, c->subjectObject);			break;		case kQualifier_Subject_Is_Player_ID:			SetControlValue( aControl, (c->subjectObject == -2)?(1):(0));			{//				ControlHandle	tControl = HUI_Control_Get( dummyParam->master, dummyParam->layer, dummyParam->cellx,//					dummyParam->celly, kQualifier_Subject_ID);				//				if ( tControl != nil)				{					if ( c->subjectObject == -2)					{						HUI_Control_Hilite( dummyParam->master, dummyParam->layer, dummyParam->cellx,							dummyParam->celly, kQualifier_Subject_ID, 0);						HUI_Control_Hilite( dummyParam->master, dummyParam->layer, dummyParam->cellx,							dummyParam->celly, kQualifier_Subject_Choose_ID, 0);					}					else if ( !d->chooseOnly)					{						HUI_Control_Hilite( dummyParam->master, dummyParam->layer, dummyParam->cellx,							dummyParam->celly, kQualifier_Subject_ID, 1);						HUI_Control_Hilite( dummyParam->master, dummyParam->layer, dummyParam->cellx,							dummyParam->celly, kQualifier_Subject_Choose_ID, 1);					}				}			}			break;					case kQualifier_Direct_ID:			SetControlTextItemLong( aControl, c->directObject);			break;		case kQualifier_Action_Index_ID://			SetControlTextItemLong( aControl, c->startVerb);			SetControlTextItemString( aControl,				GetActionNameFromDiscreteActionID(				d->heraFile, c->startVerb, s, true));			break;		case kQualifier_Action_Num_ID://			SetControlTextItemLong( aControl, c->verbNum);			break;					case (kCI_ID):		case (kCG_ID):		case (kCN_ID):			SetControlTextItemLong( aControl, c->conditionArgument.counter.whichCounter);			break;		case (kCI_ID+2):		case (kCG_ID+2):		case (kCN_ID+2):			SetControlTextItemLong( aControl, c->conditionArgument.counter.whichPlayer);			break;		case (kCI_ID+4):		case (kCG_ID+4):		case (kCN_ID+4):			SetControlTextItemLong( aControl, c->conditionArgument.counter.amount);			break;				case (kLC_ID):		case (kCM_ID+2):		case (kCC_ID+2):			SetControlTextItemLong( aControl, c->conditionArgument.location.h);			break;		case (kLC_ID+2):		case (kCM_ID):		case (kCC_ID):			SetControlTextItemLong( aControl, c->conditionArgument.location.v);			break;				case kPX_ID:		case kOW_ID:		case kDE_ID:		case kAG_ID:		case kTM_ID:		case kRN_ID:		case kDG_ID:		case kNS_ID:		case kZL_ID:			SetControlTextItemLong( aControl, c->conditionArgument.longValue);			break;				case kVE_ID:			SetControlTextItemSmallFixed( aControl, c->conditionArgument.longValue);			break;	}	if ( draw) Draw1Control( aControl);}static void GetConditionField( Condition_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioConditionType *c, long id){	ControlHandle	aControl;#pragma unused ( d)	if ( dummyParam == nil) return;	if ( c == nil) return;	if ( id < 0) return;		aControl = HUI_Control_Get( dummyParam->master, dummyParam->layer, dummyParam->cellx,		dummyParam->celly, id);	if ( aControl == nil) return;		switch( id)	{		case kCondition_Popup_ID:			c->condition = (conditionType)(GetControlValue( aControl) - 1);			break;					// qualifiers		case kQualifier_Flag_ID:			break;					case kQualifier_Subject_ID:			c->subjectObject = GetControlTextItemLong( aControl);			break;		case kQualifier_Subject_Is_Player_ID:			if ( GetControlValue( aControl))				c->subjectObject = -2;			break;					case kQualifier_Direct_ID:			c->directObject = GetControlTextItemLong( aControl);			break;		case kQualifier_Action_Index_ID://			c->startVerb = GetControlTextItemLong( aControl);			break;		case kQualifier_Action_Num_ID://			c->verbNum = GetControlTextItemLong( aControl);			break;					case (kCI_ID):		case (kCG_ID):		case (kCN_ID):			c->conditionArgument.counter.whichCounter = GetControlTextItemLong( aControl);			break;		case (kCI_ID+2):		case (kCG_ID+2):		case (kCN_ID+2):			c->conditionArgument.counter.whichPlayer = GetControlTextItemLong( aControl);			break;		case (kCI_ID+4):		case (kCG_ID+4):		case (kCN_ID+4):			c->conditionArgument.counter.amount = GetControlTextItemLong( aControl);			break;				case (kLC_ID):		case (kCM_ID+2):		case (kCC_ID+2):			c->conditionArgument.location.h = GetControlTextItemLong( aControl);			break;		case (kLC_ID+2):		case (kCM_ID):		case (kCC_ID):			c->conditionArgument.location.v = GetControlTextItemLong( aControl);			break;				case kPX_ID:		case kOW_ID:		case kDE_ID:		case kAG_ID:		case kTM_ID:		case kRN_ID:		case kDG_ID:		case kNS_ID:		case kZL_ID:			c->conditionArgument.longValue = GetControlTextItemLong( aControl);			break;				case kVE_ID:			c->conditionArgument.longValue = GetControlTextItemSmallFixed( aControl);			break;	}}static void Setup_ConditionValues_Panel( Condition_EditorWindowType *d, CWindowPtr window){	huiPlainControlParamType	buttonParam, textParam;	huiCellParamType			cellParam;	short						i;#pragma unused( window)	// set up all cells	cellParam.master = d->conditionValues;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_center;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	// set up main cell	for ( i = 0; i < kCondition_Panel_Num; i++)	{			cellParam.colSpan = 1;			cellParam.rowSpan = 1;			SetRect( &cellParam.inSpace, -1, 0, -1, 12);			SetRect( &cellParam.outSpace, 4, 4, 4, 4);			HUI_Cell_Set( i, kCondition_Main_Cell_X, kCondition_Main_Cell_Y, &cellParam);			SetRect( &cellParam.outSpace, -1, -1, -1, -1);	}		// set up buttons, general	buttonParam.master = d->conditionValues;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;	buttonParam.fontStyle.font = kSmallFontNum;	buttonParam.fontStyle.size = kSmallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = teCenter;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;	buttonParam.flags = huiControlFlag_none;	buttonParam.cellx = kCondition_Main_Cell_X;	buttonParam.celly = kCondition_Main_Cell_Y;		// set up text, general		textParam.master = d->conditionValues;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = 8;	textParam.space.top = 12;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = -1;	textParam.cellx = kCondition_Main_Cell_X;	textParam.celly = kCondition_Main_Cell_Y;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;		// ----------------------------------	// location condition	// ----------------------------------	textParam.layer = kLocationCondition;		textParam.id = kLC_ID - 1;	GetIndString( textParam.label, kStrResID, 1);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);	// ----------------------------------	// counter is condition	// ----------------------------------	textParam.layer = kCounterCondition;		textParam.id = kCI_ID-1;	GetIndString( textParam.label, kStrResID, 2);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kCI_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id = kCI_ID+1;	GetIndString( textParam.label, kStrResID, 3);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kCI_ID+2;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id = kCI_ID+3;	GetIndString( textParam.label, kStrResID, 4);	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kCI_ID+4;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	// ----------------------------------	// counter greater condition	// ----------------------------------	textParam.layer = kCounterGreaterCondition;		textParam.id = kCG_ID-1;	GetIndString( textParam.label, kStrResID, 2);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kCG_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id =  kCG_ID+1;	GetIndString( textParam.label, kStrResID, 3);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kCG_ID+2;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id =  kCG_ID+3;	GetIndString( textParam.label, kStrResID, 5);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kCG_ID+4;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	// ----------------------------------	// counter not condition	// ----------------------------------	textParam.layer = kCounterNotCondition;		textParam.id = kCN_ID-1;	GetIndString( textParam.label, kStrResID, 2);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kCN_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id = kCN_ID+1;	GetIndString( textParam.label, kStrResID, 3);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kCN_ID+2;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id = kCN_ID+3;	GetIndString( textParam.label, kStrResID, 6);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kCN_ID+4;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	// ----------------------------------	// proximity condition	// ----------------------------------	textParam.layer = kProximityCondition;		textParam.id = kPX_ID-1;	GetIndString( textParam.label, kStrResID, 11);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kPX_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id = kPX_ID+1;	GetIndString( textParam.label, kStrResID, 12);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);	// ----------------------------------	// distance greater condition	// ----------------------------------	textParam.layer = kDistanceGreaterCondition;		textParam.id = kDG_ID-1;	GetIndString( textParam.label, kStrResID, 13);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kDG_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id = kDG_ID+1;	GetIndString( textParam.label, kStrResID, 14);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);	// ----------------------------------	// owner condition	// ----------------------------------	textParam.layer = kOwnerCondition;		textParam.id = kOW_ID-1;	GetIndString( textParam.label, kStrResID, 9);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kOW_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	// ----------------------------------	// destruction condition	// ----------------------------------	textParam.layer = kDestructionCondition;		textParam.id = kDE_ID-1;	GetIndString( textParam.label, kStrResID, 7);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kDE_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id = kDE_ID+1;	GetIndString( textParam.label, kStrResID, 8);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);	// ----------------------------------	// age condition	// ----------------------------------	textParam.layer = kAgeCondition;		textParam.id = kAG_ID - 1;	GetIndString( textParam.label, kStrResID, 21);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);	// ----------------------------------	// time condition	// ----------------------------------	textParam.layer = kTimeCondition;		textParam.id = kTM_ID-1;	GetIndString( textParam.label, kStrResID, 10);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kTM_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	// ----------------------------------	// random condition	// ----------------------------------	textParam.layer = kRandomCondition;		textParam.id = kRN_ID - 1;	GetIndString( textParam.label, kStrResID, 22);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);	// ----------------------------------	// half health condition	// ----------------------------------	textParam.layer = kHalfHealthCondition;		textParam.id = kHH_ID - 1;	GetIndString( textParam.label, kStrResID, 15);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		// ----------------------------------	// is aux condition	// ----------------------------------	textParam.layer = kIsAuxiliaryObject;		textParam.id = kAX_ID - 1;	GetIndString( textParam.label, kStrResID, 16);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		// ----------------------------------	// is target condition	// ----------------------------------	textParam.layer = kIsTargetObject;		textParam.id = kTG_ID - 1;	GetIndString( textParam.label, kStrResID, 17);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);	// ----------------------------------	// velocity less than equal to condition	// ----------------------------------	textParam.layer = kVelocityLessThanEqualToCondition;		textParam.id = kVE_ID-1;	GetIndString( textParam.label, kStrResID, 18);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kVE_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	// ----------------------------------	// no ships left condition	// ----------------------------------	textParam.layer = kNoShipsLeftCondition;		textParam.id = kNS_ID-1;	GetIndString( textParam.label, kStrResID, 19);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kNS_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id = kNS_ID+1;	GetIndString( textParam.label, kStrResID, 20);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);	// ----------------------------------	// current message condition condition	// ----------------------------------	textParam.layer = kCurrentMessageCondition;		textParam.id = kCM_ID-1;	GetIndString( textParam.label, kStrResID, 23);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kCM_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id =  kCM_ID+1;	GetIndString( textParam.label, kStrResID, 24);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kCM_ID+2;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	// ----------------------------------	// current computer condition condition	// ----------------------------------	textParam.layer = kCurrentComputerCondition;		textParam.id = kCC_ID-1;	GetIndString( textParam.label, kStrResID, 35);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kCC_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	textParam.id =  kCC_ID+1;	GetIndString( textParam.label, kStrResID, 36);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kCC_ID+2;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);	// ----------------------------------	// zoom level condition	// ----------------------------------	textParam.layer = kZoomLevelCondition;		textParam.id = kZL_ID-1;	GetIndString( textParam.label, kStrResID, 37);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kZL_ID;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);}static void AddBitPopUp( huiPlainControlParamType *textParam,	huiPlainControlParamType *buttonParam, long id, short resID, short index,	Boolean newLine, short menuStrResID){	//  label	textParam->id = id-1;	GetIndString( textParam->label, resID, index); // which base type	textParam->whichTabSet = 0;	textParam->whichTab = 0;	textParam->flags = (newLine)?(huiControlFlag_newLine):(huiControlFlag_none);	textParam->minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( textParam);		buttonParam->id = id;	buttonParam->special.menuStrList.strList = GetStringList( menuStrResID);	buttonParam->special.menuStrList.menuID = HU_GetNewMenuID();//id;	buttonParam->special.menuStrList.cicnResID = 128;	buttonParam->special.menuStrList.multiSelect = true;	buttonParam->whichTabSet = 0;	buttonParam->whichTab = 1;	buttonParam->flags = huiControlFlag_none;	buttonParam->space.left = 8;		HUI_BevelButtonMenu_New_StrList( buttonParam);	buttonParam->whichTabSet = -1;	buttonParam->whichTab = -1;	if ( buttonParam->special.menuStrList.strList != nil)		ReleaseResource( buttonParam->special.menuStrList.strList);			// set attributes button	buttonParam->id = id + 2;	GetIndString( buttonParam->label, kHera_AppStrResID, 8); // setÉ	buttonParam->space.left = 8;	buttonParam->minMaxBounds.right = kHUI_Pixel_Max;	buttonParam->minMaxBounds.left = 0;	HUI_PushButton_New_LiteralP( buttonParam);}static void GetAllData( Condition_EditorWindowType *d){	short						oldResRefNum = 0;	ControlHandle				aControl;	ListHandle					list;//	OSErr						err;	long						conditionNum = 0;		if ( d == nil) return;	oldResRefNum = CurResFile();//	UseResFile( d->resRefNum);	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);	/*	d->conditionData = GetResource( 'sncd', 500);	if ( d->conditionData == nil) d->conditionData = NewHandle(0);	else	{		DetachResource( d->conditionData);	}	if ( d->conditionData == nil)	{		goto GetAllData_error;	}*/	if ( d->discreteData == nil)	{		d->discreteData = HD_Find_Discrete_Data( d->heraFile, 			d->discreteDataID, -1, nil,			kHera_Condition_Type);		mAssert( d->discreteData != nil);	}	if (( d->discreteData != nil) && ( d->conditionData == nil))	{		long	offset, size;				HD_DiscreteData_GetOffsetAndSize( d->discreteData, &offset, &size);		d->startConditionIndex = 0;		d->conditionNumber = size / sizeof( scenarioConditionType);				if ( d->conditionData != nil) DisposeHandle( d->conditionData);		d->conditionData = NewHandle( size);		mAssert( d->conditionData != nil);		if ( d->conditionData == nil) return;				BlockMove( *d->discreteData + offset, *d->conditionData, size);	}		aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Cell		cell;				conditionNum = GetHandleSize( d->conditionData) / sizeof( scenarioConditionType);		if ( conditionNum > 0)		{			if ( d->startConditionIndex >= conditionNum) d->startConditionIndex = conditionNum - 1;			if (( d->startConditionIndex + d->conditionNumber) > conditionNum)				d->conditionNumber = (conditionNum - d->startConditionIndex);		} else d->startConditionIndex = 0;		GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			short	i = d->startConditionIndex, count = d->conditionNumber;			Str255	s;						LDelRow( 0, 0, list);	// delete all rows			(*list)->selFlags = lOnlyOne;						cell.h = 0;			while ( count > 0)			{//				GetIndString( s, 4201, i);				MakeConditionName( d->heraFile, nil, d->conditionData, i, nil, nil, s);				if ( s[0] == 0) pstrcpy( s, "\puntitled");//				if ( s[0] != 0)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( (Ptr)(&s[1]), s[0], cell, list );				}				i ++;				count--;			}		}	}	conditionNum = GetHandleSize( d->conditionData) / sizeof( scenarioConditionType);	if ( d->conditionIndex >= conditionNum) d->conditionIndex = conditionNum - 1;	d->conditionIndex = HUI_Control_SetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, d->conditionIndex);	Window_SetControls_FromConditionIndex( d,		GetWindowPtrFromDispatchWindowID( d->windowID), d->conditionIndex + d->startConditionIndex);	GetAllData_error:		UseResFile( oldResRefNum);}static void SetConditionFlags( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Condition_EditorWindowType			*d;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Condition_EditorWindowType *)*data;	if ( d->chooseOnly)	{		HSetState( data, dataState);		return;	}	d->condition.flags = bits;	HU_HUIMenu_SetCheckFromBits( d->mainMaster, 0, kQualifier_Cell_X, kQualifier_Cell_Y,		kQualifier_Flag_ID, bits, 0, 2);		HSetState( data, dataState);}static void OKConfirmCallBack( long whichButton, long windowID){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Condition_EditorWindowType		*d;	Boolean							same = true;	CWindowPtr						whichWindow =								GetWindowPtrFromDispatchWindowID( windowID);		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Condition_EditorWindowType *)*data;	if ( whichButton == 1)	{		Window_SetCondition_FromControls( d,			whichWindow, d->conditionIndex + d->startConditionIndex);					if ( d->modal)			gHera->modalMode--;//		HU_UseResFile( d->resRefNum, &resRefNum);//		Resource_Replace( 'sncd', 500, d->conditionData, "\pHera Conditions");//		UpdateResFile( d->resRefNum);//		UseResFile( resRefNum);		if (( d->discreteData != nil) && ( d->conditionData != nil))		{			if ( !d->chooseOnly)			{				HD_DiscreteData_Replace_Compare( d->discreteData, d->conditionData,					kHera_Condition_Type, &same);								if ( !same) d->heraFile->changed = true;			}			DisposeHandle( d->conditionData);		}		if ( d->callBack != nil) d->callBack( d->callerID, d->discreteDataID,												d->conditionNumber,												d->dataChanges);		HD_DataChanges_DeleteAll( d->dataChanges);		HUI_MasterControl_Delete( d->master);		CloseDispatchWindow( d->windowID); // d and data no longer valid	} else	{		HSetState( data, dataState);	}}static void CancelConfirmCallBack( long whichButton, long windowID){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Condition_EditorWindowType		*d;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Condition_EditorWindowType *)*data;	if ( whichButton == 1)	{		if ( d->modal)			gHera->modalMode--;		if ( d->conditionData != nil)			DisposeHandle( d->conditionData);		HUI_MasterControl_Delete( d->master);		CloseDispatchWindow( d->windowID); // d and data no longer valid	} else	{		HSetState( data, dataState);	}}static void Initial_Subject_CallBack( long dispatchID, long initialFirst,	long initialNum, long initialSelection, heraDataChangesType *changesList){	Handle						windowData =									GetDispatchWindowDataHandle( dispatchID);	Condition_EditorWindowType	*d;	SignedByte					dataState;	huiPlainControlParamType	dummyParam;#pragma unused ( initialFirst, initialNum, changesList)	mAssert( windowData != nil);	if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);				d = (Condition_EditorWindowType *)*windowData;	if ( d->chooseOnly)	{		HSetState( windowData, dataState);		return;	}		d->condition.subjectObject = initialSelection;	dummyParam.master = d->mainMaster;	dummyParam.cellx = kQualifier_Cell_X;	dummyParam.celly = kQualifier_Cell_Y;	dummyParam.layer = 0;		SetConditionField( d, &dummyParam, &d->condition,		kQualifier_Subject_ID, true);	HSetState( windowData, dataState);}static void Initial_Direct_CallBack( long dispatchID, long initialFirst,	long initialNum, long initialSelection, heraDataChangesType *changesList){	Handle						windowData =									GetDispatchWindowDataHandle( dispatchID);	Condition_EditorWindowType	*d;	SignedByte					dataState;	huiPlainControlParamType	dummyParam;	#pragma unused ( initialFirst, initialNum, changesList)	mAssert( windowData != nil);	if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);				d = (Condition_EditorWindowType *)*windowData;	d->condition.directObject = initialSelection;	if ( d->chooseOnly)	{		HSetState( windowData, dataState);		return;	}	dummyParam.master = d->mainMaster;	dummyParam.cellx = kQualifier_Cell_X;	dummyParam.celly = kQualifier_Cell_Y;	dummyParam.layer = 0;		SetConditionField( d, &dummyParam, &d->condition,		kQualifier_Direct_ID, true);	HSetState( windowData, dataState);}static void Action_Editor_CallBack( long dispatchID, long actionID,	long actionNum){	Handle						windowData =									GetDispatchWindowDataHandle( dispatchID);	Condition_EditorWindowType	*d;	SignedByte					dataState;	huiPlainControlParamType	dummyParam;		mAssert( windowData != nil);	if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);				d = (Condition_EditorWindowType *)*windowData;	if ( d->chooseOnly)	{		HSetState( windowData, dataState);		return;	}	d->condition.startVerb = actionID;	d->condition.verbNum = actionNum;	dummyParam.master = d->mainMaster;	dummyParam.cellx = kQualifier_Cell_X;	dummyParam.celly = kQualifier_Cell_Y;	dummyParam.layer = 0;		SetConditionField( d, &dummyParam, &d->condition,		kQualifier_Action_Index_ID, true);	HSetState( windowData, dataState);}static void InsertCondition( Condition_EditorWindowType *d, CWindowPtr whichWindow){	Ptr					data = nil;	long				dataLength;	ControlHandle		aControl;	Str255				s;		d->heraFile->changed = true;		Window_SetCondition_FromControls( d,		whichWindow, d->conditionIndex + d->startConditionIndex);		if ( d->conditionNumber > 0)	{		HUI_Control_GetListCell( 			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 0, d->conditionIndex,			&data, &dataLength);				HU_Handle_InsertData( d->conditionIndex, d->conditionData,			(Ptr)&d->condition,			sizeof( scenarioConditionType), 0);		HUI_Control_InsertListRows(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 1, d->conditionIndex);		if ( data != nil)		{			HUI_Control_SetListCell( 				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, 0, d->conditionIndex,				data, dataLength);						DisposePtr( data);		}		d->conditionNumber++;		d->dataChanges = HD_DataChanges_Add( d->dataChanges, d->conditionIndex,			1, 1);		d->conditionIndex++;		GetAllData( d); // this will correctly set list cells & selection	} else	{		d->conditionNumber = 1;			d->condition.condition = kNoCondition;		d->condition.conditionArgument.location.h =			d->condition.conditionArgument.location.v = 0;		d->condition.subjectObject = -1;		d->condition.directObject = -1;		d->condition.startVerb = -1;		d->condition.verbNum = -1;		d->condition.flags = kTrueOnlyOnce;		d->condition.direction = 0;				HU_Handle_InsertData( d->conditionIndex, d->conditionData, (Ptr)&d->condition,			sizeof( scenarioConditionType), 0);		MakeConditionName( d->heraFile, &d->condition, nil, 0, nil, nil, s);				d->conditionIndex = 0;				HUI_Control_InsertListRows(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 1, d->conditionIndex);				HUI_Control_SetListCell( 			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 0, d->conditionIndex,			(Ptr)&s[1], s[0]);		Window_SetControls_FromConditionIndex(			d, whichWindow, d->conditionIndex + d->startConditionIndex			);		d->dataChanges = HD_DataChanges_Add( d->dataChanges, 9999,			1, 1);				Enable_Editing( d, true);	}	d->conditionIndex = 		HUI_Control_GetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->conditionIndex);	aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Draw1Control( aControl);	}	}static void DeleteCondition( Condition_EditorWindowType *d, CWindowPtr whichWindow){	ControlHandle	aControl;#pragma unused( whichWindow)	if ( d->conditionNumber <= 0) return;		d->heraFile->changed = true;		HU_Handle_DeleteData( d->conditionIndex, d->conditionData,		sizeof( scenarioConditionType), 0);		HUI_Control_DeleteListRows(		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, 1, d->conditionIndex);		d->dataChanges = HD_DataChanges_Add( d->dataChanges, d->conditionIndex,		1, -1);	d->conditionIndex = 		HUI_Control_SetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->conditionIndex);	aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		ListHandle	list = nil;				GetListBoxListHandle( aControl, &list);		if ( list != nil)		{			LAutoScroll(list);		}		Draw1Control( aControl);	}		d->conditionNumber--;	if ( d->conditionNumber <= 0) Enable_Editing( d, false);	//	Window_SetControls_FromConditionIndex(//		d, whichWindow, d->conditionIndex + d->startConditionIndex//		);	GetAllData( d);}static void Enable_Editing( Condition_EditorWindowType *d, Boolean enable){	HUI_Cell_Set_Enabled( d->master, 0, kMain_Cell_X, kMain_Cell_Y, enable);}static StringPtr Condition_Editor_ChildWindow_NameMaker(	Condition_EditorWindowType *d, StringPtr destString){	Str255	tString;		if (( d == nil) || ( destString == nil)) return nil;		pstrcpy( destString, d->titlePrefix);	pstrcat( destString, "\p: Condition #");	NumToString( d->conditionIndex, tString);	pstrcat( destString, tString);	return destString;}#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/OSErr Condition_Editor_NewWindow( heraScenarioFileType *heraFile, 	StringPtr titlePrefix, short resRefNum,	long discreteDataID, Boolean chooseOnly, Boolean modal, long callerID,	long scenario_initialDataID, Condition_Editor_Callback_procPtr callBack){	Rect						bounds;	CWindowPtr					newWindow;	ControlHandle				rootControl, aControl;	huiPlainControlParamType	buttonParam, textParam, groupParam;	huiMasterControlParamType	masterParam;	OSStatus					err;	Handle						data, strList;	Condition_EditorWindowType		*d;	long						maxWidth = 0, i;	long						windowID = -1;	huiCellParamType			cellParam;	Str255						title;	#pragma unused ( err, textParam, aControl)			if ( discreteDataID < 0)	{		Handle	newDiscreteData;				discreteDataID = HD_Get_NextID_From_Type( heraFile, 			kHera_Condition_Type);		newDiscreteData = HD_Create_Discrete_Data(			heraFile, nil, 0, 0, discreteDataID,			kHera_Condition_Type);		if ( newDiscreteData != nil)			discreteDataID = ((heraDataHeaderType *)*newDiscreteData)->id;	}	// create the new window	data = NewHandle( sizeof( Condition_EditorWindowType));	if ( data == nil) return memFullErr;		HLock( data);	d = (Condition_EditorWindowType *)*data;		if ( heraFile->fileRefNum <= 0) chooseOnly = true;		d->windowID = -1;	d->conditionData = nil;	d->conditionIndex = 0;	d->whatCondition = -1;	d->startConditionIndex = 0;	d->conditionNumber = -1;	d->resRefNum = resRefNum;	d->setConditionFlags_WindowID = -1;	d->anyChanges = false;	d->chooseOnly = chooseOnly;	d->modal = modal;	d->discreteDataID = discreteDataID;	d->callerID = callerID;	d->callBack = callBack;	d->discreteData = nil;	d->dataChanges = nil;	d->scenario_initialDataID = scenario_initialDataID;	d->heraFile = heraFile;	if ( titlePrefix == nil)	{		d->titlePrefix[0] = 0;		pstrcpy( title, "\pConditions");	} else	{		pstrcpy( d->titlePrefix, titlePrefix);		pstrcpy( title, titlePrefix);		pstrcat( title, "\p: Conditions");	}		SetRect( &bounds, 64, 64, 128, 128);	if ( modal)	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowMovableModalDialogProc, (WindowPtr)-1, false,			HandleEvent, 0,			&windowID);	} else	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowDocumentProc, (WindowPtr)-1, false,			HandleEvent, 0,			&windowID);	}	SetDispatchWindowDataHandle( windowID, data);	d->windowID = windowID;		SetThemeWindowBackground( (WindowPtr)newWindow,		kThemeActiveDialogBackgroundBrush, true);	SetPortWindowPort( (WindowPtr)newWindow);	CreateRootControl( (WindowPtr)newWindow, &rootControl);	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kRowNum;	masterParam.colNum = kColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->master = HUI_MasterControl_New( nil, 0, 0, 0, &masterParam);		mAssert( d->master != nil);	if ( d->master == nil) return memFullErr;	d->master->tab[0][0].h = 112;	d->master->tab[0][0].hAlign = hui_halign_right;	HUI_Master_ShowLayer( d->master, 0);		cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	cellParam.colSpan = 1;	cellParam.rowSpan = 2;	HUI_Cell_Set( 0, kMain_Cell_X, kMain_Cell_Y, &cellParam);	// set up list cell	SetRect( &cellParam.outSpace, 12, -1, -1, 5);	SetRect( &cellParam.inSpace, 3, -1, 3, 3);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_right;	cellParam.minMaxBounds.top = 100;	HUI_Cell_Set( 0, kList_Cell_X, kList_Cell_Y, &cellParam);	cellParam.minMaxBounds.top = 0;	cellParam.minMaxBounds.top = 0;		// set up list button cells	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.baseLine = gHera->smallFontSize;	cellParam.hAlign = hui_halign_center;	d->master->rowDontExpand[kList_Button_Cell_Y] = true;	HUI_Cell_Set( 0, kList_Button_Cell_X, kList_Button_Cell_Y, &cellParam);	cellParam.minMaxBounds.bottom = kHUI_Pixel_Max;	// set up buttons, general	buttonParam.master = d->master;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask | kControlUseJustMask;	buttonParam.fontStyle.font = gHera->smallFontNum;	buttonParam.fontStyle.size = gHera->smallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = teCenter;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;	buttonParam.flags = huiControlFlag_none;		if ( d->chooseOnly) buttonParam.enabled = false;		// set up text, general		textParam.master = d->master;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = 8;	textParam.space.top = 12;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = -1;	textParam.cellx = kCondition_Main_Cell_X;	textParam.celly = kCondition_Main_Cell_Y;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;	if ( d->chooseOnly) textParam.enabled = false;		// make selection list	buttonParam.enabled = true;	buttonParam.id = kList_ID;	buttonParam.minMaxBounds.left = 240;	buttonParam.minMaxBounds.right = 240;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;//200;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.bottom = 200;	buttonParam.cellx = kList_Cell_X;	buttonParam.celly = kList_Cell_Y;	buttonParam.special.listBox.ldesResID = 128;	buttonParam.special.listBox.refCon = 0;	buttonParam.flags = huiControlFlag_useCellV;	HUI_ListBox_New_LiteralP( &buttonParam);		if ( d->chooseOnly) buttonParam.enabled = false;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// set up list buttons		buttonParam.id = kList_Add_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 9);	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.id = kList_Remove_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 10);	HUI_PushButton_New_LiteralP( &buttonParam);	// set up main sub-master	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kMain_Master_RowNum;	masterParam.colNum = kMain_Master_ColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->mainMaster = HUI_MasterControl_New( d->master, 0, kMain_Cell_X,		kMain_Cell_Y, &masterParam);	mAssert( d->mainMaster != nil);	if ( d->mainMaster == nil) return memFullErr;	HUI_Master_ShowLayer( d->mainMaster, 0);	d->mainMaster->tab[0][0].h = kLarge_Tab_Width;	d->mainMaster->tab[0][0].hAlign = hui_halign_right;	d->mainMaster->tab[0][1].h = kLarge_Tab_Width;	d->mainMaster->tab[0][1].hAlign = hui_halign_left;	d->mainMaster->tab[0][2].h = kLarge_Tab_Width * 3;	d->mainMaster->tab[0][2].hAlign = hui_halign_right;	d->mainMaster->tab[0][3].h = kLarge_Tab_Width * 3;	d->mainMaster->tab[0][3].hAlign = hui_halign_left;	// set up main master cells	cellParam.master = d->mainMaster;	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_center;	SetRect( &cellParam.outSpace, -1, -1, 12, -1);	SetRect( &cellParam.inSpace, -1, 20, -1, -1);	HUI_Cell_Set( 0, kQualifier_Master_Cell_X, kQualifier_Master_Cell_Y, &cellParam);	HUI_Cell_Set( 0, kCondition_Master_Cell_X, kCondition_Master_Cell_Y, &cellParam);	// set up condition selection group		groupParam.master = d->mainMaster;	groupParam.visible = true;	groupParam.enabled = true;	groupParam.whichTabSet = -1;	groupParam.whichTab = -1;	groupParam.layer = 0;	groupParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;	groupParam.fontStyle.font = gHera->smallFontNum;	groupParam.fontStyle.size = gHera->smallFontSize;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;	groupParam.helpStringResID = -1;	groupParam.id = kCondition_Popup_ID;	groupParam.cellx = kCondition_Master_Cell_X;	groupParam.celly = kCondition_Master_Cell_X;	groupParam.special.menuStrList.strList = GetStringList( 570);	groupParam.fontStyle.style = gHera->smallFontStyle;		if ( d->chooseOnly) groupParam.enabled = false;	if ( groupParam.special.menuStrList.strList != nil)	{		groupParam.special.menuStrList.menuID = HU_GetNewMenuID();//119;		groupParam.special.menuStrList.multiSelect = false;		SetRect( &groupParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);		groupParam.label[0] = 0;		HUI_Group_PopupButton_New_StrList( &groupParam);		ReleaseResource( groupParam.special.menuStrList.strList);	}	groupParam.enabled = true;	groupParam.cellx = kQualifier_Cell_X;	groupParam.celly = kQualifier_Cell_Y;	groupParam.id = kQualifier_ID_Offset;	groupParam.special.group.isSecondary = false;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;	GetIndString( groupParam.label, kStrResID, 33);	HUI_Group_New_LiteralP( &groupParam);		// set up condition values master	masterParam.rowNum = kCondition_Master_RowNum;	masterParam.colNum = kCondition_Master_ColNum;	masterParam.layerNum = kCondition_Panel_Num;	d->conditionValues = HUI_MasterControl_New( d->mainMaster, 0, kCondition_Master_Cell_X,		kCondition_Master_Cell_Y, &masterParam);			mAssert( d->conditionValues != nil);	if ( d->conditionValues == nil) return memFullErr;		d->conditionValues->tab[0][0].h = kLarge_Tab_Width;	d->conditionValues->tab[0][0].hAlign = hui_halign_right;	d->conditionValues->tab[0][1].h = kLarge_Tab_Width;	d->conditionValues->tab[0][1].hAlign = hui_halign_left;		Setup_ConditionValues_Panel( d, newWindow);	// flags		buttonParam.master = d->mainMaster;		buttonParam.layer = 0;	buttonParam.cellx = kQualifier_Cell_X;	buttonParam.celly = kQualifier_Cell_Y;		textParam.master = d->mainMaster;		textParam.layer = 0;	textParam.cellx = kQualifier_Cell_X;	textParam.celly = kQualifier_Cell_Y;		buttonParam.enabled = true;		AddBitPopUp( &textParam, &buttonParam, kQualifier_Flag_ID, kStrResID, 25,		false, 8019);	if ( d->chooseOnly) buttonParam.enabled = false;		// subject	textParam.id = kQualifier_Subject_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 31);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kQualifier_Subject_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);	buttonParam.enabled = true;	buttonParam.id = kQualifier_Subject_Choose_ID;	buttonParam.flags = huiControlFlag_none;	buttonParam.whichTabSet = -1;	GetIndString( buttonParam.label, 8000, 13);	HUI_PushButton_New_LiteralP( &buttonParam);	if ( d->chooseOnly) buttonParam.enabled = false;		buttonParam.id = kQualifier_Subject_Is_Player_ID;	buttonParam.flags = huiControlFlag_none;	buttonParam.whichTabSet = -1;	GetIndString( buttonParam.label, kStrResID, 34);	HUI_CheckBox_New_LiteralP( &buttonParam);		// direct	textParam.id = kQualifier_Direct_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 32);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kQualifier_Direct_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);	buttonParam.enabled = true;	buttonParam.id = kQualifier_Direct_Choose_ID;	buttonParam.flags = huiControlFlag_none;	buttonParam.whichTabSet = -1;	GetIndString( buttonParam.label, 8000, 13);	HUI_PushButton_New_LiteralP( &buttonParam);	if ( d->chooseOnly) buttonParam.enabled = false;		// action index	textParam.id = kQualifier_Action_Index_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 27);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kQualifier_Action_Index_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_StaticText_New_LiteralP( &textParam);	// action num/*	textParam.id = kQualifier_Action_Num_ID - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 28);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kQualifier_Action_Num_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 3;	HUI_EditText_New_LiteralP( &textParam);*/	buttonParam.enabled = true;	buttonParam.id = kQualifier_Action_Choose_ID;	buttonParam.flags = huiControlFlag_none;	buttonParam.whichTabSet = -1;	GetIndString( buttonParam.label, 8000, 13);	HUI_PushButton_New_LiteralP( &buttonParam);	if ( d->chooseOnly) buttonParam.enabled = false;			buttonParam.master = d->mainMaster;		buttonParam.layer = 0;	buttonParam.cellx = kQualifier_Cell_X;	buttonParam.celly = kQualifier_Cell_Y;	/*	buttonParam.id = kQualifier_Action_Edit_ID;	GetIndString( buttonParam.label, kStrResID, 29);	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.id = kQualifier_Action_Set_ID;	GetIndString( buttonParam.label, kStrResID, 30);	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	HUI_PushButton_New_LiteralP( &buttonParam);*/	strList = GetStringList( kHera_DefaultMainButtonStrResID);	if ( strList != nil)	{		HUI_Main_Buttons_H_Setup( d->master, 0,			kSeparator_Cell_X, kColNum, kSeparator_Cell_Y, 1,				true, strList);				ReleaseResource( strList);	}	HUI_Master_Layout( d->master, (Point){0, 0}, (Point){0, 0});	HUI_Master_HideAllLayers_Deep( d->master);	HUI_Master_ShowAllLayers_Deep( d->master);	HUI_Master_ShowLayer( d->master, 0);		HUI_Master_HideAllLayers_Deep( d->mainMaster);	HUI_Master_ShowAllLayers_Deep( d->mainMaster);	HUI_Master_ShowLayer( d->mainMaster, 0);	HUI_Master_ShowAllControls( d->mainMaster, 0, true);	HUI_Master_HideAllLayers_Deep( d->conditionValues);	HUI_Master_ShowAllLayers_Deep( d->conditionValues);	for ( i = 0; i < d->conditionValues->layerNum; i++)	{		HUI_Master_HideLayer(d->conditionValues, i);	}	d->whatCondition = -1;	ChangeWhichCondition( d, 0);	ShowWindow( (WindowPtr)newWindow);	GetAllData( d);		if ( d->modal)		gHera->modalMode++;		if ( d->conditionNumber <= 0) Enable_Editing( d, false);		HUnlock( data);	return noErr;}// emergyency hack-o-rama/*static void InsertSelectedCondition( Condition_EditorWindowType *d){	scenarioType			*scenario;	scenarioConditionType	condition;	Str255					s;	short					i, oldResFile;	Handle					scenarioData;	long					whichCondition = d->conditionIndex + d->startConditionIndex;			ControlHandle			aControl;		if ( whichCondition >= 0)	{		HU_UseResFile( gHera->default_scenarioFile_refNum,			&oldResFile);		scenarioData = GetResource('snro', 500);		if ( scenarioData == nil) return;		for ( i = 0; i < (GetHandleSize(scenarioData)/sizeof(scenarioType)); i++)		{			scenario = (scenarioType *)*scenarioData + i;			if ( scenario->conditionFirst > whichCondition)			{				scenario->conditionFirst++;			} else if ( ( scenario->conditionFirst <= whichCondition) && ( scenario->conditionFirst >					( whichCondition - scenario->conditionNum)))			{				scenario->conditionNum++;							}					}				ChangedResource( scenarioData);		UpdateResFile( gHera->default_scenarioFile_refNum);		UseResFile( oldResFile);				BlockMoveData( *d->conditionData + 			(sizeof( scenarioConditionType) * whichCondition),			&condition, sizeof( scenarioConditionType));				HU_Handle_InsertData( whichCondition,			d->conditionData, (Ptr)&condition, sizeof( scenarioConditionType), 0);											HUI_Control_InsertListRows(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 1, whichCondition);		MakeConditionName( &condition, nil, -1, nil, nil, s);		HUI_Control_SetListCell( 			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 0, whichCondition,			(Ptr)&s[1], s[0]);					whichCondition = 			HUI_Control_GetListValue(				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, whichCondition);		aControl = HUI_Control_Get( 			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID);		if ( aControl != nil)			Draw1Control( aControl);	}}*/