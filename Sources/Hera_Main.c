/******************************************\|**| PPPT3Exp_Main.c\******************************************/#pragma mark ••INCLUDES••/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#include <Appearance.h>#include <string.h>#pragma mark _third party includes_/* - third party libraries*******************************************/#include "FileCopy.h"#include "MoreFilesExtras.h"#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Assert.h"#include "BP_Error.h"#include "Window Dispatch.h"#include "BPMacOutput.h"#include "Technote.h"//#include "Navigation_Utilities.h"#include "Set Font By String.h"#include "BPMacOutput.h"#include "str_bp.h"#include "strlist.h"#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/#include "Data_Selector.h"#include "Hera_Preferences.h"#include "Hera_Global.h"#include "Hera_Data.h"#include "Memory_Window.h"#include "Hera_ResourceTracker.h"#include "Hera_AppleEvent.h"#include "Button_Window.h"#include "Smart_File.h"#include "ResourceFork_Copy.h"// ares#include "Scenario_Data.h"#pragma mark ••DEFINITIONS••/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kMenuBarID				500#pragma mark _macros_/* - macros*******************************************/#pragma mark ••TYPEDEFS••/******************************************\|**| typedefs\******************************************/#pragma mark ••EXTERNAL GLOBALS••/******************************************\|**| external globals\******************************************/extern WindowPtr			gHilitedWindow;#pragma mark ••PRIVATE GLOBALS••/******************************************\|**| private globals\******************************************/MenuHandle			gAppleMenu = nil;heraGlobalType		*gHera = nil;#pragma mark ••PRIVATE PROTOTYPES••/******************************************\|**| private function prototypes\******************************************/void DisposeHandleZ(Handle *theHandle);short MenuInit(void);Boolean IsResourceHandle(Handle);Boolean IsLockedHandle(Handle);void MainLoop( void);void DoSuspendResumeEvent ( EventRecord *event);Boolean HandleMouseDown( EventRecord *);Boolean HandleMenuChoice( long);void HandleAppleChoice( int);Boolean HandleFileChoice( int);void OpenAresScenarioFile( FSSpecPtr);void CreateNewAresScenarioFile( void);OSErr HeraFile_SaveAs( heraScenarioFileType *sourceFile, Boolean copy,	Boolean optimized);OSErr HeraFile_Save( heraScenarioFileType *sourceFile, Boolean optimized);void ClearHeraData( heraGlobalType *data);void ClearHeraScenarioFile( heraScenarioFileType *heraFile);Boolean AddHeraFile( heraScenarioFileType *heraFile);void RemoveHeraFile( heraScenarioFileType *heraFile);Boolean	EnvironmentCheck( void);Boolean MySWRoutineAvailable( short trapWord);#pragma mark ••PRIVATE FUNCTIONS••/******************************************\|**| private functions\******************************************/#pragma mark ••PUBLIC FUNCTIONS••/******************************************\|**| public functions\******************************************/void main( void){	OSErr		error, startupError = noErr;	SysEnvRec	theWorld;	short		i;	char		startupErrorString[256];	#ifndef TARGET_API_MAC_CARBON	MaxApplZone();#else	#pragma unused( theWorld)#endif	for ( i = 0; i < 90; i++)	{		MoreMasters();	// about 6K -- 5 x 1000 obj, 1 x 1000 actions		error = MemError();		if ( error != noErr)		{			startupError = error;			strcpy( startupErrorString, "More masters returned ");		}	}	#ifndef TARGET_API_MAC_CARBON	error = SysEnvirons(1, &theWorld);	if ( error != noErr)	{		return;	}	if (theWorld.hasColorQD == false) {//		BP_UserError_Literal("Initialization Error", "No Color QuickDraw");		return;// -27611;					/* If no color QD, we must leave (device_wrong_type. */	}#endif		/* Initialize all the needed managers. */#ifndef TARGET_API_MAC_CARBON	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);#else#endif TARGET_API_MAC_CARBON	FlushEvents(everyEvent,0);	InitCursor();	if ( startupError != noErr)	{		BP_AnErrorOfTypeN_Literal("Initialization Error", startupErrorString, startupError, "."); 	}		if ( !EnvironmentCheck())	{		return;	}		error = AAE_Init();	if ( error != noErr)	{		BP_AnErrorOfTypeN_Literal("Initialization Error",			"AAE_Init returned ", error, "."); 				return;	}		InstallBogusFinderEventHandler();	error = RegisterAppearanceClient();	if ( error != noErr)	{		BP_AnErrorOfTypeN_Literal("Initialization Error", "RegisterAppearanceClient returned ", error, "."); 				return;	}	gHera = (heraGlobalType *)NewPtr( sizeof( heraGlobalType));	if ( gHera == nil)		BP_UserError_Literal("Initialization Error", "Couldn’t allocate memory for global data.");	ClearHeraData( gHera);		error = MenuInit();	mAssert( error == noErr);	if ( error != noErr)	{		BP_AnErrorOfTypeN_Literal("Initialization Error", "MenuInit returned ", error, "."); 				return;	}		BPMacOutputInit( 480, 480);		error = InitWindowDispatch();	if ( error != noErr)	{		BP_AnErrorOfTypeN_Literal("Initialization Error", "InitWindowDispatch returned ", error, "."); 				return;	}		if (!EasyOpenPreferenceFile( kHera_Pref_FileName, kHera_Pref_Creator,		 kHera_Pref_Type, &gHera->prefRefNum))	{		BP_UserError_Literal("Initialization Error",			"Couldn’t open Hera Preferences file.");		return;	}		// open the default ares data files	{		Boolean	fatalError = false;				do		{			error = HP_AresDefaultData_Open( &fatalError);			if ( error != noErr)			{				if ( !fatalError)				{					FSSpec	aresFolder;										if ( !gHera->userPrefs.firstLaunch)					{						BP_UserError_Literal("Initialization Error",							"Couldn’t find the Ares folder.");					}//					error = NS_SelectFolderObject( &aresFolder, "\pWhere is the Ares folder?",//								"\pPlease select the folder which contains the Ares application.");//					BP_UserError_Literal("Test",//						"About to ask for folder location.");					error = SmartFile_SelectFolder( &aresFolder, "\pWhere is the Ares folder?",								"\pPlease select the folder which contains the Ares application.");//					 					//					BP_UserError_Literal("Test",//						"Asked for folder location; about to save.");					if ( error != noErr)					{						if ( error == userCanceledErr) return;						BP_AnErrorOfTypeN_Literal("File Error",							"SmartFile_SelectFolder returned ", error, ".");						return;						}										error = HP_AresLocation_Save( &aresFolder);					if ( error != noErr)					{						BP_AnErrorOfTypeN_Literal("Preferences Error",							"HP_AresLocationSave returned ", error, ".");						return;					}					error = fnfErr;					//					BP_UserError_Literal("Test",//						"Saved folder location.");				} else				{					BP_AnErrorOfTypeN_Literal("Initialization Error",						"HP_AresDefaultData_Open returned an error of type ",						error, ".");					return;				}			}		} while ( error != noErr);	}		{		// fix base object picture portraits		// and scenario net flags/*		baseObjectType	*b = nil;		scenarioType	*s = nil;		Handle			objectData = nil, scenarioData = nil, picData = nil;		long			objectNumber = 0, scenarioNumber = 0, i, j;				objectData = GetResource( 'bsob', 500);		mAssert( objectData != nil);*/		/*		objectNumber = GetHandleSize( objectData) / sizeof( baseObjectType);		for ( i = 0; i < objectNumber; i++)		{			picData = GetResource( 'PICT', i + 1001);			if ( picData != nil)			{				b = ((baseObjectType *)*objectData) + i;				b->pictPortraitResID = i + 1001;				ReleaseResource( picData);			}		}*//*		b = ((baseObjectType *)*objectData) + 109;		b->baseClass = 802;				b = ((baseObjectType *)*objectData) + 125;		b->baseClass = 803;				b = ((baseObjectType *)*objectData) + 126;		b->baseClass = 803;				b = ((baseObjectType *)*objectData) + 179;		b->baseClass = 801;				b = ((baseObjectType *)*objectData) + 222;		b->baseClass = 501;				ChangedResource( objectData);*//*		scenarioData = GetResource('snro', 500);		mAssert( scenarioData != nil);				scenarioNumber = GetHandleSize( scenarioData) / sizeof( scenarioType);		for ( i = 0; i < scenarioNumber; i++)		{			s = ((scenarioType *)*scenarioData) + i;			if ( s->netRaceFlags)			{				for ( j = 0; j < s->playerNum; j++)				{					s->player[j].netRaceFlags = s->netRaceFlags;				}			}		}		ChangedResource( scenarioData);*/		// fix briefing point data/*		briefPointType			*p = nil;		Handle					briefData = nil;		long					briefNumber = 0, i;		OSErr					error;				briefData = GetResource( 'snbf', 500);		mAssert( briefData != nil);				briefNumber = GetHandleSize( briefData) / sizeof( briefPointType);		for ( i = 0; i < briefNumber; i++)		{			p = ((briefPointType *)*briefData) + i;			if ( p->titleResID == 5000)			{				p->titleResID = 5003;				BPMOWritePString("\pfixing title res id\r");			}		}				ChangedResource( briefData);		error = ResError();		mAssert( error == noErr);		*/		// don't forget to open with write permission!//		UpdateResFile( gHera->default_scenarioFile_refNum);//		error = ResError();//		mAssert( error == noErr);	}		gHera->factory.fileSpec.name[0] = 0;	error = HD_InitDiscreteData( &gHera->factory);	if ( error != noErr)	{			if ( error == resNotFound)			{				BP_AnErrorOfTypeN_Literal("Initialization Error",					"Did not find correct version of Ares. "					"Re-launch Hera and select the folder containing "					"the most recent version of Ares (an error of type "					, error, " occurred).");				error = DeletePreference( gHera->prefRefNum, 'alis',					kAresFolder_alis_ResID);			} else			{				BP_AnErrorOfTypeN_Literal("Initialization Error",					"HD_InitDiscreteData returned ", error, ".");			}						return;	}{	long	windowID;		DataSelect_NewWindow( &gHera->factory, &windowID, nil);	Memory_Window_NewWindow();}	MainLoop();}short MenuInit(void){	Handle		theMenuBar;//	MenuHandle	menu;		//•	Load the menu bar	theMenuBar = GetNewMBar(kMenuBarID);	if (theMenuBar == nil)		return -1;	//•	Install the menu bar	SetMenuBar(theMenuBar);	//•	Add Apple Menu items	gAppleMenu = GetMenuHandle (kAppleMenuID);	AppendResMenu(gAppleMenu, 'DRVR');	DrawMenuBar();	return noErr;}void DisposeHandleZ(Handle *theHandle){	if (! (**theHandle))		return;	if (IsLockedHandle(*theHandle))		HUnlock(*theHandle);			if (IsResourceHandle(*theHandle))		ReleaseResource(*theHandle);	else		DisposeHandle(*theHandle);			*theHandle = nil;}//•	--------------------	IsResourceHandleBooleanIsResourceHandle(Handle theHandle){SInt8	memState;	memState = HGetState(theHandle);		//•	Check the resource bit in the handle info	if (memState & 0x20)		return (true);			return (false);}//•	--------------------	IsLockedHandleBoolean IsLockedHandle(Handle theHandle){SInt8	memState;	//•	Check the lock bit in the handle info	memState = HGetState(theHandle);		if (memState & 0x80)		return (true);			return (false);}void MainLoop (void){	Boolean			done = FALSE, isActive;	WindowPtr		whichWindow = nil;	EventRecord		theEvent;	char			whichChar;	OSStatus		err;	unsigned long	menuChoice;		while ( !done ) 	{		if ( gHera->wantToQuit)		{			if ( !DispatchWindowDispatchWDEvent( kWDQuitCommand))				done = true;			else				gHera->wantToQuit = false;		}				if ( gHera->inBackground)			WaitNextEvent (everyEvent, &theEvent, 3, nil);		else			WaitNextEvent (everyEvent, &theEvent, 20, nil);				if ( theEvent.what != nullEvent) gHera->lastNullUpdate = TickCount();				if ( !DispatchWindowHandleEvent( &theEvent, &menuChoice))		{			switch ( theEvent.what ) 			{				case osEvt:				{					long menuChoice = theEvent.message;					menuChoice >>= 24L;					menuChoice &= 0xff;										switch (menuChoice)					{						case mouseMovedMessage:		//							DoIdle(event); //mouse-moved same as idle for this app							break;											case suspendResumeMessage:							DoSuspendResumeEvent( &theEvent);// handle supend/resume event							break;					}				}					break;					case kHighLevelEvent :						err = AEProcessAppleEvent (&theEvent);						break;					case nullEvent:						break;					case updateEvt:							BPMOWritePString("\p\rMain:\tupdate\r");						whichWindow = (WindowPtr)theEvent.message;						if ( whichWindow != nil)						{							BeginUpdate (whichWindow);							SetPortWindowPort( whichWindow);							EndUpdate (whichWindow);						}						break;					case mouseDown:						BPMOWritePString("\p\rMain:\tmouseDown\r");						done = HandleMouseDown( &theEvent);						break;					case mouseUp:						break;					case keyDown:					case autoKey:						whichChar = theEvent.message & charCodeMask;						if (( theEvent.modifiers & cmdKey ) != 0)								done = HandleMenuChoice( menuChoice);						break;					case activateEvt:						BPMOWritePString("\pactivate: ");						whichWindow = (WindowPtr)theEvent.message;						isActive = ((theEvent.modifiers & activeFlag) != 0);						if ( isActive)						{							ControlHandle	aControl = nil;														BPMOWritePString("\ptrue ");							err = GetRootControl( whichWindow, &aControl);							if (( err == noErr) && ( aControl != nil))							{								BPMOWritePString("\p<controls actived>");								ActivateControl( aControl);							}						} else						{							ControlHandle	aControl = nil;							BPMOWritePString("\pfalse ");							err = GetRootControl( whichWindow, &aControl);							if (( err == noErr) && ( aControl != nil))							{								BPMOWritePString("\p<controls deactivated>");								DeactivateControl( aControl);							}													}						BPMOWritePString("\p\r");						break;				}			}					}}void DoSuspendResumeEvent ( EventRecord *event){	CWindowPtr	currentFrontWindow = (CWindowPtr)WD_FrontWindow();	//	windowID = (long) GetWRefCon( (WindowPtr)currentFrontWindow );						if ( event->message & resumeFlag)	{//		if ( event->message & convertClipboardFlag)		{		}		gHera->inBackground = false;		InitCursor();	} else	{		gHera->inBackground = true;	}}Boolean HandleMouseDown( EventRecord *theEvent){	long			menuChoice;	short			whichPart;	WindowPtr		whichWindow, frontWindow;	Point			where;	Boolean			close = FALSE, done = FALSE;	ControlHandle	aControl;	OSStatus		err;		whichPart = FindWindow (theEvent->where,  &whichWindow);		switch (whichPart)	{		case inMenuBar:			menuChoice = MenuSelect( theEvent->where);			done = HandleMenuChoice( menuChoice);			break;		case inSysWindow:#ifndef TARGET_API_MAC_CARBON			SystemClick( theEvent, whichWindow);#endif TARGET_API_MAC_CARBON			break;		case inContent:			where = theEvent->where;			if ( whichWindow != nil)			{//				frontWindow = FrontWindow();//				if ( whichWindow != frontWindow)//				if ( !IsWindowHilited( whichWindow))				if ( whichWindow != gHilitedWindow)				{					if ( gHera->modalMode <= 0)					{						if ( gHilitedWindow != nil)						{							err = GetRootControl( gHilitedWindow, &aControl);							if (( err == noErr) && ( aControl != nil))							{								DeactivateControl( aControl);							}							HiliteWindow( gHilitedWindow, false);						}//						BringToFront( whichWindow);//						HiliteWindow( whichWindow, true);						BPMOWritePString("\pMain:SelectWindow\r");						SelectWindow( whichWindow);						err = GetRootControl( whichWindow, &aControl);						if (( err == noErr) && ( aControl != nil))						{							ActivateControl( aControl);						}						gHilitedWindow = whichWindow;					} else SysBeep(20);				}			}			break;		case inDrag:			frontWindow = gHilitedWindow;//FrontWindow();			if (( whichWindow == frontWindow) || ( gHera->modalMode <= 0))			{				Rect screenBounds;								DragWindow (whichWindow, theEvent->where,					C2C_ScreenBits_GetBounds( &screenBounds));			} else SysBeep(20);			if (( whichWindow != frontWindow) && ( gHera->modalMode <= 0))			{				aControl = nil;								err = GetRootControl( frontWindow, &aControl);				if (( err == noErr) && ( aControl != nil))				{					DeactivateControl( aControl);				}				aControl = nil;				err = GetRootControl( whichWindow, &aControl);				if (( err == noErr) && ( aControl != nil))				{					ActivateControl( aControl);				}				gHilitedWindow = whichWindow;			}			break;		case inGoAway:			if ( TrackGoAway (whichWindow, theEvent->where))			{				ShowHide ( whichWindow, FALSE);			}			break;	}	return ( done);}Boolean HandleMenuChoice( long menuChoice){	int		theMenu;	int		theItem;	Boolean	done = FALSE;		if (menuChoice != 0)	{		theMenu = HiWord( menuChoice);		theItem = LoWord( menuChoice);				if ( !DispatchWindowHandleMenuChoice( theMenu, theItem))		{			switch (theMenu)			{				case kAppleMenuID:					HandleAppleChoice( theItem);					break;				case kFileMenuID:					done = HandleFileChoice( theItem);					break;				case kEditMenuID:	//				HandleEditChoice( theItem);					break;				default:					break;			}		}		HiliteMenu( 0 );	}	return ( done);}void HandleAppleChoice ( int theItem){	Str255		accName;	int			accNumber;#ifdef TARGET_API_MAC_CARBON	#pragma unused( accNumber)#endif		switch ( theItem)	{		case 1:			{				AlertStdAlertParamRec	alertParam;				unsigned char			okButton[] = "\pOK";				short					itemHit;								alertParam.movable = false;				alertParam.helpButton = false;				alertParam.filterProc = nil;				alertParam.defaultText = okButton;				alertParam.cancelText = nil;				alertParam.otherText = nil;				alertParam.defaultButton = kAlertStdAlertOKButton;				alertParam.cancelButton = 0;				alertParam.position = kWindowDefaultPosition;				StandardAlert( kAlertNoteAlert, "\pHera v1.0.0A6-3 DEBUG TEST",					"\pAres Editor\r"					"www.arescentral.com\r"					"\r"					"a Bigger Planet Production\r"					"www.biggerplanet.com\r"					"\r"					"COPYRIGHT©2000 NATHAN LAMONT & AMBROSIA SOFTWARE, INC.\r"					"\r"					"www.AmbrosiaSW.com",					&alertParam, &itemHit);			}			break;					default:			GetMenuItemText ( gAppleMenu, theItem, accName);#ifndef TARGET_API_MAC_CARBON			accNumber = OpenDeskAcc( accName);#endif			break;	}}Boolean HandleFileChoice( int theItem){	short	resID = 5000;		switch( theItem)	{		case kFile_New_Item:			CreateNewAresScenarioFile();			break;					case kFile_Save_Item://			HD_CompileDiscreteData( &gHera->factory);//			HD_CompileDiscreteData( d->heraFile, false);			break;					case kFile_Open_Item:			OpenAresScenarioFile( nil);			break;					case kFile_Quit_Item:			if ( !DispatchWindowDispatchWDEvent( kWDQuitCommand))				return ( true);			else return false;			break;	}	return ( FALSE);}void OpenAresScenarioFile( FSSpecPtr sourceFile){	FSSpec					fileSpec;	OSErr					err;	heraScenarioFileType	*heraFile = (heraScenarioFileType *)NewPtr( sizeof( heraScenarioFileType));	scenarioInfoType		*info;	long					windowID;		if ( heraFile == nil)	{		BP_UserError_Literal("Open Ares Scenario File Error",			"Couldn’t reserve memory for the new Ares Scenario File "			"information.");		return;	}		ClearHeraScenarioFile( heraFile);	if ( sourceFile == nil)	{		err = SmartFile_SelectFile( &fileSpec, 301);				if  ( err == userCanceledErr)		{			DisposePtr( (Ptr)heraFile);			return;		}				if ( err != noErr)		{			BP_AnErrorOfTypeN_Literal("Open Ares Scenario File Error",				"Couldn’t open the Ares Scenario File because an"				" error of type ", err, " occurred.");						DisposePtr( (Ptr)heraFile);			return;		}	} else	{		BlockMove( sourceFile, &fileSpec, sizeof( FSSpec));	}	if ( SmartFile_IsStationery( &fileSpec))	{		FSSpec	newFileSpec;		Boolean	isStationery = false;				err = SmartFile_SaveAs( &newFileSpec, fileSpec.name, "\pAres",			'rsrc', 'nlAe', &isStationery);				if ( err == userCanceledErr)		{				DisposePtr( (Ptr)heraFile);			return;		}				if ( err != noErr)		{			BP_AnErrorOfTypeN_Literal("Open Ares Scenario File Error",				"Couldn’t create the new file from the stationary because an "				" error of type ", err, " occurred.");						DisposePtr( (Ptr)heraFile);			return;		}		//		err = FSpFileCopy( &fileSpec, &newFileSpec, fileSpec.name, nil, 512, true);		err = ResourceFork_Copy( fileSpec.vRefNum, fileSpec.parID,			fileSpec.name, newFileSpec.vRefNum, newFileSpec.parID,			newFileSpec.name, newFileSpec.name, nil, 512, false);		if ( err != noErr)		{			BP_AnErrorOfTypeN_Literal("Open Ares Scenario File Error",				"Couldn’t copy the stationary data because an "				" error of type ", err, " occurred.");						DisposePtr( (Ptr)heraFile);			return;		}		BlockMove( &newFileSpec, &fileSpec, sizeof( FSSpec));		if ( isStationery)		{			SetIsStationery( fileSpec.vRefNum, fileSpec.parID, fileSpec.name);		}	}		BlockMove( &fileSpec, &heraFile->fileSpec, sizeof( FSSpec));		heraFile->fileRefNum = FSpOpenResFile( &fileSpec, fsRdWrPerm);		if ( !AddHeraFile( heraFile)) return;		BPMOWritePString("\p\rnew file refnum:\t");	BPMOWriteLong( heraFile->fileRefNum);	BPMOWritePString("\p\r");				{		err = HD_InitDiscreteData( heraFile);		if ( err != noErr)		{			BP_AnErrorOfTypeN_Literal("Open Ares Scenario File Error",				"Couldn’t initialize the scenario data because"				" error of type ", err, " occurred.");						return;		}	}	if ( heraFile->scenarioInfo != nil)	{		info = (scenarioInfoType *)*heraFile->scenarioInfo;		info->requiresAresVersion = kThis_Version_Is;	}	DataSelect_NewWindow( heraFile, &windowID, nil);}void CreateNewAresScenarioFile( void){	FSSpec					fileSpec;	OSErr					err;	heraScenarioFileType	*heraFile = (heraScenarioFileType *)NewPtr( sizeof( heraScenarioFileType));	scenarioInfoType		*info;	long					windowID;	AlertStdAlertParamRec	alertParam;	unsigned char			okButton[] = "\pStart from Scratch",							cancelButton[] = "\pStart with Factory Data";	short					itemHit;	Handle					dummyStringData;	Boolean					isStationery = false;		if ( heraFile == nil)	{		BP_UserError_Literal("Create New Ares Scenario File Error",			"Couldn’t reserve memory for the new Ares Scenario File "			"information.");		return;	}		ClearHeraScenarioFile( heraFile);	err = SmartFile_SaveAs( &fileSpec, "\pUntitled", "\pAres",					 'rsrc', 'nlAe', &isStationery);	if ( err == userCanceledErr)	{		DisposePtr( (Ptr)heraFile);		return;	}	if ( err != noErr)	{		BP_AnErrorOfTypeN_Literal("Create New Ares Scenario File Error",			"Couldn’t create the new Ares Scenario File because an"			" error of type ", err, " occurred.");				return;	}	if ( isStationery)	{		SetIsStationery( fileSpec.vRefNum, fileSpec.parID, fileSpec.name);	}	BlockMove( &fileSpec, &heraFile->fileSpec, sizeof( FSSpec));	heraFile->fileRefNum = FSpOpenResFile( &fileSpec, fsRdWrPerm);		BPMOWritePString("\p\rnew file refnum:\t");	BPMOWriteLong( heraFile->fileRefNum);	BPMOWritePString("\p\r");				alertParam.movable = false;	alertParam.helpButton = false;	alertParam.filterProc = nil;	alertParam.defaultText = okButton;	alertParam.cancelText = cancelButton;	alertParam.otherText = nil;	alertParam.defaultButton = kAlertStdAlertOKButton;	alertParam.cancelButton = 0;	alertParam.position = kWindowDefaultPosition;	StandardAlert( kAlertNoteAlert, "\pDo you want to start from "		"scratch or start with all the factory data?",		"\p\r\rIf you start from scratch, you’ll be able to "		"copy data from the factory scenarios. "		"\r\rIf you start with the factory data, you’ll be able "		"to delete the data you don’t need.",		&alertParam, &itemHit);	if ( itemHit == kAlertStdAlertOKButton)	{		heraFile->scenarioData = NewHandle(0);				if ( heraFile->scenarioData == nil)		{			BP_UserError_Literal("Create New Ares Scenario File Error",				"Couldn’t create the scenario data from scratch because "				"there wasn’t enough memory.");						return;		}		heraFile->scenarioInfo = NewHandle( sizeof( scenarioInfoType));		if ( heraFile->scenarioInfo == nil)		{			BP_UserError_Literal("Create New Ares Scenario File Error",				"Couldn’t create the scenario info from scratch because "				"there wasn’t enough memory.");						return;		}				info = (scenarioInfoType *)*heraFile->scenarioInfo;		info->warpInFlareID = -1;		info->warpOutFlareID = -1;		info->playerBodyID = -1;		info->energyBlobID = -1;		info->flags = kScenario_Data_Flag_HasCustomObjects |			kScenario_Data_Flag_HasCustomScenarios |			kScenario_Data_Flag_HasCustomRaces;				// chapter name strings must be made		dummyStringData = NewStringList();				if ( dummyStringData != nil)		{			HRT_KeepChangedResource( heraFile, dummyStringData, 'STR#',				-1, 4600, "\pChapter Name Strings");			DisposeHandle( dummyStringData);		} else		{			BP_UserError_Literal("Create New Ares Scenario File Error",				"Couldn’t create the chapter name strings from scratch because "				"there wasn’t enough memory.");		}				// base object short name strings must be made		dummyStringData = NewStringList();		if ( dummyStringData != nil)		{			HRT_KeepChangedResource( heraFile, dummyStringData, 'STR#',				-1, 5000, "\pBase Object Short Name Strings");			DisposeHandle( dummyStringData);		} else		{			BP_UserError_Literal("Create New Ares Scenario File Error",				"Couldn’t create the base obejct name short strings from scratch because "				"there wasn’t enough memory.");		}				// base obejct long name strings must be made		dummyStringData = NewStringList();		if ( dummyStringData != nil)		{			HRT_KeepChangedResource( heraFile, dummyStringData, 'STR#',				-1, 5001, "\pBase Object Long Name Strings");			DisposeHandle( dummyStringData);		} else		{			BP_UserError_Literal("Create New Ares Scenario File Error",				"Couldn’t create the base object long name strings from scratch because "				"there wasn’t enough memory.");		}				// base object dev strings must be made		dummyStringData = NewStringList();		if ( dummyStringData != nil)		{			HRT_KeepChangedResource( heraFile, dummyStringData, 'STR#',				-1, 5002, "\pBase Object Dev Note Strings");			DisposeHandle( dummyStringData);		} else		{			BP_UserError_Literal("Create New Ares Scenario File Error",				"Couldn’t create the base object dev note strings from scratch because "				"there wasn’t enough memory.");		}			} else	{		err = HD_InitDiscreteData( heraFile);		if ( err != noErr)		{			BP_AnErrorOfTypeN_Literal("Create New Ares Scenario File Error",				"Couldn’t initialize the scenario data because"				" error of type ", err, " occurred.");						return;		}	}	if ( heraFile->scenarioInfo != nil)	{		info = (scenarioInfoType *)*heraFile->scenarioInfo;		pstrcpy( info->downloadURLString, "\phttp://www.domain.com/~yourname/yourscenario.hqx");		pstrcpy( info->titleString, fileSpec.name);		pstrcpy( info->authorNameString, "\pYour Name Here");		pstrcpy( info->authorURLString, "\phttp://www.domain.com/~yourname");		info->version = 0x00000100;		info->checkSum = 0;		info->requiresAresVersion = kThis_Version_Is;		info->flags = kScenario_Data_Flag_HasCustomObjects |			kScenario_Data_Flag_HasCustomScenarios |			kScenario_Data_Flag_HasCustomRaces;	}	DataSelect_NewWindow( heraFile, &windowID, nil);	HD_CompileDiscreteData( heraFile, false);	}OSErr HeraFile_SaveAs( heraScenarioFileType *sourceFile, Boolean copy,	Boolean optimized){	FSSpec					fileSpec;	OSErr					err;	heraScenarioFileType	*heraFile = (heraScenarioFileType *)NewPtr( sizeof( heraScenarioFileType));	Boolean					isStationery = false;		if ( sourceFile == nil) return paramErr;	if ( sourceFile->fileRefNum <= 0) return paramErr;	gHera->currentSave = sourceFile;		DispatchWindowDispatchWDEvent( kWDSaveWindowCommand);		if ( gHera->currentSave == nil) return noErr;		if ( heraFile == nil)	{		BP_UserError_Literal("Create New Ares Scenario File Error",			"Couldn’t reserve memory for the new Ares Scenario File "			"information.");		return memFullErr;	}		BlockMove( sourceFile, heraFile, sizeof( heraScenarioFileType));	err = SmartFile_SaveAs( &fileSpec, "\pUntitled", "\pAres",					 'rsrc', (optimized)?('ar12'):('nlAe'), &isStationery);	if ( err == userCanceledErr)	{		DisposePtr( (Ptr)heraFile);		return noErr;	}	if ( err != noErr)	{		BP_AnErrorOfTypeN_Literal("Create New Ares Scenario File Error",			"Couldn’t create the new Ares Scenario File because an"			" error of type ", err, " occurred.");				return err;	}	if ( isStationery)	{		SetIsStationery( fileSpec.vRefNum, fileSpec.parID, fileSpec.name);	}	err = ResourceFork_Copy( sourceFile->fileSpec.vRefNum, sourceFile->fileSpec.parID,		sourceFile->fileSpec.name, fileSpec.vRefNum, fileSpec.parID,		fileSpec.name, fileSpec.name, nil, 512, false);	if ( optimized)	{		ChangeCreatorType( fileSpec.vRefNum, fileSpec.parID,		fileSpec.name, 'ar12', 'rsrc');	} else	{		ChangeCreatorType( fileSpec.vRefNum, fileSpec.parID,		fileSpec.name, 'nlAe', 'rsrc');	}	BlockMove( &fileSpec, &heraFile->fileSpec, sizeof( FSSpec));	heraFile->fileRefNum = FSpOpenResFile( &fileSpec, fsRdWrPerm);	HD_CompileDiscreteData( heraFile, optimized);		if ( !copy)		heraFile->changed = false;	if ( copy)	{		CloseResFile( heraFile->fileRefNum);	} else	{		CloseResFile( sourceFile->fileRefNum);		BlockMove( heraFile, sourceFile, sizeof( heraScenarioFileType));	}	DisposePtr( (Ptr)heraFile);	return noErr;}OSErr HeraFile_Save( heraScenarioFileType *sourceFile, Boolean optimized){	if ( sourceFile == nil) return paramErr;	if ( sourceFile->fileRefNum <= 0) return paramErr;		gHera->currentSave = sourceFile;		DispatchWindowDispatchWDEvent( kWDSaveWindowCommand);		if ( gHera->currentSave == nil) return noErr;	sourceFile->changed = false;	return HD_CompileDiscreteData( sourceFile, optimized);}void ClearHeraData( heraGlobalType *data){	Str255			s;	long			i;		mAssert( data != nil);		data->prefRefNum = -1;		data->default_spriteFile_refNum = -1;	data->default_scenarioFile_refNum = -1;	data->default_interfaceFile_refNum = -1;	data->default_soundFile_refNum = -1;	data->clipboard.type = 0;	data->clipboard.sourceFile = nil;	data->clipboard.sourceData = nil;	data->currentSave = nil;//	data->userDataFile_refNum = -1;		data->modalMode = 0;		data->userPrefs.firstLaunch = true;	data->wantToQuit = false;	data->inBackground = false;		GetIndString( s, 128, 1);	// big font name	data->bigFontNum = GetFontNumByString( s);	GetIndString( s, 128, 2);	// big font size	StringToNum( s, &data->bigFontSize);	GetIndString( s, 128, 3);	// big font style	StringToNum( s, &data->bigFontStyle);		GetIndString( s, 128, 4);	// small font name	data->smallFontNum = GetFontNumByString( s);	GetIndString( s, 128, 5);	// small font size	StringToNum( s, &data->smallFontSize);	GetIndString( s, 128, 6);	// small font style	StringToNum( s, &data->smallFontStyle);	GetIndString( s, 128, 7);	// small font style	StringToNum( s, &data->smallFontBoldStyle);	data->theCLUT = GetCTable( 256);	for ( i = 0; i < kMax_Open_Files; i++)	{		data->heraFile[i] = nil;	}	ClearHeraScenarioFile( &data->factory);}void ClearHeraScenarioFile( heraScenarioFileType *heraFile){	heraFile->discreteData = nil;	heraFile->conditionID = 5000;	heraFile->actionID = 5000;	heraFile->initialID = 5000;	heraFile->objectID = 5000;	heraFile->briefPointID = 5000;		heraFile->scenarioData = nil;	heraFile->scenarioInfo = nil;	heraFile->newResource = nil;	heraFile->dragTo = heraFile->dragFrom = -1;	heraFile->fileRefNum = -1;	heraFile->changed = false;}Boolean AddHeraFile( heraScenarioFileType *heraFile){	long	i = 0;		if ( heraFile == nil) return false;	for ( i = 0; i < kMax_Open_Files; i++)	{		if ( gHera->heraFile[i] != nil)		{			if ( gHera->heraFile[i]->fileRefNum == heraFile->fileRefNum)			{				BP_UserError_Literal("Open Ares Scenario File Error",					"That file is already open.");				return false;			}		}	}		i = 0;	while (( gHera->heraFile[i] != nil) && ( i < kMax_Open_Files)) i++;	if ( i == kMax_Open_Files)	{		BP_UserError_Literal("Open Ares Scenario File Error",			"Can’t open any more files.");		DisposePtr( (Ptr)heraFile);		return false;	}		gHera->heraFile[i] = heraFile;	return true;}void RemoveHeraFile( heraScenarioFileType *heraFile){	long	i;		if ( heraFile == nil) return;		for ( i = 0; i < kMax_Open_Files; i++)	{		if ( gHera->heraFile[i] != nil)		{			if ( gHera->heraFile[i]->fileRefNum == heraFile->fileRefNum)			{				if ( heraFile->scenarioData != nil)					DisposeHandle( heraFile->scenarioData);				if ( heraFile->scenarioInfo != nil)					DisposeHandle( heraFile->scenarioInfo);				HD_Delete_Discrete_Data_All( heraFile);				DisposePtr( (Ptr)heraFile);				gHera->heraFile[i] = nil;			}		}	}}Boolean	EnvironmentCheck( void){	long 		gestaltInfo;	OSErr		err;	/*	if ( !(MySWRoutineAvailable( _Gestalt)))	{		BP_UserError_Literal("Initialization Error",			"You do not have the minimum system requirements, because "			"the Gestalt Manager is not present.");		return( false);	}*/		err = Gestalt(gestaltSystemVersion, &gestaltInfo);	if ( err != noErr)	{		BP_AnErrorOfTypeN_Literal("Initialization Error",			"Couldn’t verify that the minimum system requirements are met "			"because an error of type ", err, " occurred.");		return( false);	}		if ( gestaltInfo < 0x753)	{		BP_UserError_Literal("Initialization Error",			"You do not have the minimum system requirements, because "			"you don’t have System (MacOS) 7.5.5 or better.");		return false;	}	err = Gestalt(gestaltQuickdrawVersion, &gestaltInfo);	if ( err != noErr)	{		BP_AnErrorOfTypeN_Literal("Initialization Error",			"An error of type ", err, " occurred. Color QuickDraw does not "			"seem to be present.");		return( false);	}	if (gestaltInfo < gestalt8BitQD)	{		BP_UserError_Literal("Initialization Error",			"You do not have the minimum system requirements, because "			"Color QuickDraw is not present.");		return false;	}	err = Gestalt( gestaltAppearanceAttr, &gestaltInfo);	if ( err != noErr)	{		BP_AnErrorOfTypeN_Literal("Initialization Error",			"An error of type ", err, " occurred. Appearance Manager 1.0.1 "			"(part of MacOS 8.1) or later is required.");		return( false);	}	if (!( gestaltInfo & (0x01 << gestaltAppearanceExists)))	{		BP_UserError_Literal("Initialization Error",			"You do not have the minimum system requirements, because "			"the Appearance Manager is not installed.");		return false;	}	err = Gestalt( gestaltAppearanceVersion, &gestaltInfo);	if ( err != noErr)	{		BP_AnErrorOfTypeN_Literal("Initialization Error",			"An error of type ", err, " occurred. Appearance Manager 1.0.1 "			"(part of MacOS 8.1) or later is required.");		return( false);	}	if (!( gestaltInfo >= 0x101))	{		BP_UserError_Literal("Initialization Error",			"You do not have the minimum system requirements, because "			"you don’t have Appearance Manager 1.0.1 or better installed.");		return false;	}		return true;}/*	MySWRoutineAvailable		only used to determine if gestalt is present. We know that if we		are compiled for carbon, we don't need to check for gestalt*/Boolean MySWRoutineAvailable( short trapWord){#ifdef TARGET_API_MAC_CARBON	#pragma unused (trapWord)#else	TrapType	trType;#endif TARGET_API_MAC_CARBON#ifndef TARGET_API_MAC_CARBON	// first determine whether it is an Operating System or Toolbox routine	if ( trapWord & 0x0800) trType = ToolTrap;	else trType = OSTrap;// filter cases where older systems mask with $1FF rather than $3FF		if (( trType == ToolTrap) && (( trapWord & 0x03ff) >= 0x200) &&		GetToolboxTrapAddress( 0xa86e) == GetToolboxTrapAddress( 0xaa6e))			return( false);	else return ( ( NGetTrapAddress( trapWord, trType) !=		GetToolboxTrapAddress( _Unimplemented)));#else	return true;#endif}