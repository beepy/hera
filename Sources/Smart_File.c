/******************************************\|**| Smart_File.c\******************************************/#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#include <Navigation.h>#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#pragma mark _this library includes_/* - this project*******************************************/#include "Old_File.h"#include "Navigation_Utilities.h"#include "Smart_File.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#pragma mark _macros_/* - macros*******************************************/#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/#pragma mark 본EXTERNAL GLOBALS본/******************************************\|**| external globals\******************************************/extern Boolean gDirectorySelectionFlag;#pragma mark 본PRIVATE GLOBALS본/******************************************\|**| private globals\******************************************/#pragma mark 본PRIVATE PROTOTYPES본/******************************************\|**| private function prototypes\******************************************/#pragma mark 본PRIVATE FUNCTIONS본/******************************************\|**| private functions\******************************************/#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/OSErr SmartFile_SelectFolder( FSSpecPtr destFile, StringPtr windowName,	StringPtr prompt){	OSErr	error = noErr;		if ( destFile == nil) return paramErr;	if ( !NavServicesAvailable()) 	// this is a macro that's safe to call any									// time	{#ifndef TARGET_API_MAC_CARBON			StandardFileReply	fileReply;				error = doDirectorySelectionDialog( &fileReply);		if (( fileReply.sfGood) || ( gDirectorySelectionFlag))		{			BlockMove( &fileReply.sfFile, destFile, sizeof( FSSpec));			return noErr;		} else return userCanceledErr;#endif	} else	{		return NS_SelectFolderObject( destFile, windowName, prompt);	}	return noErr;	}OSErr SmartFile_SaveAs( FSSpecPtr destFile, StringPtr fileName,	StringPtr appName, OSType fileTypeToSave, OSType fileCreator,	Boolean *isStationery){	OSErr				error = noErr;		if ( isStationery != nil) *isStationery = false;		if ( destFile == nil) return paramErr;		if ( !NavServicesAvailable()) 	// this is a macro that's safe to call any									// time	{#ifndef TARGET_API_MAC_CARBON		StandardFileReply	fileReply;		unsigned char		prompt[] = "\pSave as:";		StandardPutFile( prompt, fileName, &fileReply);		if ( fileReply.sfGood)		{			BlockMove( &fileReply.sfFile, destFile, sizeof( FSSpec));			if ( fileReply.sfReplacing)			{				error = FSpDelete( destFile);				if ( error != noErr) return error;			}//			if ( !fileReply.sfReplacing)			{				FSpCreateResFile( destFile, fileCreator, fileTypeToSave,					fileReply.sfScript);				error = ResError();				if ( error != noErr) return error;			}		} else return userCanceledErr;#endif TARGET_API_MAC_CARBON			} else	{		return NS_SaveAs( destFile, fileName, appName, fileTypeToSave,							fileCreator, isStationery);	}		return noErr;}OSErr SmartFile_SelectFile( FSSpecPtr destFile, short openListResID){	OSErr				error = noErr;		if ( !NavServicesAvailable())	{#ifndef TARGET_API_MAC_CARBON			Handle				openFileTypeResource =								GetResource('open', openListResID);		SFTypeList			typeList;		OSType				*osType = nil;		long				typeNum, i;		StandardFileReply	fileReply;				if ( openFileTypeResource == nil) return resNotFound;				typeNum = *((long *)((*openFileTypeResource) + 4));		if ( typeNum > 4) typeNum = 4;		for ( i = 0; i < typeNum; i++)		{			osType = (OSType *)((*openFileTypeResource) + 8 + ( 4 * i));			typeList[i] = *osType;		}				ReleaseResource( openFileTypeResource);		StandardGetFile( 0, typeNum, typeList, &fileReply);		if ( fileReply.sfGood)		{			BlockMove( &fileReply.sfFile, destFile, sizeof( FSSpec));			return noErr;		} else return userCanceledErr;#endif TARGET_API_MAC_CARBON			} else	{		return NS_SelectFileObject( destFile, openListResID);	}		return noErr;}/*FUNCTION IsStationeryDoc (myFSSpec: FSSpec): Boolean;VAR    myErr:      OSErr;    myFInfo:    FInfo;BEGIN    myErr := FSpGetFInfo(myFSSpec, myFInfo);    IF myErr = noErr THEN        IsStationeryDoc := BTST(myFInfo.fdFlags, isStationery)    ELSE        IsStationeryDoc := FALSE;END;*/Boolean SmartFile_IsStationery( FSSpecPtr file){	OSErr	error = noErr;	FInfo	fileInfo;		error = FSpGetFInfo( file, &fileInfo);	if ( error == noErr)	{		if ( fileInfo.fdFlags & kIsStationery) return true;		else return false;	} else return false;}