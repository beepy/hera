/******************************************\|**| Hera_Name_Maker.c\******************************************/#pragma mark ¥¥INCLUDES¥¥/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "String Handling.h"#include "str_bp.h"#include "strlist.h"#include "String Numerics.h"#include "Assert.h"#pragma mark _this library includes_/* - this project*******************************************/#include "Hera_Name_Maker.h"#include "Hera_Utilities.h"#include "Hera_Global.h"#include "Hera_ResourceTracker.h"#include "Hera_Data.h"#pragma mark ¥¥DEFINITIONS¥¥/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#pragma mark _macros_/* - macros*******************************************/#pragma mark ¥¥TYPEDEFS¥¥/******************************************\|**| typedefs\******************************************/#pragma mark ¥¥EXTERNAL GLOBALS¥¥/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark ¥¥PRIVATE GLOBALS¥¥/******************************************\|**| private globals\******************************************/#pragma mark ¥¥PRIVATE PROTOTYPES¥¥/******************************************\|**| private function prototypes\******************************************/#pragma mark ¥¥PRIVATE FUNCTIONS¥¥/******************************************\|**| private functions\******************************************/#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/StringPtr MakeActionName( heraScenarioFileType *heraFile,	objectActionType *action, Handle actionData,	long actionNumber,	Str255 destString){	Str255				s;	Boolean				releaseActionData = false, setActionDataState = false;	SignedByte			actionDataState;	short				oldResFile;	if ( action == nil)	{		if ( actionData == nil)		{			HU_UseResFile( heraFile->fileRefNum, &oldResFile);						actionData = HRT_Resource_GetEZ( heraFile,'obac', 500);			UseResFile( oldResFile);			if ( actionData == nil)			{				destString[0] = 0;				return destString;			}			HLock( actionData);			actionDataState = 0;			releaseActionData = setActionDataState = true;		} else		{			actionDataState = HGetState( actionData);			HLock( actionData);		}		action = (objectActionType *)*actionData + actionNumber;	}	/*	CopyPString( destString, "\p(");	NumToString( actionNumber, s);	if ( s[0] == 1) ConcatenatePString(destString, "\p00");	else if ( s[0] == 2) ConcatenatePString(destString, "\p0");	ConcatenatePString(destString, s);	ConcatenatePString(destString, "\p) ");	if ( action->owner == 1) ConcatenatePString(destString, "\p>>");	GetIndString( s, kVerbTypeNameResID, action->verb + 1);	ConcatenatePString(destString, s);	ConcatenatePString(destString, "\p ");*/	GetIndString( destString, kVerbTypeNameResID, action->verb + 1);	ConcatenatePString(destString, "\p ");	switch ( action->verb)	{		case kCreateObject:		case kCreateObjectSetDest:			NumToString( action->argument.createObject.howManyMinimum, s);			ConcatenatePString(destString, s);			ConcatenatePString(destString, "\p ");//			GetBaseObjectNameNumber( action->argument.createObject.whichBaseType + 1, s);			MakeObjectName( heraFile, nil, nil, action->argument.createObject.whichBaseType, s);			ConcatenatePString(destString, s);			break;				case kPlaySound://			HU_UseResFile( gHera->default_soundFile_refNum, &oldResFile);//			i = GetResourceIndexFromResID( action->argument.playSound.idMinimum, 'snd ');//			GetResourceNameFromIndex( i, 'snd ', s);			HU_GetResourceNameFromID( action->argument.playSound.idMinimum,				'snd ', s);			ConcatenatePString(destString, s);//			UseResFile( oldResFile);			break;					case kAlter:			GetIndString( s, 558, action->argument.alterObject.alterType + 1);			ConcatenatePString(destString, s);			ConcatenatePString(destString, "\p by ");			NumToString( action->argument.alterObject.minimum, s);			ConcatenatePString(destString, s);			break;						case kMakeSparks:			NumToString( action->argument.makeSparks.howMany, s);			ConcatenatePString(destString, s);			ConcatenatePString(destString, "\p ");			GetIndString( s, 590, action->argument.makeSparks.color + 1);			ConcatenatePString(destString, s);			break;				case kReleaseEnergy:			NumToString( action->argument.releaseEnergy.percent, s);			ConcatenatePString(destString, s);			ConcatenatePString(destString, "\p%");			break;					case kLandAt:			NumToString( action->argument.landAt.landingSpeed, s);			ConcatenatePString(destString, s);			break;					case kEnterWarp:			NumToString( action->argument.enterWarp.warpSpeed, s);			ConcatenatePString(destString, s);			break;					case kDisplayMessage:			NumToString( action->argument.displayMessage.resID, s);			ConcatenatePString(destString, s);			ConcatenatePString(destString, "\p/");			NumToString( action->argument.displayMessage.pageNum, s);			ConcatenatePString(destString, s);			break;					case kChangeScore:			ConcatenatePString(destString, "\p#");			NumToString( action->argument.changeScore.whichScore, s);			ConcatenatePString(destString, s);			ConcatenatePString(destString, "\p by ");			NumToString( action->argument.changeScore.amount, s);			ConcatenatePString(destString, s);			break;					case kDeclareWinner:			NumToString( action->argument.declareWinner.whichPlayer, s);			ConcatenatePString(destString, s);			ConcatenatePString(destString, "\p -> ");			NumToString( action->argument.declareWinner.nextLevel, s);			ConcatenatePString(destString, s);			break;					case kDie:			GetIndString( s, 557, action->argument.killObject.dieType + 1);			ConcatenatePString(destString, s);			break;				}		if ( setActionDataState) HSetState( actionData, actionDataState);	if ( releaseActionData) DisposeHandle( actionData);	return destString;}StringPtr MakeObjectName( heraScenarioFileType *heraFile, Handle objectData, Handle objectNameStringList,	long index, StringPtr d){	#pragma unused ( objectData, objectNameStringList)	/*	d[0] = 0;	pstrcat( d, "\p[");	NumToString( index, s);	pstrcat( d, s);	pstrcat( d, "\p] ");	if ( objectNameStringList == nil)	{		short				oldResFile;				HU_UseResFile( gHera->default_scenarioFile_refNum, &oldResFile);//		GetIndString( s, 5001, index + 1);		HU_GetOneIndString( 5001, index + 1, s);				UseResFile( oldResFile);	} else	{		RetrieveIndString( objectNameStringList, index, s);	}	if ( s[0] == 0) pstrcpy( s, "\puntitled");	pstrcat( d, s);*/	if ( index >= 0)		GetObjectNameFromDiscreteObjectID( heraFile, index, d, 1);	else		d[0] = 0;	return d;}StringPtr MakeActionWindowNameFromObject( heraScenarioFileType *heraFile,	Handle objectData, Handle objectNameStringList,	long index, StringPtr d, StringPtr actionName){	MakeObjectName( heraFile, objectData, objectNameStringList, index, d);	pstrcat(d, "\p: ");	pstrcat(d, actionName);	return d;}StringPtr MakeActionWindowNameFromDiscreteObject( heraScenarioFileType *heraFile,	Handle discreteObjectData,	StringPtr d, StringPtr actionName){	Handle						discreteObjectStringsData;	heraBaseObjectStringsType	*objectStrings = nil;	Str255						s;		mAssert( discreteObjectData != nil);	mAssert( d != nil);	mAssert( actionName != nil);				d[0] = 0;	pstrcat( d, "\p[");	NumToString( ((heraDataHeaderType *)*discreteObjectData)->id, s);	pstrcat( d, s);	pstrcat( d, "\p] ");		discreteObjectStringsData = HD_Find_Discrete_Data( heraFile, 		((heraDataHeaderType *)*discreteObjectData)->id, 1, nil, kHera_ObjectStrings_Type);	mAssert( discreteObjectStringsData != nil);		objectStrings = (heraBaseObjectStringsType *)HD_DiscreteData_GetNthElement(									discreteObjectStringsData, kHera_ObjectStrings_Type,									0);	mAssert( objectStrings != nil);		if ( objectStrings->shortName[0] == 0)		pstrcat( d, "\puntitled");	else		pstrcat( d, objectStrings->shortName);		return d;}StringPtr GetActionNameFromDiscreteAction( heraScenarioFileType *heraFile,	Handle discreteActionData,	StringPtr d, Boolean includeID){	Str255	s;		objectActionType *action = nil;		mAssert( discreteActionData != nil);	mAssert( d != nil);		if ( HD_DiscreteData_GetElementNumber( discreteActionData,		kHera_Action_Type) <= 0)	{		pstrcpy( d, "\pno action");		return d;	}	action = (objectActionType *)HD_DiscreteData_GetNthElementCopy(		discreteActionData, kHera_Action_Type, 0);		if ( action == nil)	{		pstrcpy( d, "\pno action");		return d;	}		MakeActionName( heraFile, action, nil,		((heraDataHeaderType *)*discreteActionData)->id, s);	DisposePtr( (Ptr)action);	if ( includeID)	{		NumToString( ((heraDataHeaderType *)*discreteActionData)->id, d);		pstrcat( d, "\p-");	} else d[0] = 0;	pstrcat( d, s);	return d;}StringPtr GetActionNameFromDiscreteActionID( heraScenarioFileType *heraFile,	long id, StringPtr d,	Boolean includeID){	Handle 	discreteActionData = nil;		mAssert( d != nil);	if ( id < 0)	{		pstrcpy(d, "\p-");		return d;	}		discreteActionData = HD_Find_Discrete_Data( heraFile, id, -1, nil,		kHera_Action_Type);			if ( discreteActionData == nil)	{		pstrcpy(d, "\pnot found");		return d;	}		return GetActionNameFromDiscreteAction( heraFile, discreteActionData, d,		includeID);}/* GetObjectNameFromDiscreteObject	whichString =	0 = shortString					1 = longString					2 = devNote*/StringPtr GetObjectNameFromDiscreteObject( heraScenarioFileType *heraFile, 	Handle discreteObjectData, StringPtr d,	long whichString){	Handle						discreteObjectStringsData;	heraBaseObjectStringsType	*objectStrings = nil;	Str255						s;	long						len = 255;		mAssert( discreteObjectData != nil);	mAssert( d != nil);	discreteObjectStringsData = HD_Find_Discrete_Data( heraFile,		((heraDataHeaderType *)*discreteObjectData)->id, 1, nil, kHera_ObjectStrings_Type);			mAssert( discreteObjectStringsData != nil);		objectStrings = (heraBaseObjectStringsType *)HD_DiscreteData_GetNthElement(									discreteObjectStringsData, kHera_ObjectStrings_Type,									0);	mAssert( objectStrings != nil);	switch( whichString)	{		case 0:			pstrcpy( s, objectStrings->shortName);			len = kObjectShortNameLength;			break;				case 1:			pstrcpy( s, objectStrings->longName);			len = kObjectNameLength;			break;				case 2:			pstrcpy( s, objectStrings->devNote);			len = 255;			break;	}			if ( s[0] > len) s[0] = len;	pstrcpy( d, s);	return d;}StringPtr GetObjectNameFromDiscreteObjectID( heraScenarioFileType *heraFile, 	long id, StringPtr d,	long whichString){	Handle						discreteObjectStringsData;	heraBaseObjectStringsType	*objectStrings = nil;	Str255						s;	long						len = 255;		mAssert( d != nil);	d[0] = 0;		discreteObjectStringsData = HD_Find_Discrete_Data( heraFile, id, 1, nil,		kHera_ObjectStrings_Type);		if ( discreteObjectStringsData == nil)	{		pstrcpy( d, "\pNOTFOUND");		return d;	}	mAssert( discreteObjectStringsData != nil);		objectStrings = (heraBaseObjectStringsType *)HD_DiscreteData_GetNthElement(									discreteObjectStringsData, kHera_ObjectStrings_Type,									0);	mAssert( objectStrings != nil);	switch( whichString)	{		case 0:			pstrcpy( s, objectStrings->shortName);			len = kObjectShortNameLength;			break;				case 1:			pstrcpy( s, objectStrings->longName);			len = kObjectNameLength;			break;				case 2:			pstrcpy( s, objectStrings->devNote);			len = 255;			break;	}			if ( s[0] > len) s[0] = len;	pstrcpy( d, s);	return d;}StringPtr GetObjectName_WithID_FromDiscreteObjectID( heraScenarioFileType *heraFile,	long id, StringPtr d,	long whichString){	Handle						discreteObjectStringsData;	heraBaseObjectStringsType	*objectStrings = nil;	Str255						s;	long						len = 255;		mAssert( d != nil);	d[0] = 0;		discreteObjectStringsData = HD_Find_Discrete_Data( heraFile, id, 1, nil,		kHera_ObjectStrings_Type);	if ( discreteObjectStringsData == nil)	{		pstrcpy( d, "\pNOTFOUND");		return d;	}	mAssert( discreteObjectStringsData != nil);		objectStrings = (heraBaseObjectStringsType *)HD_DiscreteData_GetNthElement(									discreteObjectStringsData, kHera_ObjectStrings_Type,									0);	mAssert( objectStrings != nil);	NumToString( id, d);	switch( whichString)	{		case 0:			pstrcpy( s, objectStrings->shortName);			len = kObjectShortNameLength;			break;				case 1:			pstrcpy( s, objectStrings->longName);			len = kObjectNameLength;			break;				case 2:			pstrcpy( s, objectStrings->devNote);			len = 255;			break;	}			if ( s[0] > len) s[0] = len;	pstrcat( d, "\p ");	pstrcat( d, s);	return d;}StringPtr MakeConditionName( heraScenarioFileType *heraFile, scenarioConditionType *condition, Handle conditionData,	long conditionNumber, Handle objectData, Handle objectNameStringList,	StringPtr destString){	Str255				s;	Boolean				releaseConditionData = false, setConditionDataState = false;	SignedByte			conditionDataState;	short				oldResFile;	#pragma unused ( objectData, objectNameStringList)		if ( condition == nil)	{		if ( conditionData == nil)		{			HU_UseResFile( heraFile->fileRefNum, &oldResFile);						conditionData = HRT_Resource_GetEZ( heraFile,'obac', 500);			UseResFile( oldResFile);			if ( conditionData == nil)			{				destString[0] = 0;				return destString;			}			HLock( conditionData);			conditionDataState = 0;			releaseConditionData = setConditionDataState = true;		} else		{			conditionDataState = HGetState( conditionData);			HLock( conditionData);		}		condition = (scenarioConditionType *)*conditionData + conditionNumber;	}		destString[0] = 0;	NumToString( conditionNumber, s);	if ( s[0] == 1) ConcatenatePString(destString, "\p00");	else if ( s[0] == 2) ConcatenatePString(destString, "\p0");	pstrcat( destString, s);	pstrcat( destString, "\p ");		switch( condition->condition)	{		case kCounterCondition:			GetIndString( s, 8020, 2);			pstrcat( destString, s);			NumToString( condition->conditionArgument.counter.whichCounter, s);			pstrcat( destString, s);			GetIndString( s, 8020, 3);			pstrcat( destString, s);			NumToString( condition->conditionArgument.counter.whichPlayer, s);			pstrcat( destString, s);			GetIndString( s, 8020, 4);			pstrcat( destString, s);			NumToString( condition->conditionArgument.counter.amount, s);			pstrcat( destString, s);			break;					case kCounterGreaterCondition:			GetIndString( s, 8020, 2);			pstrcat( destString, s);			NumToString( condition->conditionArgument.counter.whichCounter, s);			pstrcat( destString, s);			GetIndString( s, 8020, 3);			pstrcat( destString, s);			NumToString( condition->conditionArgument.counter.whichPlayer, s);			pstrcat( destString, s);			GetIndString( s, 8020, 5);			pstrcat( destString, s);			NumToString( condition->conditionArgument.counter.amount, s);			pstrcat( destString, s);			break;					case kCounterNotCondition:			GetIndString( s, 8020, 2);			pstrcat( destString, s);			NumToString( condition->conditionArgument.counter.whichCounter, s);			pstrcat( destString, s);			GetIndString( s, 8020, 3);			pstrcat( destString, s);			NumToString( condition->conditionArgument.counter.whichPlayer, s);			pstrcat( destString, s);			GetIndString( s, 8020, 6);			pstrcat( destString, s);			NumToString( condition->conditionArgument.counter.amount, s);			pstrcat( destString, s);			break;					case kProximityCondition:			GetIndString( s, 8020, 11);			pstrcat( destString, s);			NumToString( condition->conditionArgument.longValue, s);			pstrcat( destString, s);			GetIndString( s, 8020, 12);			pstrcat( destString, s);			break;					case kDistanceGreaterCondition:			GetIndString( s, 8020, 13);			pstrcat( destString, s);			NumToString( condition->conditionArgument.longValue, s);			pstrcat( destString, s);			GetIndString( s, 8020, 14);			pstrcat( destString, s);			break;				case kOwnerCondition:			GetIndString( s, 8020, 9);			pstrcat( destString, s);			NumToString( condition->conditionArgument.longValue, s);			pstrcat( destString, s);			break;				case kDestructionCondition:			GetIndString( s, 8020, 7);			pstrcat( destString, s);			NumToString( condition->conditionArgument.longValue, s);			pstrcat( destString, s);			GetIndString( s, 8020, 8);			pstrcat( destString, s);			break;				case kTimeCondition:			GetIndString( s, 8020, 10);			pstrcat( destString, s);			NumToString( condition->conditionArgument.longValue, s);			pstrcat( destString, s);			break;				case kHalfHealthCondition:			GetIndString( s, 8020, 15);			pstrcat( destString, s);			break;		case kIsAuxiliaryObject:			GetIndString( s, 8020, 16);			pstrcat( destString, s);			break;		case kIsTargetObject:			GetIndString( s, 8020, 17);			pstrcat( destString, s);			break;				case kVelocityLessThanEqualToCondition:			GetIndString( s, 8020, 18);			pstrcat( destString, s);			SmallFixedToString( condition->conditionArgument.longValue, s);			pstrcat( destString, s);			break;		case kNoShipsLeftCondition:			GetIndString( s, 8020, 19);			pstrcat( destString, s);			NumToString( condition->conditionArgument.longValue, s);			pstrcat( destString, s);			GetIndString( s, 8020, 20);			pstrcat( destString, s);			break;		case kCurrentMessageCondition:			GetIndString( s, 8020, 23);			pstrcat( destString, s);			NumToString( condition->conditionArgument.location.v, s);			pstrcat( destString, s);			GetIndString( s, 8020, 24);			pstrcat( destString, s);			NumToString( condition->conditionArgument.location.h, s);			pstrcat( destString, s);			break;				case kCurrentComputerCondition:			GetIndString( s, 8020, 35);			pstrcat( destString, s);			NumToString( condition->conditionArgument.location.v, s);			pstrcat( destString, s);			GetIndString( s, 8020, 36);			pstrcat( destString, s);			NumToString( condition->conditionArgument.location.h, s);			pstrcat( destString, s);			break;				case kZoomLevelCondition:			GetIndString( s, 8020, 37);			pstrcat( destString, s);			NumToString( condition->conditionArgument.longValue, s);			pstrcat( destString, s);			break;			case kAutopilotCondition:			GetIndString( s, 8020, 38);			pstrcat( destString, s);			break;					case kNotAutopilotCondition:			GetIndString( s, 8020, 39);			pstrcat( destString, s);			break;		case kObjectIsBeingBuilt:			GetIndString( s, 8020, 40);			pstrcat( destString, s);			break;		case kDirectIsSubjectTarget:			GetIndString( s, 8020, 41);			pstrcat( destString, s);			break;		case kSubjectIsPlayerCondition:			GetIndString( s, 8020, 42);			pstrcat( destString, s);			break;		default:			pstrcat( destString, "\p- none -");			break;	}	if ( setConditionDataState) HSetState( conditionData, conditionDataState);	if ( releaseConditionData) DisposeHandle( conditionData);	return destString;	}StringPtr MakeInitialName( heraScenarioFileType *heraFile,	scenarioInitialType *initial, Handle initialData,	long initialNumber, Handle objectData, Handle objectNameStringList,	StringPtr destString){	Str255				s;	Boolean				releaseInitialData = false, setInitialDataState = false;	SignedByte			initialDataState;	short				oldResFile;//	#pragma unused ( objectData, objectNameStringList)		if ( initial == nil)	{		if ( initialData == nil)		{			HU_UseResFile( heraFile->fileRefNum, &oldResFile);						initialData = HRT_Resource_GetEZ( heraFile,'obac', 500);			UseResFile( oldResFile);			if ( initialData == nil)			{				destString[0] = 0;				return destString;			}			HLock( initialData);			initialDataState = 0;			releaseInitialData = setInitialDataState = true;		} else		{			initialDataState = HGetState( initialData);			HLock( initialData);		}		initial = (scenarioInitialType *)*initialData + initialNumber;	}		destString[0] = 0;	NumToString( initialNumber, s);	if ( s[0] == 1) ConcatenatePString(destString, "\p00");	else if ( s[0] == 2) ConcatenatePString(destString, "\p0");	pstrcat( destString, s);	pstrcat( destString, "\p = ");	pstrcat( destString,	MakeObjectName( heraFile, objectData, objectNameStringList, initial->type, s));			if ( setInitialDataState) HSetState( initialData, initialDataState);	if ( releaseInitialData) DisposeHandle( initialData);	return destString;}StringPtr HNM_Resource_Name_Make( heraScenarioFileType *heraFile,	ResType theType, short resID, StringPtr theString){	Str255		s;	Handle		tempData;		if ( resID < 0)	{		theString[0] = 1;		theString[1] = 'Ñ';		return theString;	}		pstrcpy( theString, "\p<");	NumToString( resID, s);	pstrcat( theString, s);	pstrcat( theString, "\p> ");	tempData = HRT_Resource_GetHandle( heraFile, theType, resID, nil, s);	pstrcat( theString, s);	if ( tempData != nil) DisposeHandle( tempData);	return theString;}