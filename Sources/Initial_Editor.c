/******************************************\|**| Initial_Editor.c\******************************************/#pragma mark ¥¥INCLUDES¥¥/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Window Dispatch.h"#include "Control Utilities.h"#include "Hewey.h"#include "Hewey_Main.h"#include "Hewey_Layout.h"#include "Hewey_Utilities.h"#include "str_bp.h"#include "Set Font By String.h"#include "BP_Error.h"#include "Assert.h"#include "strlist.h"#include "Hewey_Helpers.h"#include "Hera_Global.h"#include "Classic2Carbon_Helpers.h"#include "Scenario.h"#pragma mark _this library includes_/* - this project*******************************************/#include "Initial_Editor.h"#include "Hera_Name_Maker.h"#include "Hera_Utilities.h"#include "Bit_Flipper.h"#include "Button_Window.h"#include "Hera_Data.h"#include "Object_Editor.h"#include "STR_Editor.h"#include "Sprite_Selector.h"#pragma mark ¥¥DEFINITIONS¥¥/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kLarge_Tab_Width				112#define	kEditTextFieldWidth				38#define	kEditTextSmallFieldWidth		16#define	kEditTextBigFieldWidth			((kLarge_Tab_Width * 1) + (kEditTextFieldWidth * 2)) //150#define	kColNum							2#define	kRowNum							4#define	kMain_Cell_X					1#define	kMain_Cell_Y					0#define	kMain_ID_Offset					100#define	kSeparator_Cell_X				0#define	kSeparator_Cell_Y				2#define	kSeparator_ID					200#define	kList_ID						6#define	kList_Cell_X					0#define	kList_Cell_Y					0#define	kList_Button_Cell_X				0#define	kList_Button_Cell_Y				1#define	kList_Button_ID_Offset			300#define	kList_Remove_Button_ID			(kList_Button_ID_Offset + 1)#define	kList_Add_Button_ID				(kList_Button_ID_Offset + 2)#define	kInitial_Popup_ID				400#define	kButton_Cell_X					0#define	kButton_Cell_Y					3#define	kOK_Button_ID					1#define	kCancel_Button_ID				2#define	kRevert_Button_ID				3#define	kSmallFontSize					gHera->smallFontSize#define	kSmallFontNum					gHera->smallFontNum#define	kLargeFontNum					gHera->bigFontNum;#define kLargeFontSize					gHera->bigFontSize;#define	kInitial_Panel_Num			18#define	kPanel_ID_Multiplier			2000#define	kPanel_ID_Offset				500#define	kInitial_Main_Cell_X			1#define	kInitial_Main_Cell_Y			0#define	kInitial_ID_Offset				600#define	kInitial_Object_ID				(kInitial_ID_Offset + 2)#define	kInitial_Owner_ID				(kInitial_ID_Offset + 4)#define	kInitial_Attributes_Menu_ID		(kInitial_ID_Offset + 6)#define	kInitial_Attributes_Button_ID	(kInitial_ID_Offset + 8)#define	kInitial_Location_X_ID			(kInitial_ID_Offset + 10)#define	kInitial_Location_Y_ID			(kInitial_ID_Offset + 12)#define	kInitial_Earn_ID				(kInitial_ID_Offset + 14)#define	kInitial_Distance_ID			(kInitial_ID_Offset + 16)#define	kInitial_Rotation_ID			(kInitial_ID_Offset + 18)#define	kInitial_Rotation_Range_ID		(kInitial_ID_Offset + 20)#define	kInitial_Sprite_ID				(kInitial_ID_Offset + 22)#define	kInitial_Build_Types_ID			(kInitial_ID_Offset + 24)#define	kInitial_Target_ID				(kInitial_ID_Offset + 26)#define	kInitial_Name_Res_ID			(kInitial_ID_Offset + 28)#define	kInitial_Name_Index_ID			(kInitial_ID_Offset + 30)#define	kInitial_ObjectSelect_Button	(kInitial_ID_Offset + 32)#define	kInitial_NameSelect_Button		(kInitial_ID_Offset + 34)#define	kInitial_SpriteSelect_Button	(kInitial_ID_Offset + 36)#define	kMiniMap_ID_Offset				700#define	kMiniMap_ID						(kMiniMap_ID_Offset + 2)#define	kMiniMap_CenterButton_ID		(kMiniMap_ID_Offset + 4)#define	kMiniMap_ZoomInButton_ID		(kMiniMap_ID_Offset + 6)#define	kMiniMap_ZoomOutButton_ID		(kMiniMap_ID_Offset + 8)#define	kMiniMap_PositionButton_ID		(kMiniMap_ID_Offset + 10)#define	kMiniMap_ShowNames_ID			(kMiniMap_ID_Offset + 12)#define	kMiniMap_Width					200#define	kMiniMap_Height					200#define	kSubSectorSize					512#define	kSectorSize						4096#define	kSuperSectorSize				32768#define	kStrResID						8025#pragma mark _macros_/* - macros*******************************************/#pragma mark ¥¥TYPEDEFS¥¥/******************************************\|**| typedefs\******************************************/typedef struct Initial_EditorWindowType{	heraScenarioFileType			*heraFile;	huiMasterControlType			*master;	long							windowID;	scenarioInitialType				initial;	Handle							initialData;	long							initialIndex;	long							startInitialIndex;	long							initialNumber;	short							resRefNum;	long							setInitialFlags_WindowID;	Boolean							anyChanges;	Initial_Editor_Callback_procPtr	callBack;	long							callerID;	Boolean							chooseOnly;	Boolean							modal;	long							discreteDataID;	Handle							discreteData;	float							miniMap_scale;	long							miniMap_centerh;	long							miniMap_centerv;	long							miniMap_tool;	Boolean							showNames;	heraDataChangesType				*dataChanges;	Str255							titlePrefix;} Initial_EditorWindowType;typedef struct miniMapSymbolType{	Point							coord;	long							symbolType;	RGBColor						color;	Str255							name;} miniMapSymbolType;#pragma mark ¥¥EXTERNAL GLOBALS¥¥/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark ¥¥PRIVATE GLOBALS¥¥/******************************************\|**| private globals\******************************************/#pragma mark ¥¥PRIVATE PROTOTYPES¥¥/******************************************\|**| private function prototypes\******************************************/static Boolean HandleEvent( EventRecord *, CWindowPtr, long, long);static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID);static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID);static void MiniMap_Draw( CWindowPtr window, Initial_EditorWindowType *d);static Point GetMiniMapCoordsFromGalactic( long gh, long gv, ControlHandle aControl,	Initial_EditorWindowType *d);static void GetGalacticCoordsFromMiniMap( Point where, longPointType *lp,	ControlHandle aControl, Initial_EditorWindowType *d);static void OK_Button( Initial_EditorWindowType *d);static void Cancel_Button( Initial_EditorWindowType *d);static void Revert_Button( Initial_EditorWindowType *d);static void ChangeWhichInitial( Initial_EditorWindowType *d, long newCondtion);static void Window_SetControls_FromInitialIndex( Initial_EditorWindowType *d, CWindowPtr window,	long index);static void Window_SetInitial_FromControls( Initial_EditorWindowType *d, CWindowPtr window,	long index);static void SetInitialField( Initial_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioInitialType *c, long id, Boolean draw);static void GetInitialField( Initial_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioInitialType *c, long id);static void Setup_InitialValues_Panel( Initial_EditorWindowType *d, CWindowPtr window);static void AddBitPopUp(  huiPlainControlParamType *textParam, 	huiPlainControlParamType *buttonParam, long id, short resID, short index,	Boolean newLine, short menuStrResID);static void GetAllData( Initial_EditorWindowType *d);static void SetInitialFlags( long windowID, unsigned long bits);static void OKConfirmCallBack( long whichButton, long windowID);static void CancelConfirmCallBack( long whichButton, long windowID);static void Object_Choose_CallBack( long dispatchID, long objectChoiceID);static void Name_Choose_CallBack( long windowID, long resID, long stringNum);static void Sprite_Choose_CallBack( long windowID, long resID);static void MiniMapTool_Set( Initial_EditorWindowType *d, long whichTool,	Boolean draw);static void InsertInitial( Initial_EditorWindowType *d, CWindowPtr whichWindow);static void DeleteInitial( Initial_EditorWindowType *d, CWindowPtr whichWindow);static void Enable_Editing( Initial_EditorWindowType *d, Boolean enable);#pragma mark ¥¥PRIVATE FUNCTIONS¥¥/******************************************\|**| private functions\******************************************/static Boolean HandleEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID, long command){	switch( command)	{		case kWDCloseWindowCommand:			break;				case kWDProcessEventCommand:			return( ProcessEvent( theEvent, whichWindow, dispatchID));			break;				case kWDSaveWindowCommand:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these initial objects?",										"\pBefore saving, the Initial Object Editor "										"must be closed. Click Cancel to "										"abort the save.", nil, nil))				{					OKConfirmCallBack( 1, dispatchID);									} else				{					gHera->currentSave = nil;				}			}			return false;			break;				case kWD_Close_ForQuit_Command:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these initial objects?",										"\pBefore quitting, the Initial Object Editor "										"must be closed. Click Cancel to "										"abort the quit.", nil, nil))				{					OKConfirmCallBack( 1, dispatchID);									} else				{					gHera->currentSave = nil;					return true;				}			}			return false;			break;				case kWDProcessMenuChoiceCommand:			return( ProcessMenuChoiceCommand( (unsigned long)theEvent,				whichWindow, dispatchID));			break;	}	return false;}static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	SignedByte						dataState;	Initial_EditorWindowType			*d;	Boolean							result = false;	GrafPtr							oldPort;	short							menuID = ((menuData & 0xffff0000) >> 16),									menuItem = (menuData & 0x0000ffff);										if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (Initial_EditorWindowType *)*data;	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);	result = Generic_ProcessMenuChoiceCommand( menuData, whichWindow,												dispatchID);	if ( result)	{		goto ProcessMenuChoiceCommand_Return;	}		switch( menuID)	{		case kEditMenuID:			switch( menuItem)			{				case kEdit_Undo_Item:					result = true;					break;				case kEdit_Add_Item:					result = true;					break;									case kEdit_Delete_Item:					result = true;					break;									case kEdit_Delete_All_Item:					result = true;					break;			}							break;		}	ProcessMenuChoiceCommand_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);}static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Boolean							result = false;	ControlHandle					aControl, oldControl;	short							whichPart, oldValue;	WindowPtr						scratchWindow;	Point							where;	char							whichChar;	GrafPtr							oldPort;	OSStatus						err;	Initial_EditorWindowType		*d;	huiPlainControlType				*hui;		if ( data == nil) return false;	if ( theEvent == nil) return false;		dataState = HGetState( data);	HLock( data);	d = (Initial_EditorWindowType *)*data;		if ( theEvent == nil) goto ProcessEvent_Return;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);		switch( theEvent->what)	{		case nullEvent:			IdleControls( (WindowPtr)whichWindow);			where = theEvent->where;			scratchWindow = WD_FrontWindow();			if ( whichWindow != (CWindowPtr)scratchWindow)			{				goto ProcessEvent_Return;			}			SetPortWindowPort( (WindowPtr)whichWindow);			GlobalToLocal( &where);			whichPart = FindControl( where, (WindowPtr)whichWindow,				&aControl);			if ( aControl == nil)			{				if ( HUI_Control_PtIn( d->master, 0,					kMain_Cell_X, kMain_Cell_Y, kMiniMap_ID, where))				{					whichPart = 1;					aControl = HUI_Control_Get( d->master, 0,						kMain_Cell_X, kMain_Cell_Y, kMiniMap_ID);				}			}			if ( aControl != nil)			{				short cursorID = -1;								hui = (huiPlainControlType *)CU_GetControlReference( aControl);								if ( hui->generic.id == kMiniMap_ID)				{					switch( d->miniMap_tool)					{						case kMiniMap_CenterButton_ID:							cursorID = 128;							break;												case kMiniMap_ZoomInButton_ID:							cursorID = 129;							break;												case kMiniMap_ZoomOutButton_ID:							cursorID = 130;							break;												case kMiniMap_PositionButton_ID:							cursorID = 131;							break;					}										if ( cursorID < 0)					{						InitCursor();					} else					{						SetCursor( *GetCursor( cursorID));					}				} else InitCursor();			} else InitCursor();												result = true;			break;					case updateEvt:				BeginUpdate ((WindowPtr)whichWindow);/*			SetPort( (WindowPtr)whichWindow);//			CalcVis( (WindowPtr)whichWindow);			UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);*/						HU_GenericUpdateEventHandler( whichWindow);			MiniMap_Draw( whichWindow, d);			EndUpdate ((WindowPtr)whichWindow);			result = true;			break;		case activateEvt:		{			Boolean	isActive = ((theEvent->modifiers & activeFlag) != 0);						if ( isActive)			{				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_scenarioFile_refNum);			}		}						oldValue = ((theEvent->modifiers & activeFlag) != 0);			if ( oldValue)			{				aControl = nil;				err = GetRootControl( (WindowPtr)whichWindow, &aControl);				if (( err == noErr) && ( aControl != nil))				{					ActivateControl( aControl);					MiniMap_Draw( whichWindow, d);					result = true;				}			}			break;					case mouseDown:			whichPart = FindWindow (theEvent->where, &scratchWindow);			switch( whichPart)			{				case inGrow:/*					{						Rect	growRect;						long	newSize;//						growRect = qd.screenBits.bounds;						C2C_ScreenBits_GetBounds( &growRect);						growRect.top = growRect.left = 120;						newSize = GrowWindow((WindowPtr)whichWindow,							theEvent->where ,&growRect);						if (newSize != 0)						{							SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,								(((newSize) >> 16) & 0xFFFF), true );							EraseRect(&whichWindow->portRect);							InvalRect( &whichWindow->portRect);						}					}*/					HU_GenericGrowWindow( whichWindow, theEvent->where);					result = true;					break;								case inContent:					where = theEvent->where;					scratchWindow = WD_FrontWindow();					if ( whichWindow != (CWindowPtr)scratchWindow)					{						goto ProcessEvent_Return;					}					SetPortWindowPort( (WindowPtr)whichWindow);					GlobalToLocal( &where);					whichPart = FindControl( where, (WindowPtr)whichWindow,						&aControl);					if ( aControl != nil)						oldValue = GetControlValue( aControl);					else					{						if ( HUI_Control_PtIn( d->master, 0,							kMain_Cell_X, kMain_Cell_Y, kMiniMap_ID, where))						{							whichPart = 1;							aControl = HUI_Control_Get( d->master, 0,								kMain_Cell_X, kMain_Cell_Y, kMiniMap_ID);						}					}					if ( aControl == nil)						goto ProcessEvent_Return;					err = GetKeyboardFocus( (WindowPtr)whichWindow, &oldControl);					if (( err == noErr) && ( oldControl != aControl))					{						SetKeyboardFocus( (WindowPtr)whichWindow, aControl, whichPart);					}										if ( aControl != nil)					{						hui = (huiPlainControlType *)CU_GetControlReference( aControl);												if ( hui->generic.id == kMiniMap_ID) whichPart = 1;					}										if ( whichPart != 0)					{//						whichPart = HandleControlClick ( aControl, where,//							theEvent->modifiers, (ControlActionUPP)-1);							if ( !ListBox_Appearance_1_0_1_Hack( aControl, where,									&whichPart))						{							whichPart = HUI_Control_Click_Handle( hui, where,								theEvent->modifiers);														}						if ( hui->generic.id == kMiniMap_ID) whichPart = 1;						if ( whichPart != kControlNoPart) switch( hui->generic.id)						{							case kOK_Button_ID:								Window_SetInitial_FromControls( d,									whichWindow, d->initialIndex + d->startInitialIndex);								result = true;								OK_Button( d);								data = nil;								goto ProcessEvent_Return;								break;														case kCancel_Button_ID:								Cancel_Button( d);								data = nil;								result = true;								goto ProcessEvent_Return;								break;															case kRevert_Button_ID:								Revert_Button( d);								break;															case kInitial_Attributes_Button_ID:								BitFlipper_NewWindow( &d->setInitialFlags_WindowID,									"\pInitial Attributes",									GetStringList( 630),									d->initial.attributes, dispatchID,									SetInitialFlags);								result = true;								break;														case kInitial_Attributes_Menu_ID:							{								unsigned long bit;																if (( whichPart == kControlMenuPart) &&									(!( d->chooseOnly)))								{									oldValue = GetBevelMenuValue( aControl) - 1;									bit = 0x01 << oldValue;									d->initial.attributes ^= bit;									HU_Menu_SetCheckFromBits( aControl,										d->initial.attributes, oldValue, oldValue);								}							}								break;														case kList_ID:								oldValue = d->initialIndex;																d->initialIndex = HUI_Control_GetListValue(										d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, d->initialIndex);								if ( d->initialIndex != oldValue)								{																	Window_SetInitial_FromControls( d,										whichWindow, oldValue + d->startInitialIndex);									Window_SetControls_FromInitialIndex(										d, whichWindow, d->initialIndex + d->startInitialIndex);																		MiniMap_Draw( whichWindow, d);																		}								result = true;								break;														case kMiniMap_ID:							{								longPointType	lp;																GetGalacticCoordsFromMiniMap( where, &lp,															aControl, d);																switch ( d->miniMap_tool)								{									case kMiniMap_CenterButton_ID:										d->miniMap_centerh = lp.h;										d->miniMap_centerv = lp.v;										break;																		case kMiniMap_ZoomInButton_ID:										d->miniMap_centerh = lp.h;										d->miniMap_centerv = lp.v;										if ( d->miniMap_scale < 1.0)											d->miniMap_scale *= 2.0;										break;																		case kMiniMap_ZoomOutButton_ID:										d->miniMap_centerh = lp.h;										d->miniMap_centerv = lp.v;										if ( d->miniMap_scale > .00125)											d->miniMap_scale /= 2.0;										break;																		case kMiniMap_PositionButton_ID:										if ( d->initialIndex <													d->initialNumber)										{											huiPlainControlParamType												dummyParam;												d->initial.location = lp;											dummyParam.layer = 0;											dummyParam.cellx =												kInitial_Main_Cell_X;											dummyParam.celly =												kInitial_Main_Cell_Y;											dummyParam.master = d->master;											SetInitialField( d, &dummyParam, &d->initial, kInitial_Location_X_ID, true);											SetInitialField( d, &dummyParam, &d->initial, kInitial_Location_Y_ID, true);										}										break;								}																								MiniMap_Draw( whichWindow, d);															}								break;							case kMiniMap_CenterButton_ID:								MiniMapTool_Set( d, kMiniMap_CenterButton_ID,									true);								break;							case kMiniMap_ZoomInButton_ID:								MiniMapTool_Set( d, kMiniMap_ZoomInButton_ID,									true);								break;							case kMiniMap_ZoomOutButton_ID:								MiniMapTool_Set( d, kMiniMap_ZoomOutButton_ID,									true);								break;							case kMiniMap_PositionButton_ID:								MiniMapTool_Set( d, kMiniMap_PositionButton_ID,									true);								break;														case kMiniMap_ShowNames_ID:								ReverseCheckBox( aControl);								if ( GetControlValue( aControl))									d->showNames = true;								else									d->showNames = false;								MiniMap_Draw( whichWindow, d);								result = true;								break;							case kInitial_ObjectSelect_Button:							{								long newWindowID = -1;								Str255	tString, tString2;																pstrcpy( tString, d->titlePrefix);								pstrcat( tString, "\p: Initial #");								NumToString( d->initialIndex, tString2);								pstrcat( tString, tString2);																ObjectEditor_NewWindow( d->heraFile,									&newWindowID, dispatchID, d->initial.type,									tString, d->resRefNum, true, true,									false, true, Object_Choose_CallBack);							}								result = true;								break;							case kInitial_Name_Res_ID - 1:								if ( !GetControlValue( aControl))								{									STR_Editor_NewWindow( d->heraFile,										"\pChoose Initial Object Name",										d->resRefNum, d->initial.nameResID,										d->initial.nameStrNum, true, true,										true, dispatchID, Name_Choose_CallBack);								} else								{									Name_Choose_CallBack( dispatchID, -1, -1);								}								result = true;								break;														case kInitial_NameSelect_Button:								STR_Editor_NewWindow( d->heraFile,									"\pChoose Initial Object Name",									d->resRefNum, d->initial.nameResID,									d->initial.nameStrNum, true, true,									true, dispatchID, Name_Choose_CallBack);								result = true;								break;															case kInitial_Sprite_ID - 1:								if ( !GetControlValue( aControl))								{									Sprite_Selector_NewWindow( d->heraFile,										"\pInitial Object Sprite Override",										d->resRefNum,										d->initial.spriteIDOverride,										dispatchID,										true,										Sprite_Choose_CallBack);								} else								{									Sprite_Choose_CallBack( dispatchID, -1);								}								result = true;								break;														case kInitial_SpriteSelect_Button:								Sprite_Selector_NewWindow( d->heraFile,									"\pInitial Object Sprite Override",									d->resRefNum,									d->initial.spriteIDOverride,									dispatchID,									true,									Sprite_Choose_CallBack);								result = true;								break;															case kList_Add_Button_ID:								InsertInitial( d, whichWindow);								result = true;								break;														case kList_Remove_Button_ID:								if ( HU_Confirm_Delete("\pAre you sure you "									"want to delete this initial object?",										theEvent->modifiers))									DeleteInitial( d, whichWindow);								result = true;								break;									default:								break;						}					} else // not in control					{						where = theEvent->where;						GlobalToLocal( &where);					}			}			break;					case keyDown:		case autoKey:			whichChar = theEvent->message & charCodeMask;			if ((whichChar=='\r' || whichChar==0x3))			{				// ok				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kOK_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);					result = true;					OK_Button( d);					data = nil;					goto ProcessEvent_Return;				}			} else if ((whichChar==0x1b) || ((whichChar=='.') && (theEvent->modifiers & cmdKey)))			{				// cancel				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kCancel_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);										Cancel_Button( d);					data = nil;					result = true;					goto ProcessEvent_Return;				}			} else if ( whichChar == '\t')			{				if ( theEvent->modifiers & shiftKey)					ReverseKeyboardFocus( (WindowPtr)whichWindow);				else					AdvanceKeyboardFocus( (WindowPtr)whichWindow);				result = true;				break;			} else if (( whichChar == 0x08) && ( !d->chooseOnly))			{				huiPlainControlType	*hui = nil;				err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);				hui = (huiPlainControlType	*)CU_GetControlReference( aControl);				if ( hui != nil)				{					if ( hui->generic.id == kList_ID)					{						if ( HU_Confirm_Delete("\pAre you sure you "							"want to delete this initial object?",								theEvent->modifiers))							DeleteInitial( d, whichWindow);					}				}				result = true;			}						err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);			if (( err == noErr) && ( aControl != nil))			{				whichPart = HandleControlKey( aControl,					(theEvent->message & keyCodeMask)>>16,					theEvent->message & charCodeMask, theEvent->modifiers);				{					hui = (huiPlainControlType	*)CU_GetControlReference( aControl);					switch( hui->generic.id)					{													case kList_ID:							oldValue = d->initialIndex;							d->initialIndex = HUI_Control_GetListValue(									d->master, 0, kList_Cell_X, kList_Cell_Y,									kList_ID, d->initialIndex);														if ( d->initialIndex != oldValue)							{								Window_SetInitial_FromControls( d,									whichWindow, oldValue + d->startInitialIndex);//								ChangeWhichInitial( d, 5);								Window_SetControls_FromInitialIndex(									d, whichWindow, d->initialIndex + d->startInitialIndex									);																MiniMap_Draw( whichWindow, d);							}							break;					}				}			}			break;	}		ProcessEvent_Return:	SetPort( oldPort);	if ( data != nil)		HSetState( data, dataState);	return( result);	}static void MiniMap_Draw( CWindowPtr window, Initial_EditorWindowType *d){	ControlHandle	aControl = HUI_Control_Get( d->master, 0,						kMain_Cell_X, kMain_Cell_Y, kMiniMap_ID);	RgnHandle		originalClip = nil, newClip = nil;	RGBColor		c, originalForeColor, originalBackColor;	GrafPtr			oldPort;	long			i, sectorSize;	miniMapSymbolType	*symbols = nil;	float 			f;	longPointType	tlp, brp, lp;	Point			p;	Str255			s;	Rect			controlBounds;		mAssert( d != nil);	symbols = (miniMapSymbolType *)NewPtr( sizeof( miniMapSymbolType) *		d->initialNumber);	if ( symbols == nil) return;		GetPort( &oldPort);	if ( aControl == nil) goto MiniMap_Draw_error;		SetPortWindowPort( (WindowPtr)window);	originalClip = NewRgn();	if ( originalClip == nil) goto MiniMap_Draw_error;	GetClip( originalClip);	newClip = NewRgn();	if ( newClip == nil) goto MiniMap_Draw_error;		CU_GetControlBounds( aControl, &controlBounds);	RectRgn( newClip, &controlBounds);	SectRgn( originalClip, newClip, newClip);		SetClip( newClip);	GetForeColor( &originalForeColor);	GetBackColor( &originalBackColor);	c.red = c.blue = c.green = 0;	RGBForeColor ( &c);	c.red = c.blue = c.green = 65535;	RGBBackColor( &c);	PaintRect( &controlBounds);		// draw the sector lines	sectorSize = f = kSubSectorSize;	f *= d->miniMap_scale;	c.red = c.blue = 0;	c.green = 32768;	if ( f < 16.0)	{		sectorSize = f = kSectorSize;		f *= d->miniMap_scale;		c.red = c.green = 20000;		c.blue = 40000;		if ( f < 16.0)		{			c.red = c.green = 0;			c.blue = 65535;			sectorSize = f = kSuperSectorSize;			f *= d->miniMap_scale;		}	}	p.h = controlBounds.left;	p.v = controlBounds.top;	GetGalacticCoordsFromMiniMap( p, &tlp, aControl, d);	p.h = controlBounds.right;	p.v = controlBounds.bottom;	GetGalacticCoordsFromMiniMap( p, &brp, aControl, d);		i = tlp.h - (tlp.h & ( sectorSize - 1));	while ( i < brp.h)	{		if ( i == 0)		{			c.red = c.green = c.blue = 65535;			RGBForeColor( &c);		} else		{			c.red = c.blue = 0;			c.green = 32768;			if ( f < 16.0)			{				sectorSize = f = kSectorSize;				f *= d->miniMap_scale;				c.red = c.green = 20000;				c.blue = 40000;				if ( f < 16.0)				{					c.red = c.green = 0;					c.blue = 65535;					sectorSize = f = kSuperSectorSize;					f *= d->miniMap_scale;				}			}			RGBForeColor( &c);		}		lp.h = i;		lp.v = tlp.v;		p = GetMiniMapCoordsFromGalactic( lp.h, lp.v, aControl, d);		MoveTo( p.h, controlBounds.top);		LineTo( p.h, controlBounds.bottom - 1);		i += sectorSize;	}		i = tlp.v - (tlp.v & ( sectorSize - 1));	while ( i < brp.v)	{		if ( i == 0)		{			c.red = c.green = c.blue = 65535;			RGBForeColor( &c);		} else		{			c.red = c.blue = 0;			c.green = 32768;			if ( f < 16.0)			{				sectorSize = f = kSectorSize;				f *= d->miniMap_scale;				c.red = c.green = 20000;				c.blue = 40000;				if ( f < 16.0)				{					c.red = c.green = 0;					c.blue = 65535;					sectorSize = f = kSuperSectorSize;					f *= d->miniMap_scale;				}			}			RGBForeColor( &c);		}		lp.h = tlp.h;		lp.v = i;		p = GetMiniMapCoordsFromGalactic( lp.h, lp.v, aControl, d);		MoveTo( controlBounds.left, p.v);		LineTo( controlBounds.right - 1, p.v);		i += sectorSize;	}	for ( i = 0; i < d->initialNumber; i++)	{		scenarioInitialType *initial = (scenarioInitialType *)*d->initialData +								i;		baseObjectType		*o = nil;		Handle				objectData;		miniMapSymbolType	*aSymbol = symbols + i;		if ( i == d->initialIndex) initial = &d->initial;		objectData = HD_Find_Discrete_Data( d->heraFile,			initial->type, 1, nil,			kHera_Object_Type);		if ( objectData != nil)		{			o = (baseObjectType *)HD_DiscreteData_GetNthElement(				objectData, kHera_Object_Type, 0);			if ( o != nil)			{				if ( o->attributes & kIsDestination)				{					aSymbol->symbolType = 1;				} else				{					aSymbol->symbolType = 0;				}			}		} else aSymbol->symbolType = -1;				if ( initial->owner == 0)		{			aSymbol->color.red = aSymbol->color.blue = 0;			aSymbol->color.green = 65535;		} else if (initial->owner < 0)		{			aSymbol->color.red = aSymbol->color.green = 0;			aSymbol->color.blue = 65535;		} else		{			aSymbol->color.green = aSymbol->color.blue = 0;			aSymbol->color.red = 65535;		}		aSymbol->coord = GetMiniMapCoordsFromGalactic( initial->location.h,			initial->location.v, aControl, d);				if ( d->showNames)		{//			GetObjectName_WithID_FromDiscreteObjectID(//					initial->type, aSymbol->name, 0);			MakeInitialName( d->heraFile, initial, nil, i, nil, nil, aSymbol->name); 			if ( initial->nameResID > 0)			{				pstrcat( aSymbol->name, "\p: ");				HU_GetOneIndString( d->heraFile, initial->nameResID,									initial->nameStrNum, s)	;				pstrcat( aSymbol->name, s);						}					}			}		// 1st go through and connect all dest objects	for ( i = 0; i < d->initialNumber; i++)	{		miniMapSymbolType	*aSymbol = symbols + i;		long				j;				c.red = c.blue = 65535;		c.green = 0;		RGBForeColor( &c);		if ( aSymbol->symbolType == 1)		{			for ( j = i + 1; j < d->initialNumber; j++)			{				miniMapSymbolType	*otherSymbol = symbols + j;				if ( otherSymbol->symbolType == 1)				{					MoveTo( aSymbol->coord.h, aSymbol->coord.v);					LineTo( otherSymbol->coord.h, otherSymbol->coord.v);				}			}		}	}		TextFont( kSmallFontNum);	TextSize( kSmallFontSize);		// draw the actual symbols	for ( i = 0; i < d->initialNumber; i++)	{		miniMapSymbolType	*aSymbol = symbols + i;		Rect				symbolBounds;				RGBForeColor( &aSymbol->color);		switch ( aSymbol->symbolType)		{			case 0:				SetRect( &symbolBounds, aSymbol->coord.h - 2,					aSymbol->coord.v - 2, aSymbol->coord.h + 2,					aSymbol->coord.v + 2);				PaintRect( &symbolBounds);				break;						case 1:				SetRect( &symbolBounds, aSymbol->coord.h - 5,					aSymbol->coord.v - 5, aSymbol->coord.h + 5,					aSymbol->coord.v + 5);				PaintRect( &symbolBounds);				break;		}		if ( d->showNames)		{			MoveTo( aSymbol->coord.h, aSymbol->coord.v + 6 + kSmallFontSize);			DrawString( aSymbol->name);		}	}		if (( d->initialNumber > 0) && ( d->initialIndex < d->initialNumber))	{		miniMapSymbolType	*aSymbol = symbols + d->initialIndex;		Rect				symbolBounds;				SetRect( &symbolBounds, aSymbol->coord.h - 7,			aSymbol->coord.v - 7, aSymbol->coord.h + 7,			aSymbol->coord.v + 7);				c.red = c.green = 65535;		c.blue = 0;		RGBForeColor( &c);		PenSize( 2, 2);		FrameOval( &symbolBounds);		PenSize( 1, 1);	}	if ( originalClip != nil)	{		SetClip( originalClip);		DisposeRgn( originalClip);	}	if ( newClip != nil) DisposeRgn( newClip);	originalClip = newClip = nil;	DrawThemeGenericWell(&controlBounds, kThemeStateActive, false);	MiniMap_Draw_error:	RGBForeColor ( &originalForeColor);	RGBBackColor( &originalBackColor);	if ( symbols != nil) DisposePtr( (Ptr)symbols);	if ( originalClip != nil)	{		SetClip( originalClip);		DisposeRgn( originalClip);	}	if ( newClip != nil) DisposeRgn( newClip);	SetPort( oldPort);}static Point GetMiniMapCoordsFromGalactic( long gh, long gv,	ControlHandle aControl, Initial_EditorWindowType *d){	float	f;	Point	result;	Rect	controlBounds;		if ( aControl == nil)	{		aControl = HUI_Control_Get( d->master, 0,						kMain_Cell_X, kMain_Cell_Y, kMiniMap_ID);	}		mAssert( aControl != nil);	if ( aControl != nil)		CU_GetControlBounds( aControl, &controlBounds);		f = gh - d->miniMap_centerh;	f *= d->miniMap_scale;	result.h = f;	result.h += controlBounds.left + kMiniMap_Width / 2;	f = gv - d->miniMap_centerv;	f *= d->miniMap_scale;	result.v = f;	result.v += controlBounds.top + kMiniMap_Height / 2;		return result;}static void GetGalacticCoordsFromMiniMap( Point where, longPointType *lp,	ControlHandle aControl, Initial_EditorWindowType *d){	float	f;	Rect	controlBounds;		if ( aControl == nil)	{		aControl = HUI_Control_Get( d->master, 0,						kMain_Cell_X, kMain_Cell_Y, kMiniMap_ID);	}	mAssert( aControl != nil);	if ( aControl != nil)		CU_GetControlBounds( aControl, &controlBounds);			where.h -= controlBounds.left + kMiniMap_Width / 2;	f = where.h;	f /= d->miniMap_scale;	lp->h = f;	lp->h += d->miniMap_centerh;		where.v -= controlBounds.top + kMiniMap_Height / 2;	f = where.v;	f /= d->miniMap_scale;	lp->v = f;	lp->v += d->miniMap_centerv;}static void OK_Button( Initial_EditorWindowType *d){	if ( d->chooseOnly)	{		OKConfirmCallBack( 1, d->windowID);	} else	{//		Button_Window_NewWindow("\pSave Changes to Initials", true, false, 8021,//			8022, OKConfirmCallBack, d->windowID);		OKConfirmCallBack( kOK_Button_ID, d->windowID);	}}static void Cancel_Button( Initial_EditorWindowType *d){//	Button_Window_NewWindow("\pDiscard Changes to Initials", true, false, 8023,//		8024, CancelConfirmCallBack, d->windowID);	CancelConfirmCallBack( kOK_Button_ID, d->windowID);}static void Revert_Button( Initial_EditorWindowType *d){	CWindowPtr whichWindow = GetWindowPtrFromDispatchWindowID( d->windowID);		if ( whichWindow == nil) return;	if ( !Button_Window_Modal( "\pRevert this initial object?",							"\pClick Revert to restore this inital object to its "							"previous values. Click Cancel to "							"keep it as it is.", "\pRevert", nil))		return;	Window_SetControls_FromInitialIndex(			d, whichWindow, d->initialIndex + d->startInitialIndex);}static void Window_SetControls_FromInitialIndex( Initial_EditorWindowType *d, CWindowPtr window,	long index){	SignedByte					initialDataState;	GrafPtr						oldPort;	scenarioInitialType		*aInitial;	huiPlainControlParamType	dummyParam;		mAssert( d != nil);		if (( d->initialData == nil) || ( d->initialNumber <= 0)) return;		mAssert( d->initialData != nil);		initialDataState = HGetState( d->initialData);	HLock( d->initialData);	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);		aInitial = (scenarioInitialType *)*d->initialData + index;		BlockMoveData( aInitial, &d->initial, sizeof( scenarioInitialType));	// set qualifiers	dummyParam.layer = 0;	dummyParam.cellx = kInitial_Main_Cell_X;	dummyParam.celly = kInitial_Main_Cell_Y;	dummyParam.master = d->master;		SetInitialField( d, &dummyParam, aInitial, kInitial_Object_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Owner_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Attributes_Menu_ID, true);	d->initial.attributes = aInitial->attributes;	SetInitialField( d, &dummyParam, aInitial, kInitial_Location_X_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Location_Y_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Earn_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Distance_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Rotation_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Rotation_Range_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Sprite_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Sprite_ID-1, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Build_Types_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Target_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Name_Res_ID, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Name_Res_ID-1, true);	SetInitialField( d, &dummyParam, aInitial, kInitial_Name_Index_ID, true);	HSetState( d->initialData, initialDataState);}static void Window_SetInitial_FromControls( Initial_EditorWindowType *d, CWindowPtr window,	long index){	SignedByte					initialDataState;	GrafPtr						oldPort;	scenarioInitialType			*aInitial;	huiPlainControlParamType	dummyParam;	Str255						s;		mAssert( d != nil);	if (( d->initialData == nil) || ( d->initialNumber <= 0)) return;	if ( d->chooseOnly) return;		mAssert( d->initialData != nil);		initialDataState = HGetState( d->initialData);	HLock( d->initialData);	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);		aInitial = (scenarioInitialType *)*d->initialData + index;		BlockMoveData( &d->initial, aInitial, sizeof( scenarioInitialType));	// set qualifiers	dummyParam.layer = 0;	dummyParam.cellx = kInitial_Main_Cell_X;	dummyParam.celly = kInitial_Main_Cell_Y;	dummyParam.master = d->master;		GetInitialField( d, &dummyParam, aInitial, kInitial_Object_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Owner_ID);	aInitial->attributes = d->initial.attributes;	GetInitialField( d, &dummyParam, aInitial, kInitial_Attributes_Menu_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Location_X_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Location_Y_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Earn_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Distance_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Rotation_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Rotation_Range_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Sprite_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Build_Types_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Target_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Name_Res_ID);	GetInitialField( d, &dummyParam, aInitial, kInitial_Name_Index_ID);	BlockMoveData( aInitial, &d->initial, sizeof( scenarioInitialType));	MakeInitialName(  d->heraFile, nil, d->initialData, index, nil, nil, s); 	if ( s[0] == 0) pstrcpy( s, "\puntitled");		HUI_Control_SetListCell( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, 0, index,		(Ptr)&s[1], s[0]);		HUI_Control_Draw( d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	BlockMoveData( aInitial, &d->initial, sizeof( scenarioInitialType));	HSetState( d->initialData, initialDataState);}static void SetInitialField( Initial_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioInitialType *i, long id, Boolean draw){	ControlHandle	aControl;	Str255			s;#pragma unused( d)		if ( dummyParam == nil) return;	if ( i == nil) return;	if ( id < 0) return;		aControl = HUI_Control_Get( dummyParam->master, dummyParam->layer, dummyParam->cellx,		dummyParam->celly, id);	if ( aControl == nil) return;		switch( id)	{		case kInitial_Attributes_Menu_ID:			HU_Menu_SetCheckFromBits( aControl, i->attributes, 0, 31);			break;					case kInitial_Object_ID://			SetControlTextItemLong( aControl, i->type);			SetControlTextItemString( aControl,				GetObjectName_WithID_FromDiscreteObjectID(					d->heraFile, i->type, s, 0));			break;		case kInitial_Owner_ID:			SetControlTextItemLong( aControl, i->owner);			break;					case kInitial_Location_X_ID:			SetControlTextItemLong( aControl, i->location.h);			break;		case kInitial_Location_Y_ID:			SetControlTextItemLong( aControl, i->location.v);			break;		case kInitial_Earn_ID:			SetControlTextItemSmallFixed( aControl, i->earning);			break;					case kInitial_Distance_ID:			SetControlTextItemLong( aControl, i->distanceRange);			break;		case kInitial_Rotation_ID:			SetControlTextItemLong( aControl, i->rotationMinimum);			break;		case kInitial_Rotation_Range_ID:			SetControlTextItemLong( aControl, i->rotationRange);			break;		case kInitial_Sprite_ID - 1:			if ( i->spriteIDOverride > 0) SetControlValue( aControl, 1);			else SetControlValue( aControl, 0);			break;					case kInitial_Sprite_ID://			SetControlTextItemLong( aControl, i->spriteIDOverride);			SetControlTextItemString( aControl, HNM_Resource_Name_Make(				d->heraFile, 'SMIV', i->spriteIDOverride, s));			break;		case kInitial_Build_Types_ID:			{				short	j = 0;				Str255	n, s;								s[0] = 0;				while (( j < kMaxTypeBaseCanBuild) && ( i->canBuild[j] >= 0))				{					if ( j > 0)						pstrcat(s, "\p, ");					NumToString( i->canBuild[j], n);					pstrcat( s, n);					j++;				}				SetControlTextItemString( aControl, s);								}			break;		case kInitial_Target_ID:			SetControlTextItemLong( aControl, i->initialDestination);			break;		case kInitial_Name_Res_ID - 1:			if ( i->nameResID > 0) SetControlValue( aControl, 1);			else SetControlValue( aControl, 0);			break;					case kInitial_Name_Res_ID://			SetControlTextItemLong( aControl, i->nameResID);			SetControlTextItemString( aControl,				HU_GetOneIndString( d->heraFile, i->nameResID,					i->nameStrNum, s));			break;		case kInitial_Name_Index_ID:			SetControlTextItemLong( aControl, i->nameStrNum);			break;	}	if ( draw) Draw1Control( aControl);}static void GetInitialField( Initial_EditorWindowType *d, huiPlainControlParamType *dummyParam,	scenarioInitialType *i, long id){	ControlHandle	aControl;#pragma unused( d)	if ( dummyParam == nil) return;	if ( i == nil) return;	if ( id < 0) return;		aControl = HUI_Control_Get( dummyParam->master, dummyParam->layer, dummyParam->cellx,		dummyParam->celly, id);	if ( aControl == nil) return;	switch( id)	{//		case kInitial_Attributes_Menu_ID://			HU_Menu_SetCheckFromBits( aControl, i->attributes, 0, 2);//			break;					case kInitial_Object_ID://			i->type = GetControlTextItemLong( aControl);			break;		case kInitial_Owner_ID:			i->owner = GetControlTextItemLong( aControl);			break;					case kInitial_Location_X_ID:			i->location.h = GetControlTextItemLong( aControl);			break;		case kInitial_Location_Y_ID:			i->location.v = GetControlTextItemLong( aControl);			break;		case kInitial_Earn_ID:			i->earning = GetControlTextItemSmallFixed( aControl);			break;					case kInitial_Distance_ID:			i->distanceRange = GetControlTextItemLong( aControl);			break;		case kInitial_Rotation_ID:			i->rotationMinimum = GetControlTextItemLong( aControl);			break;		case kInitial_Rotation_Range_ID:			i->rotationRange = GetControlTextItemLong( aControl);			break;		case kInitial_Sprite_ID://			i->spriteIDOverride = GetControlTextItemLong( aControl);			break;		case kInitial_Build_Types_ID:			{				short	charNum = 1, buildNum = 0;				Str255	n, s;				long	j;								GetControlTextItemString( aControl, s);				n[0] = 0;				i->canBuild[0] = -1;				while ( charNum <= s[0])				{					if ( s[charNum] != ',')					{						n[0]++;						n[n[0]] = s[charNum];					}					if (( s[charNum] == ',') || ( charNum == s[0]))					{						StringToNum( n, &j);						i->canBuild[buildNum] = j;						buildNum++;						if ( buildNum < kMaxTypeBaseCanBuild)							i->canBuild[buildNum] = -1;						n[0] = 0;					}					charNum++;				}				SetControlTextItemString( aControl, s);								}			break;		case kInitial_Target_ID:			i->initialDestination = GetControlTextItemLong( aControl);			break;		case kInitial_Name_Res_ID://			i->nameResID = GetControlTextItemLong( aControl);			break;		case kInitial_Name_Index_ID://			i->nameStrNum = GetControlTextItemLong( aControl);			break;	}}static void AddBitPopUp( huiPlainControlParamType *textParam,	huiPlainControlParamType *buttonParam, long id, short resID, short index,	Boolean newLine, short menuStrResID){	//  label	textParam->id = id-1;	GetIndString( textParam->label, resID, index); // which base type	textParam->whichTabSet = 0;	textParam->whichTab = 0;	textParam->flags = (newLine)?(huiControlFlag_newLine):(huiControlFlag_none);	textParam->minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( textParam);		buttonParam->id = id;	buttonParam->special.menuStrList.strList = GetStringList( menuStrResID);	buttonParam->special.menuStrList.menuID = HU_GetNewMenuID();//id;	buttonParam->special.menuStrList.cicnResID = 128;	buttonParam->special.menuStrList.multiSelect = true;	buttonParam->whichTabSet = 0;	buttonParam->whichTab = 1;	buttonParam->flags = huiControlFlag_none;	buttonParam->space.left = 8;		HUI_BevelButtonMenu_New_StrList( buttonParam);	buttonParam->whichTabSet = -1;	buttonParam->whichTab = -1;	if ( buttonParam->special.menuStrList.strList != nil)		ReleaseResource( buttonParam->special.menuStrList.strList);			// set attributes button	buttonParam->id = id + 2;	GetIndString( buttonParam->label, kHera_AppStrResID, 8); // setÉ	buttonParam->space.left = 8;	buttonParam->minMaxBounds.right = kHUI_Pixel_Max;	buttonParam->minMaxBounds.left = 0;	HUI_PushButton_New_LiteralP( buttonParam);}static void GetAllData( Initial_EditorWindowType *d){	short						oldResRefNum = 0;	ControlHandle				aControl;	ListHandle					list;//	OSErr						err;	long						initialNum = 0;		if ( d == nil) return;	oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);		if ( d->discreteData == nil)	{		d->discreteData = HD_Find_Discrete_Data( d->heraFile,			d->discreteDataID, -1, nil,			kHera_Initial_Type);		mAssert( d->discreteData != nil);	}	if (( d->discreteData != nil) && ( d->initialData == nil))	{		long	offset, size;				HD_DiscreteData_GetOffsetAndSize( d->discreteData, &offset, &size);		d->startInitialIndex = 0;		d->initialNumber = size / sizeof( scenarioInitialType);				if ( d->initialData != nil) DisposeHandle( d->initialData);		d->initialData = NewHandle( size);		mAssert( d->initialData != nil);		if ( d->initialData == nil) return;				BlockMove( *d->discreteData + offset, *d->initialData, size);	}		aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Cell		cell;				initialNum = GetHandleSize( d->initialData) / sizeof( scenarioInitialType);		if ( initialNum > 0)		{			if ( d->startInitialIndex >= initialNum) d->startInitialIndex = initialNum - 1;			if (( d->startInitialIndex + d->initialNumber) > initialNum)				d->initialNumber = (initialNum - d->startInitialIndex);		} else d->startInitialIndex = 0;		GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			short	i = d->startInitialIndex, count = d->initialNumber;			Str255	s;						LDelRow( 0, 0, list);	// delete all rows			(*list)->selFlags = lOnlyOne;						cell.h = 0;						while ( count > 0)			{//				GetIndString( s, 4201, i);				MakeInitialName(  d->heraFile, nil, d->initialData, i, nil, nil, s); 				if ( s[0] == 0) pstrcpy( s, "\puntitled");//				if ( s[0] != 0)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( (Ptr)(&s[1]), s[0], cell, list );				}				i ++;				count--;			}// while ( count > 0);		}	}	initialNum = GetHandleSize( d->initialData) / sizeof( scenarioInitialType);	if ( d->initialIndex >= initialNum) d->initialIndex = initialNum - 1;	d->initialIndex = HUI_Control_SetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, d->initialIndex);	Window_SetControls_FromInitialIndex( d,		GetWindowPtrFromDispatchWindowID( d->windowID), d->initialIndex + d->startInitialIndex);	GetAllData_error:		UseResFile( oldResRefNum);}static void SetInitialFlags( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Initial_EditorWindowType			*d;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Initial_EditorWindowType *)*data;		if ( d->chooseOnly)	{		HSetState( data, dataState);		return;	}	d->initial.attributes = bits;	HU_HUIMenu_SetCheckFromBits( d->master, 0, kInitial_Main_Cell_X, kInitial_Main_Cell_Y,		kInitial_Attributes_Menu_ID, bits, 0, 31);		HSetState( data, dataState);}static void OKConfirmCallBack( long whichButton, long windowID){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Initial_EditorWindowType		*d;	Boolean							same = true;	CWindowPtr						whichWindow =								GetWindowPtrFromDispatchWindowID( windowID);	if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Initial_EditorWindowType *)*data;		if ( whichButton == 1)	{		Window_SetInitial_FromControls( d,			whichWindow, d->initialIndex + d->startInitialIndex);		if ( d->modal)			gHera->modalMode--;//		HU_UseResFile( d->resRefNum, &resRefNum);//		Resource_Replace( 'snit', 500, d->initialData, "\pHera Initials");//		UpdateResFile( d->resRefNum);//		UseResFile( resRefNum);		if (( d->discreteData != nil) && ( d->initialData != nil))		{			if ( !d->chooseOnly)				HD_DiscreteData_Replace_Compare( d->discreteData, d->initialData,					kHera_Initial_Type, &same);						if ( !same) d->heraFile->changed = true;			DisposeHandle( d->initialData);		}		if ( d->callBack != nil) d->callBack( d->callerID, d->discreteDataID,												d->initialNumber,												d->initialIndex,												d->dataChanges);		HUI_MasterControl_Delete( d->master);		HD_DataChanges_DeleteAll( d->dataChanges);		CloseDispatchWindow( d->windowID); // d and data no longer valid	} else	{		HSetState( data, dataState);	}}static void CancelConfirmCallBack( long whichButton, long windowID){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	Initial_EditorWindowType		*d;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (Initial_EditorWindowType *)*data;	if ( whichButton == 1)	{		if ( d->modal)			gHera->modalMode--;		DisposeHandle( d->initialData);		HUI_MasterControl_Delete( d->master);		HD_DataChanges_DeleteAll( d->dataChanges);		CloseDispatchWindow( d->windowID); // d and data no longer valid	} else	{		HSetState( data, dataState);	}}static void Object_Choose_CallBack( long dispatchID, long objectChoiceID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	Initial_EditorWindowType			*d = nil;	huiPlainControlParamType		dummyParam;	SignedByte						dataState;	if ( objectChoiceID < 0) return;		if ( data == nil) return;			dataState = HGetState( data);	HLock( data);	d = (Initial_EditorWindowType *)*data;	d->initial.type = objectChoiceID;		dummyParam.master = d->master;	dummyParam.cellx = kMain_Cell_X;	dummyParam.celly = kMain_Cell_Y;	dummyParam.layer = 0;		SetInitialField( d, &dummyParam, &d->initial, kInitial_Object_ID, true);	HSetState( data, dataState);}static void Name_Choose_CallBack( long windowID, long resID, long stringNum){	Handle						windowData =									GetDispatchWindowDataHandle( windowID);	SignedByte					dataState;	Initial_EditorWindowType	*d;	huiPlainControlParamType	dummyParam;	if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);	d = (Initial_EditorWindowType *)*windowData;		d->initial.nameStrNum = stringNum;	d->initial.nameResID = resID;		dummyParam.master = d->master;	dummyParam.layer = 0;	dummyParam.cellx = kMain_Cell_X;	dummyParam.celly = kMain_Cell_Y;			SetInitialField( d, &dummyParam, &d->initial, kInitial_Name_Res_ID,						true);	SetInitialField( d, &dummyParam, &d->initial, kInitial_Name_Res_ID - 1,						true);							HSetState( windowData, dataState);}static void Sprite_Choose_CallBack( long windowID, long resID){	Handle						windowData =									GetDispatchWindowDataHandle( windowID);	SignedByte					dataState;	Initial_EditorWindowType	*d;	huiPlainControlParamType	dummyParam;	if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);	d = (Initial_EditorWindowType *)*windowData;		d->initial.spriteIDOverride  = resID;		dummyParam.master = d->master;	dummyParam.layer = 0;	dummyParam.cellx = kMain_Cell_X;	dummyParam.celly = kMain_Cell_Y;			SetInitialField( d, &dummyParam, &d->initial, kInitial_Sprite_ID,						true);	SetInitialField( d, &dummyParam, &d->initial, kInitial_Sprite_ID - 1,						true);							HSetState( windowData, dataState);}static void MiniMapTool_Set( Initial_EditorWindowType *d, long whichTool,	Boolean draw){	ControlHandle	aControl;			if ( d->miniMap_tool == whichTool) return;		if ( d->miniMap_tool >= 0)	{		aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X,			kMain_Cell_Y, d->miniMap_tool);				if ( aControl != nil)		{			SetControlValue( aControl, 0);			if ( draw) Draw1Control( aControl);		}	}		d->miniMap_tool = whichTool;	if ( d->miniMap_tool >= 0)	{		aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X,			kMain_Cell_Y, d->miniMap_tool);				if ( aControl != nil)		{			SetControlValue( aControl, 1);			if ( draw) Draw1Control( aControl);		}	}}static void InsertInitial( Initial_EditorWindowType *d, CWindowPtr whichWindow){	Ptr					data = nil;	long				dataLength, i;	ControlHandle		aControl;	Str255				s;	scenarioInitialType	*initial;		d->heraFile->changed = true;		Window_SetInitial_FromControls( d,		whichWindow, d->initialIndex + d->startInitialIndex);		if ( d->initialNumber > 0)	{		HUI_Control_GetListCell( 			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 0, d->initialIndex,			&data, &dataLength);				HU_Handle_InsertData( d->initialIndex, d->initialData,			(Ptr)&d->initial,			sizeof( scenarioInitialType), 0);		HUI_Control_InsertListRows(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 1, d->initialIndex);		if ( data != nil)		{			HUI_Control_SetListCell( 				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, 0, d->initialIndex,				data, dataLength);						DisposePtr( data);		}		d->initialNumber++;		// now we have to look at all initial objects' initial targets		// to see if they need to be changed				for ( i = 0; i < d->initialNumber; i++)		{			initial = (scenarioInitialType *)*d->initialData + i;						if ( initial->initialDestination > d->initialIndex)			{				initial->initialDestination++;			}		}//		Window_SetControls_FromInitialIndex(//			d, whichWindow, d->initialIndex + d->startInitialIndex);		d->dataChanges = HD_DataChanges_Add( d->dataChanges, d->initialIndex,			1, 1);		d->initialIndex++;		GetAllData( d); // this will correctly set list cells & selection	} else	{		d->initialNumber = 1;			d->initial.type = 0;		d->initial.owner = -1;		d->initial.location.h = d->initial.location.v = 0;		d->initial.earning = 0;		d->initial.distanceRange = 0;		d->initial.rotationMinimum = 0;		d->initial.rotationRange = 360;		d->initial.spriteIDOverride = -1;				for ( i = 0; i < kMaxTypeBaseCanBuild; i++)		{			d->initial.canBuild[i] = -1;		}		d->initial.initialDestination = -1;		d->initial.nameResID = -1;		d->initial.nameStrNum = -1;		d->initial.attributes = 0;		HU_Handle_InsertData( d->initialIndex, d->initialData, (Ptr)&d->initial,			sizeof( scenarioInitialType), 0);		MakeInitialName( d->heraFile, &d->initial, nil, 0, nil, nil, s);				d->initialIndex = 0;				HUI_Control_InsertListRows(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 1, d->initialIndex);				HUI_Control_SetListCell( 			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 0, d->initialIndex,			(Ptr)&s[1], s[0]);		Window_SetControls_FromInitialIndex(			d, whichWindow, d->initialIndex + d->startInitialIndex			);		MiniMap_Draw( whichWindow, d);		d->dataChanges = HD_DataChanges_Add( d->dataChanges, 9999,			1, 1);				Enable_Editing( d, true);	}	d->initialIndex = 		HUI_Control_GetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->initialIndex);	aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Draw1Control( aControl);	}	}static void DeleteInitial( Initial_EditorWindowType *d, CWindowPtr whichWindow){	ControlHandle	aControl;	long			i;	scenarioInitialType	*initial;		if ( d->initialNumber <= 0) return;		d->heraFile->changed = true;		HU_Handle_DeleteData( d->initialIndex, d->initialData,		sizeof( scenarioInitialType), 0);		HUI_Control_DeleteListRows(		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, 1, d->initialIndex);		for ( i = 0; i < (d->initialNumber-1); i++)	{		initial = (scenarioInitialType *)*d->initialData + i;				if ( initial->initialDestination > d->initialIndex)		{			initial->initialDestination--;		} else if (initial->initialDestination == d->initialIndex)		{			initial->initialDestination = -1;		}	}	d->dataChanges = HD_DataChanges_Add( d->dataChanges, d->initialIndex,		1, -1);	d->initialIndex = 		HUI_Control_SetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->initialIndex);	aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		ListHandle	list = nil;				GetListBoxListHandle( aControl, &list);		if ( list != nil)		{			LAutoScroll(list);		}		Draw1Control( aControl);	}		d->initialNumber--;	if ( d->initialNumber <= 0) Enable_Editing( d, false);	//	Window_SetControls_FromInitialIndex(//		d, whichWindow, d->initialIndex + d->startInitialIndex//		);	GetAllData( d);	MiniMap_Draw( whichWindow, d);}static void Enable_Editing( Initial_EditorWindowType *d, Boolean enable){	HUI_Cell_Set_Enabled( d->master, 0, kMain_Cell_X, kMain_Cell_Y, enable);}#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/OSErr Initial_Editor_NewWindow( heraScenarioFileType *heraFile,	StringPtr titlePrefix, short resRefNum,	long discreteDataID, long selection,	Boolean chooseOnly, Boolean modal, long callerID,	Initial_Editor_Callback_procPtr callBack){	Rect						bounds;	CWindowPtr					newWindow;	ControlHandle				rootControl, aControl;	huiPlainControlParamType	buttonParam, textParam, groupParam;	huiMasterControlParamType	masterParam;	OSStatus					err;	Handle						data, strList;	Initial_EditorWindowType		*d;	long						maxWidth = 0;	long						windowID = -1;	huiCellParamType			cellParam;	Str255						title;	#pragma unused ( err, textParam, aControl)			if ( discreteDataID < 0)	{		if ( chooseOnly)		{			BP_UserError_Literal("Initial Object Editor Error",				"Couldn't create Initial Object Editor window because "				"there are no initial objects for this scenario.");			return paramErr;			 		} else		{			Handle	newDiscreteData;						discreteDataID = HD_Get_NextID_From_Type( heraFile,				kHera_Initial_Type);			newDiscreteData = HD_Create_Discrete_Data( heraFile,				nil, 0, 0, discreteDataID,				kHera_Initial_Type);			if ( newDiscreteData != nil)				discreteDataID = ((heraDataHeaderType *)*newDiscreteData)->id;		}	}		// create the new window	data = NewHandle( sizeof( Initial_EditorWindowType));	if ( data == nil) return memFullErr;		HLock( data);	d = (Initial_EditorWindowType *)*data;	if ( heraFile->fileRefNum <= 0)		chooseOnly = true;			d->windowID = -1;	d->initialData = nil;	d->initialIndex = selection;	d->startInitialIndex = 0;	d->initialNumber = -1;	d->resRefNum = resRefNum;	d->setInitialFlags_WindowID = -1;	d->anyChanges = false;	d->chooseOnly = chooseOnly;	d->modal = modal;	d->discreteDataID = discreteDataID;	d->callerID = callerID;	d->callBack = callBack;	d->discreteData = nil;	d->miniMap_centerh = 0;	d->miniMap_centerv = 0;	d->miniMap_scale = .01;	d->miniMap_tool = -1;	d->showNames = false;	d->dataChanges = nil;	d->heraFile = heraFile;	if ( titlePrefix == nil)		d->titlePrefix[0] = 0;	else		pstrcpy( d->titlePrefix, titlePrefix);		if ( titlePrefix != nil)	{		pstrcpy( title, titlePrefix);		pstrcat( title, "\p: Initial Objects");	} else	{		pstrcpy( title, "\pInitial Objects");	}		SetRect( &bounds, 64, 64, 128, 128);	if ( modal)	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowMovableModalDialogProc, (WindowPtr)-1, false,			HandleEvent, 0,			&windowID);	} else	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowDocumentProc, (WindowPtr)-1, false,			HandleEvent, 0,			&windowID);		}	SetDispatchWindowDataHandle( windowID, data);	d->windowID = windowID;		SetThemeWindowBackground( (WindowPtr)newWindow,		kThemeActiveDialogBackgroundBrush, true);	SetPortWindowPort( (WindowPtr)newWindow);	CreateRootControl( (WindowPtr)newWindow, &rootControl);	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kRowNum;	masterParam.colNum = kColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->master = HUI_MasterControl_New( nil, 0, 0, 0, &masterParam);		mAssert( d->master != nil);	if ( d->master == nil) return memFullErr;	d->master->tab[0][0].h = kLarge_Tab_Width;	d->master->tab[0][0].hAlign = hui_halign_right;	d->master->tab[0][1].h = kLarge_Tab_Width;	d->master->tab[0][1].hAlign = hui_halign_left;		d->master->tab[0][2].h = (kLarge_Tab_Width * 2) + kEditTextFieldWidth;	d->master->tab[0][2].hAlign = hui_halign_right;	d->master->tab[0][3].h = (kLarge_Tab_Width * 2) + kEditTextFieldWidth;	d->master->tab[0][3].hAlign = hui_halign_left;		HUI_Master_ShowLayer( d->master, 0);		cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, 12, -1, 12);	cellParam.colSpan = 1;	cellParam.rowSpan = 2;	HUI_Cell_Set( 0, kMain_Cell_X, kMain_Cell_Y, &cellParam);	// set up list cell	SetRect( &cellParam.outSpace, 12, -1, -1, 5);	SetRect( &cellParam.inSpace, 3, -1, 3, 3);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_right;	cellParam.minMaxBounds.top = 100;	HUI_Cell_Set( 0, kList_Cell_X, kList_Cell_Y, &cellParam);	cellParam.minMaxBounds.top = 0;	cellParam.minMaxBounds.top = 0;		// set up list button cells	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.baseLine = gHera->smallFontSize;	cellParam.hAlign = hui_halign_center;	d->master->rowDontExpand[kList_Button_Cell_Y] = true;	HUI_Cell_Set( 0, kList_Button_Cell_X, kList_Button_Cell_Y, &cellParam);	cellParam.minMaxBounds.bottom = kHUI_Pixel_Max;	// set up initial group	groupParam.master = d->master;	groupParam.visible = true;	groupParam.enabled = true;	groupParam.whichTabSet = -1;	groupParam.whichTab = -1;	groupParam.layer = 0;	groupParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;	groupParam.fontStyle.font = gHera->smallFontNum;	groupParam.fontStyle.size = gHera->smallFontSize;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;	groupParam.helpStringResID = -1;	groupParam.id = kInitial_ID_Offset;	groupParam.cellx = kMain_Cell_X;	groupParam.celly = kMain_Cell_Y;	groupParam.special.group.isSecondary = false;	SetRect( &groupParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	GetIndString( groupParam.label, kStrResID, 15);	HUI_Group_New_LiteralP( &groupParam);	// set up buttons, general	buttonParam.master = d->master;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask | kControlUseJustMask;	buttonParam.fontStyle.font = gHera->smallFontNum;	buttonParam.fontStyle.size = gHera->smallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = teCenter;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;	buttonParam.flags = huiControlFlag_none;		// set up text, general		textParam.master = d->master;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = 8;	textParam.space.top = 12;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = -1;	textParam.cellx = kInitial_Main_Cell_X;	textParam.celly = kInitial_Main_Cell_Y;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;	// make selection list	buttonParam.id = kList_ID;	buttonParam.minMaxBounds.left = 240;	buttonParam.minMaxBounds.right = 240;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;//200;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.bottom = 200;	buttonParam.cellx = kList_Cell_X;	buttonParam.celly = kList_Cell_Y;	buttonParam.special.listBox.ldesResID = 128;	buttonParam.special.listBox.refCon = 0;	buttonParam.flags = huiControlFlag_useCellV;	HUI_ListBox_New_LiteralP( &buttonParam);		buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// set up list buttons		if ( d->chooseOnly)	{		buttonParam.enabled = false;		textParam.enabled = false;	}		buttonParam.id = kList_Remove_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 10); // remove	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.id = kList_Add_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 9); // add	HUI_PushButton_New_LiteralP( &buttonParam);		// flags		buttonParam.master = d->master;		buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.cellx = kMain_Cell_X;	buttonParam.celly = kMain_Cell_Y;		textParam.master = d->master;		textParam.layer = 0;	textParam.cellx = kMain_Cell_X;	textParam.celly = kMain_Cell_Y;		AddBitPopUp( &textParam, &buttonParam, kInitial_Attributes_Menu_ID,		kStrResID, 3,		false, 630);	if ( d->chooseOnly)		buttonParam.enabled = false;			// object	textParam.id = kInitial_Object_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 1);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kInitial_Object_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_StaticText_New_LiteralP( &textParam);	// select button	buttonParam.id = kInitial_ObjectSelect_Button;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, 8000, 13); // selectÉ	buttonParam.whichTabSet = buttonParam.whichTab = -1;	HUI_PushButton_New_LiteralP( &buttonParam);		// owner	textParam.id = kInitial_Owner_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 2);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kInitial_Owner_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);	// earn	textParam.id = kInitial_Earn_ID - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 6);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kInitial_Earn_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 3;	HUI_EditText_New_LiteralP( &textParam);	// location h	textParam.id = kInitial_Location_X_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 4);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kInitial_Location_X_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);	// location v	textParam.id = kInitial_Location_Y_ID - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 5);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kInitial_Location_Y_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 3;	HUI_EditText_New_LiteralP( &textParam);		// distance range	textParam.id = kInitial_Distance_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 7);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kInitial_Distance_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);	// initial target	textParam.id = kInitial_Target_ID - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 12);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kInitial_Target_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 3;	HUI_EditText_New_LiteralP( &textParam);	// rotation	textParam.id = kInitial_Rotation_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 8);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kInitial_Rotation_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);	// rotation range	textParam.id = kInitial_Rotation_Range_ID - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 9);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kInitial_Rotation_Range_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 3;	HUI_EditText_New_LiteralP( &textParam);	// sprite res id	textParam.id = kInitial_Sprite_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 10);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_CheckBox_New_LiteralP( &textParam);		textParam.id =  kInitial_Sprite_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_StaticText_New_LiteralP( &textParam);	// select button	buttonParam.id = kInitial_SpriteSelect_Button;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, 8000, 13); // selectÉ	buttonParam.whichTabSet = buttonParam.whichTab = -1;	HUI_PushButton_New_LiteralP( &buttonParam);		// build types	textParam.id = kInitial_Build_Types_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 11);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kInitial_Build_Types_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);	// name res id	textParam.id = kInitial_Name_Res_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 13);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_CheckBox_New_LiteralP( &textParam);		textParam.id = kInitial_Name_Res_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_StaticText_New_LiteralP( &textParam);	// select button	buttonParam.id = kInitial_NameSelect_Button;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, 8000, 13); // selectÉ	buttonParam.whichTabSet = buttonParam.whichTab = -1;	HUI_PushButton_New_LiteralP( &buttonParam);	/*	// name index	textParam.id = kInitial_Name_Index_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 14);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id =  kInitial_Name_Index_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);*/	// center button	buttonParam.enabled = true;	textParam.enabled = true;	buttonParam.space.left = 0;		buttonParam.id = kMiniMap_CenterButton_ID;	buttonParam.flags = huiControlFlag_newLine;	buttonParam.special.cicnBevelButton.cicnResID = 129;	buttonParam.special.cicnBevelButton.behavior = 0;	buttonParam.special.cicnBevelButton.bevelSize = kHUI_BevelButtonSize_Small;	buttonParam.label[0] = 0;	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 1;	HUI_BevelButton_New_LiteralP( &buttonParam);		// zoom in button	buttonParam.id = kMiniMap_ZoomInButton_ID;	buttonParam.flags = huiControlFlag_none;	buttonParam.special.cicnBevelButton.cicnResID = 130;	buttonParam.special.cicnBevelButton.behavior = 0;	buttonParam.special.cicnBevelButton.bevelSize = kHUI_BevelButtonSize_Small;	buttonParam.label[0] = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	HUI_BevelButton_New_LiteralP( &buttonParam);	// zoom out button	buttonParam.id = kMiniMap_ZoomOutButton_ID;	buttonParam.flags = huiControlFlag_none;	buttonParam.special.cicnBevelButton.cicnResID = 131;	buttonParam.special.cicnBevelButton.behavior = 0;	buttonParam.special.cicnBevelButton.bevelSize = kHUI_BevelButtonSize_Small;	buttonParam.label[0] = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	HUI_BevelButton_New_LiteralP( &buttonParam);	// position button	if ( d->chooseOnly)	{		buttonParam.enabled = false;	}	buttonParam.id = kMiniMap_PositionButton_ID;	buttonParam.flags = huiControlFlag_none;	buttonParam.special.cicnBevelButton.cicnResID = 132;	buttonParam.special.cicnBevelButton.behavior = 0;	buttonParam.special.cicnBevelButton.bevelSize = kHUI_BevelButtonSize_Small;	buttonParam.label[0] = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;		// last tool, so we need h space	buttonParam.space.left = 4;		HUI_BevelButton_New_LiteralP( &buttonParam);	buttonParam.enabled = true;	textParam.id = kMiniMap_ShowNames_ID;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 16); // show names	textParam.whichTab = textParam.whichTabSet = -1;	HUI_CheckBox_New_LiteralP( &textParam);		buttonParam.id = kMiniMap_ID;	buttonParam.flags = huiControlFlag_newLine;	buttonParam.minMaxBounds.right = kMiniMap_Width;	buttonParam.minMaxBounds.bottom = kMiniMap_Height;	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 1;	HUI_UserPane_New_LiteralP( &buttonParam);		strList = GetStringList( kHera_DefaultMainButtonStrResID);	if ( strList != nil)	{		HUI_Main_Buttons_H_Setup( d->master, 0,			kSeparator_Cell_X, kColNum, kSeparator_Cell_Y, 1,				true, strList);				ReleaseResource( strList);	}	MiniMapTool_Set( d, kMiniMap_CenterButton_ID, false);		HUI_Master_Layout( d->master, (Point){0, 0}, (Point){0, 0});	HUI_Master_HideAllLayers_Deep( d->master);	HUI_Master_ShowAllLayers_Deep( d->master);	ShowWindow( (WindowPtr)newWindow);	GetAllData( d);		HUnlock( data);		if ( d->modal)		gHera->modalMode++;		if ( d->initialNumber <= 0) Enable_Editing( d, false);		return noErr;}