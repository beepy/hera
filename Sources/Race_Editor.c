/******************************************\|**| Race_Editor.c\******************************************/#pragma mark ••INCLUDES••/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Window Dispatch.h"#include "Control Utilities.h"#include "Hewey.h"#include "Hewey_Main.h"#include "Hewey_Layout.h"#include "Hewey_Utilities.h"#include "str_bp.h"#include "Set Font By String.h"#include "BP_Error.h"#include "Assert.h"#include "strlist.h"#include "String Numerics.h"#include "BPMacOutput.h"#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/// ares#include "Scenario.h"// hera#include "Hera_Global.h"#include "Data_Selector.h"#include "Race_Editor.h"#include "Bit_Flipper.h"#include "Hera_Utilities.h"#include "Button_Window.h"#include "Hera_ResourceTracker.h"#pragma mark ••DEFINITIONS••/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kEditTextFieldWidth				120#define	kColNum							2#define	kRowNum							4#define	kRace_Row						0#define	kRaceIDOffset					100#define	kOK_Button_ID					1#define	kCancel_Button_ID				2#define	kRevert_Button_ID				3#define	kPrevious_Button_ID				4#define	kNext_Button_ID					5#define	kList_ID						6#define	kList_Cell_X					0#define	kList_Cell_Y					0#define	kList_Button_Cell_X				0#define	kList_Button_Cell_Y				1#define	kList_Button_ID_Offset			300#define	kList_Remove_Button_ID			(kList_Button_ID_Offset + 1)#define	kList_Add_Button_ID				(kList_Button_ID_Offset + 2)#define	kMain_Cell_X					1#define	kMain_Cell_Y					0#define	kMain_Cell_RowSpan				2#define	kMain_Cell_ColSpan				1#define	kSeparator_Cell_X				0#define	kSeparator_Cell_Y				2#define	kButton_Cell_X					0#define	kButton_Cell_Y					3#define	kSeparator_ID					200#define kRace_Group_ID					(kRaceIDOffset)#define	kRace_Adjective_ID				(kRaceIDOffset + 4)#define	kRace_Plural_ID					(kRaceIDOffset + 6)#define	kRace_Military_ID				(kRaceIDOffset + 8)#define	kRace_Planet_ID					(kRaceIDOffset + 10)#define	kRace_ID_ID						(kRaceIDOffset + 12)#define	kRace_Color_ID					(kRaceIDOffset + 14)#define	kRace_IllegalColors_ID			(kRaceIDOffset + 16)#define	kRace_Advantage_ID				(kRaceIDOffset + 18)#define	kRace_IllegalColors_Edit_ID		(kRaceIDOffset + 20)#define	kStrResID						8002#define	kRaceStringResID				4201#pragma mark _macros_/* - macros*******************************************/#pragma mark ••TYPEDEFS••/******************************************\|**| typedefs\******************************************/#pragma options align=mac68k/*typedef struct{	long					id;	unsigned char			apparentColor;	unsigned long			illegalColors;	smallFixedType			advantage;} raceType;*/#pragma options align=resettypedef struct raceWindowType{	heraScenarioFileType	*heraFile;	huiMasterControlType	*master;	Str255					single;	Str255					plural;	Str255					military;	Str255					homeWorld;	raceType				race;	long					whichRace;	long					illegalColorWindowID;	Handle					raceData;	Handle					raceIndStrings;	Boolean					anyChanges;	unsigned long			illegalColorBits;	short					resRefNum;	long					windowID;	Boolean					chooseOnly;	long					callerID;	RaceEditor_callBack_procPtr	callBack;} raceWindowType;#pragma mark ••EXTERNAL GLOBALS••/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark ••PRIVATE GLOBALS••/******************************************\|**| private globals\******************************************/#pragma mark ••PRIVATE PROTOTYPES••/******************************************\|**| private function prototypes\******************************************/static Boolean HandleEvent( EventRecord *, CWindowPtr, long, long);static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID);static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID);static void Window_SetControls_FromRaceIndex( raceWindowType *d, CWindowPtr window,	long index);static void Window_SaveData_FromRaceIndex( raceWindowType *d, CWindowPtr window,	long index);static void IllegalColorMenu_SetFromBits( raceWindowType *d, unsigned long bits,	long startBit, long endBit);static void SetIllegalColorBits( long windowID, unsigned long bits);static void OK_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID);static void Cancel_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID);static void OKButton( raceWindowType *d, CWindowPtr window);static void CancelButton( raceWindowType *d, CWindowPtr window);static void RevertButton( raceWindowType *d, CWindowPtr window);static void Revert_Window_Callback( long whichButton, long windowID);static void GetAllData( raceWindowType *d);static void Enable_Editing( raceWindowType *d, Boolean enable);void Race_Do_Delete( raceWindowType *d, CWindowPtr whichWindow,	unsigned short modifiers, Boolean confirm);#pragma mark ••PRIVATE FUNCTIONS••/******************************************\|**| private functions\******************************************/static Boolean HandleEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID, long command){	switch( command)	{		case kWD_Close_ForQuit_Command:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{//				Cancel_Button_From_WindowID( whichWindow, dispatchID);					OK_Button_From_WindowID( whichWindow, dispatchID);						}			return false;			break;				case kWDProcessEventCommand:			return( ProcessEvent( theEvent, whichWindow, dispatchID));			break;				case kWDSaveWindowCommand:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these races?",										"\pBefore saving, the Race Editor "										"must be closed. Click Cancel to "										"abort the save.", nil, nil))				{					OK_Button_From_WindowID( whichWindow, dispatchID);							} else				{					gHera->currentSave = nil;				}			}			return false;			break;				case kWDProcessMenuChoiceCommand:			return( ProcessMenuChoiceCommand( (unsigned long)theEvent,				whichWindow, dispatchID));			break;	}	return false;}static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	SignedByte						dataState;	raceWindowType			*d;	Boolean							result = false;	GrafPtr							oldPort;	short							menuID = ((menuData & 0xffff0000) >> 16),									menuItem = (menuData & 0x0000ffff);										if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (raceWindowType *)*data;	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);	result = Generic_ProcessMenuChoiceCommand( menuData, whichWindow,												dispatchID);	if ( result)	{		goto ProcessMenuChoiceCommand_Return;	}		switch( menuID)	{		case kEditMenuID:			switch( menuItem)			{				case kEdit_Undo_Item:					result = true;					break;				case kEdit_Add_Item:					result = true;					break;									case kEdit_Delete_Item:					result = true;					break;									case kEdit_Delete_All_Item:					result = true;					break;			}							break;		}	ProcessMenuChoiceCommand_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);}static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Boolean							result = false;	ControlHandle					aControl, oldControl;	short							whichPart, oldValue;	WindowPtr						scratchWindow;	Point							where;	char							whichChar;	GrafPtr							oldPort;	OSStatus						err;	raceWindowType					*d;		if ( data == nil) return false;	if ( theEvent == nil) return false;		dataState = HGetState( data);	HLock( data);	d = (raceWindowType *)*data;		if ( theEvent == nil) goto ProcessEvent_Return;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);		switch( theEvent->what)	{		case nullEvent:			IdleControls( (WindowPtr)whichWindow);						result = true;			break;					case updateEvt:				BeginUpdate ((WindowPtr)whichWindow);/*			SetPort( (WindowPtr)whichWindow);			CalcVis( (WindowPtr)whichWindow);			UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);*/			HU_GenericUpdateEventHandler( whichWindow);			EndUpdate ((WindowPtr)whichWindow);			result = true;			break;		case activateEvt:		{			Boolean	isActive = ((theEvent->modifiers & activeFlag) != 0);						if ( isActive)			{				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_scenarioFile_refNum);			}		}			// result != true so dispatch window will handle activation			// of controls etc.			break;					case mouseDown:			whichPart = FindWindow (theEvent->where, &scratchWindow);			switch( whichPart)			{				case inGrow:/*					{						Rect	growRect;						long	newSize;//						growRect = qd.screenBits.bounds;						C2C_ScreenBits_GetBounds( &growRect);						growRect.top = growRect.left = 120;						newSize = GrowWindow((WindowPtr)whichWindow,							theEvent->where ,&growRect);						if (newSize != 0)						{							SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,								(((newSize) >> 16) & 0xFFFF), true );							EraseRect(&whichWindow->portRect);							InvalRect( &whichWindow->portRect);						}					}*/					HU_GenericGrowWindow( whichWindow, theEvent->where);					result = true;					break;								case inContent:					where = theEvent->where;					scratchWindow = WD_FrontWindow();					if ( whichWindow != (CWindowPtr)scratchWindow)					{						goto ProcessEvent_Return;					}					SetPortWindowPort( (WindowPtr)whichWindow);					GlobalToLocal( &where);					whichPart = FindControl( where, (WindowPtr)whichWindow,						&aControl);					if ( aControl == nil)						goto ProcessEvent_Return;					oldValue = GetControlValue( aControl);					err = GetKeyboardFocus( (WindowPtr)whichWindow, &oldControl);					if (( err == noErr) && ( oldControl != aControl))					{						SetKeyboardFocus( (WindowPtr)whichWindow, aControl, whichPart);					}										if ( whichPart != 0)					{						huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);						Boolean				hackTest = false;												BPMOWritePString("\p\rid: ");						BPMOWriteLong( hui->generic.id);						BPMOWritePString("\p\tpart before: ");						BPMOWriteLong( whichPart);						//						whichPart = HandleControlClick ( aControl, where,//							theEvent->modifiers, nil);				/*						if ( hui != nil)						{							ListHandle	list;														err = GetListBoxListHandle( aControl, &list );							if (( err == noErr) && ( list != nil))							{								if ( PtInRect( where, &(*(*list)->vScroll)->contrlRect))								{									hackTest = true;									aControl = (*list)->vScroll;									whichPart = TrackControl( aControl, where,										nil//(ControlActionUPP)-1L										);									BPMOWritePString("\p\rcontrol value: ");									BPMOWriteLong( GetControlValue( aControl));									BPMOWritePString("\p\r");								}							}						}						*//*						if ( hui != nil)						{							ListHandle	list;														err = GetListBoxListHandle( aControl, &list );							if (( err == noErr) && ( list != nil))							{								hackTest = LClick( where, theEvent->modifiers,									list);							}						}						*/						if ( !ListBox_Appearance_1_0_1_Hack( aControl, where,									&whichPart))						{							whichPart = HUI_Control_Click_Handle( hui, where,								theEvent->modifiers);														}						BPMOWritePString("\p\tpart after: ");						BPMOWriteLong( whichPart);						BPMOWritePString("\p\r");												if ( whichPart != kControlNoPart) switch( hui->generic.id)						{							case kRace_IllegalColors_Edit_ID://								gHera->modalMode++;								BitFlipper_NewWindow( &d->illegalColorWindowID,									"\pIllegal Colors",									GetStringList( 590), //590									d->illegalColorBits, dispatchID,									SetIllegalColorBits);								result = true;																break;														case kList_ID:								oldValue = d->whichRace;																d->whichRace = HUI_Control_GetListValue(										d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, d->whichRace);								if ( d->whichRace != oldValue)								{																	Window_SaveData_FromRaceIndex( d,										whichWindow, oldValue);									Window_SetControls_FromRaceIndex(										d, whichWindow, d->whichRace);								}								result = true;								break;														case kRace_IllegalColors_ID:							{								unsigned long bit;																if ( whichPart == kControlMenuPart)								{									oldValue = GetBevelMenuValue( aControl) - 1;									bit = 0x01 << oldValue;									d->illegalColorBits ^= bit;									IllegalColorMenu_SetFromBits( d, d->illegalColorBits,										oldValue, oldValue);								}							}								result = true;								break;														case kList_Add_Button_ID:								{									raceType	r;									Str255		s1, s2, s3, s4;																		d->heraFile->changed = true;																		Window_SaveData_FromRaceIndex( d,										whichWindow, d->whichRace);																		BlockMoveData( *d->raceData + 										(sizeof( raceType) * d->whichRace),										&r, sizeof( raceType));																		HU_Handle_InsertData( d->whichRace,										d->raceData, (Ptr)&r, sizeof( raceType), 0);																		RetrieveIndString(										d->raceIndStrings,										(d->whichRace * 4) + 1, s1);									RetrieveIndString(										d->raceIndStrings,										(d->whichRace * 4) + 2, s2);									RetrieveIndString(										d->raceIndStrings,										(d->whichRace * 4) + 3, s3);									RetrieveIndString(										d->raceIndStrings,										(d->whichRace * 4) + 4, s4);									StringListInstall(										d->raceIndStrings, (d->whichRace * 4) + 1,										s1);									StringListInstall(										d->raceIndStrings, (d->whichRace * 4) + 2,										s2);									StringListInstall(										d->raceIndStrings, (d->whichRace * 4) + 3,										s3);									StringListInstall(										d->raceIndStrings, (d->whichRace * 4) + 4,										s4);																		HUI_Control_InsertListRows(										d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, 1, d->whichRace);									HUI_Control_SetListCell( 										d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, 0, d->whichRace,										(Ptr)&s1[1], s1[0]);																			d->whichRace = 										HUI_Control_GetListValue(											d->master, 0, kList_Cell_X, kList_Cell_Y,											kList_ID, d->whichRace);									aControl = HUI_Control_Get( 										d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID);									if ( aControl != nil)										Draw1Control( aControl);									}									result = true;								break;														case kList_Remove_Button_ID:								Race_Do_Delete( d, whichWindow, theEvent->modifiers,									true);									result = true;								break;														case kOK_Button_ID:								OKButton( d, whichWindow);								result = true;								CloseDispatchWindow( dispatchID);								break;														case kCancel_Button_ID:								CancelButton( d, whichWindow);								result = true;								break;														case kRevert_Button_ID:								RevertButton( d, whichWindow);								result = true;								break;															default:								break;						}					} else // not in control					{						where = theEvent->where;						GlobalToLocal( &where);					}			}			break;					case keyDown:		case autoKey:			whichChar = theEvent->message & charCodeMask;			if ((whichChar=='\r' || whichChar==0x3))			{				// ok				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kOK_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);					result = true;					OKButton( d, whichWindow);					CloseDispatchWindow( dispatchID);					goto ProcessEvent_Return;				}			} else if ((whichChar==0x1b) || ((whichChar=='.') && (theEvent->modifiers & cmdKey)))			{				// cancel				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kCancel_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);					//					CloseDispatchWindow( dispatchID);					result = true;					goto ProcessEvent_Return;				}			} else if ( whichChar == '\t')			{				if ( theEvent->modifiers & shiftKey)					ReverseKeyboardFocus( (WindowPtr)whichWindow);				else					AdvanceKeyboardFocus( (WindowPtr)whichWindow);				result = true;				break;			} else if (( whichChar == 0x08) && ( !d->chooseOnly))			{				huiPlainControlType	*hui = nil;				err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);				hui = (huiPlainControlType	*)CU_GetControlReference( aControl);				if ( hui != nil)				{					if ( hui->generic.id == kList_ID)					{						Race_Do_Delete( d, whichWindow, theEvent->modifiers,							true);					}				}			}						err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);			if (( err == noErr) && ( aControl != nil))			{				whichPart = HandleControlKey( aControl,					(theEvent->message & keyCodeMask)>>16,					theEvent->message & charCodeMask, theEvent->modifiers);				{					huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);					switch( hui->generic.id)					{													case kList_ID:							oldValue = d->whichRace;							d->whichRace = HUI_Control_GetListValue(									d->master, 0, kList_Cell_X, kList_Cell_Y,									kList_ID, d->whichRace);														if ( d->whichRace != oldValue)							{								Window_SaveData_FromRaceIndex( d,									whichWindow, oldValue);								Window_SetControls_FromRaceIndex(									d, whichWindow, d->whichRace									);							}							break;					}				}			}			break;	}		ProcessEvent_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);	}static void Window_SetControls_FromRaceIndex( raceWindowType *d, CWindowPtr window,	long index){	raceType				*racep, race;	Str255					s;	GrafPtr					oldPort;	ControlHandle			aControl;	SignedByte				raceDataState, stringDataState;		raceDataState = HGetState( d->raceData);	stringDataState = HGetState( d->raceIndStrings);	HLock( d->raceIndStrings);	HLock( d->raceData);	racep = ((raceType *)*d->raceData) + index;	BlockMoveData( racep, &race, sizeof( raceType));		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);	HUI_Control_SetTextItemLong( d->master, 0, kMain_Cell_X, kMain_Cell_Y,		kRace_ID_ID, race.id, true);	HUI_Control_SetTextItemSmallFixed( d->master, 0, kMain_Cell_X, kMain_Cell_Y,		kRace_Advantage_ID, race.advantage, true);	HUI_Control_SetTextItemString( d->master, 0, kMain_Cell_X, kMain_Cell_Y,		kRace_Adjective_ID, RetrieveIndString( d->raceIndStrings,			1 + (index * 4), s), true);	HUI_Control_SetTextItemString( d->master, 0, kMain_Cell_X, kMain_Cell_Y,		kRace_Plural_ID, RetrieveIndString( d->raceIndStrings,			2 + (index * 4), s), true);	HUI_Control_SetTextItemString( d->master, 0, kMain_Cell_X, kMain_Cell_Y,		kRace_Military_ID, RetrieveIndString( d->raceIndStrings,			3 + (index * 4), s), true);	HUI_Control_SetTextItemString( d->master, 0, kMain_Cell_X, kMain_Cell_Y,		kRace_Planet_ID, RetrieveIndString( d->raceIndStrings,			4 + (index * 4), s), true);	aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X, kMain_Cell_Y,		kRace_Color_ID);	if ( aControl != nil)	{		SetControlValue( aControl, race.apparentColor+1);	}	/*	HUI_Control_GetBevelMenu( d->master, 0, kMain_Cell_X, kMain_Cell_Y,		kRace_IllegalColors_ID, &aMenu);	if ( aMenu != nil)	{		long			bitNum;		unsigned long	bit = 1;					for ( bitNum = 0; bitNum < 16; bitNum++)			{				if ( race.illegalColors & bit)				{					SetItemMark( aMenu, bitNum + 1, '•');				} else				{					SetItemMark( aMenu, bitNum + 1, noMark);				}				bit <<= 1;			}	}*/	IllegalColorMenu_SetFromBits( d, race.illegalColors, 0, 15);	d->illegalColorBits = race.illegalColors;	//	UpdateControls( (WindowPtr)window, ((WindowPeek)window)->contRgn);	HSetState( d->raceData, raceDataState);	HSetState( d->raceIndStrings, stringDataState);	SetPort( oldPort);}static void Window_SaveData_FromRaceIndex( raceWindowType *d, CWindowPtr window,	long index){	raceType				*racep;	Str255					s;	SignedByte				raceDataState, stringDataState;	long					l;	short					h;	smallFixedType			f;#pragma unused( window)		if ( d->chooseOnly) return;		raceDataState = HGetState( d->raceData);	stringDataState = HGetState( d->raceIndStrings);	HUnlock( d->raceIndStrings);	HUnlock( d->raceData);		HUI_Control_GetTextItemString( d->master, 0, kMain_Cell_X, kMain_Cell_Y,			kRace_Adjective_ID, s);	if ( pstrcmp( s, StringListElt( d->raceIndStrings, (index * 4) + 1)))	{		ControlHandle	aControl;				d->heraFile->changed = true;		StringListRemove( d->raceIndStrings, (index * 4) + 1);		StringListInstall( d->raceIndStrings, (index * 4) + 1, s);		HUI_Control_SetListCell( d->master, 0, kList_Cell_X, kList_Cell_Y,									kList_ID, 0, index, (Ptr)&s[1], s[0]);		aControl = HUI_Control_Get( 			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID);		Draw1Control( aControl);	}	HUI_Control_GetTextItemString( d->master, 0, kMain_Cell_X, kMain_Cell_Y,			kRace_Plural_ID, s);	if ( pstrcmp( s, StringListElt( d->raceIndStrings, (index * 4) + 2)))	{		d->heraFile->changed = true;		StringListRemove( d->raceIndStrings, (index * 4) + 2);		StringListInstall( d->raceIndStrings, (index * 4) + 2, s);	}		HUI_Control_GetTextItemString( d->master, 0, kMain_Cell_X, kMain_Cell_Y,			kRace_Military_ID, s);	if ( pstrcmp( s, StringListElt( d->raceIndStrings, (index * 4) + 3)))	{		d->heraFile->changed = true;		StringListRemove( d->raceIndStrings, (index * 4) + 3);		StringListInstall( d->raceIndStrings, (index * 4) + 3, s);	}	HUI_Control_GetTextItemString( d->master, 0, kMain_Cell_X, kMain_Cell_Y,			kRace_Planet_ID, s);	if ( pstrcmp( s, StringListElt( d->raceIndStrings, (index * 4) + 4)))	{		d->heraFile->changed = true;		StringListRemove( d->raceIndStrings, (index * 4) + 4);		StringListInstall( d->raceIndStrings, (index * 4) + 4, s);	}	HLock( d->raceData);	racep = ((raceType *)*d->raceData) + index;	l = HUI_Control_GetTextItemLong( d->master, 0,		kMain_Cell_X, kMain_Cell_Y, kRace_ID_ID);	if ( racep->id != l)	{		d->heraFile->changed = true;		racep->id = l;	}	f = HUI_Control_GetTextItemSmallFixed( d->master, 0,		kMain_Cell_X, kMain_Cell_Y, kRace_Advantage_ID);	if ( racep->advantage != f)	{		d->heraFile->changed = true;		racep->advantage = f;	}		h = HUI_Control_GetValueShort( d->master, 0,		kMain_Cell_X, kMain_Cell_Y, kRace_Color_ID) - 1;	if ( racep->apparentColor != h)	{		d->heraFile->changed = true;		racep->apparentColor = h;	}	if ( racep->illegalColors != d->illegalColorBits)	{		d->heraFile->changed = true;		racep->illegalColors = d->illegalColorBits;	}		HSetState( d->raceData, raceDataState);	HSetState( d->raceIndStrings, stringDataState);}static void IllegalColorMenu_SetFromBits( raceWindowType *d, unsigned long bits,	long startBit, long endBit){/*	MenuHandle				aMenu;	HUI_Control_GetBevelMenu( d->master, 0, kMain_Cell_X, kMain_Cell_Y,		kRace_IllegalColors_ID, &aMenu);	if ( aMenu != nil)	{		long			bitNum;		unsigned long	bit = 1 << startBit;				for ( bitNum = startBit; bitNum <= endBit; bitNum++)		{			if ( bits & bit)			{				SetItemMark( aMenu, bitNum + 1, '•');			} else			{				SetItemMark( aMenu, bitNum + 1, noMark);			}			bit <<= 1;		}	}*/	HU_HUIMenu_SetCheckFromBits( d->master, 0, kMain_Cell_X, kMain_Cell_Y,		kRace_IllegalColors_ID, bits, startBit, endBit);}static void SetIllegalColorBits( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	raceWindowType					*d;	if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (raceWindowType *)*data;	d->illegalColorBits = bits;	IllegalColorMenu_SetFromBits( d, d->illegalColorBits, 0, 15);	HSetState( data, dataState);}static void OK_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	raceWindowType					*d;		if ( data == nil) return;		dataState = HGetState( data);	HLock( data);	d = (raceWindowType *)*data;	OKButton( d, whichWindow);	HSetState( data, dataState);	CloseDispatchWindow( dispatchID);}static void Cancel_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	raceWindowType					*d;		if ( data == nil) return;		dataState = HGetState( data);	HLock( data);	d = (raceWindowType *)*data;	CancelButton( d, whichWindow);	// d is deleted}static void OKButton( raceWindowType *d, CWindowPtr window){	short	oldResFile = CurResFile();		Window_SaveData_FromRaceIndex( d, window, d->whichRace);	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);//	UseResFile( d->resRefNum);//	Resource_Replace('race', 500, d->raceData, "\prace data");//	Resource_Replace('STR#', kRaceStringResID, d->raceIndStrings, "\prace strings");	if ( !d->chooseOnly)	{		HRT_KeepChangedResource( d->heraFile, d->raceData, 'race', 500, 500, "\prace data");		HRT_KeepChangedResource( d->heraFile, d->raceIndStrings, 'STR#', kRaceStringResID, kRaceStringResID,			"\prace strings");	}//	UpdateResFile( d->resRefNum);		if ( d->raceData != nil) DisposeHandle( d->raceData);	if ( d->raceIndStrings != nil) DisposeHandle( d->raceIndStrings);		if ( d->callBack != nil)	{		d->callBack( true, d->callerID);	}	HUI_MasterControl_Delete( d->master);		UseResFile( oldResFile);}static void CancelButton( raceWindowType *d, CWindowPtr window){	if ( d->raceData != nil) DisposeHandle( d->raceData);	if ( d->raceIndStrings != nil) DisposeHandle( d->raceIndStrings);	if ( d->callBack != nil)	{		d->callBack( true, d->callerID);	}	HUI_MasterControl_Delete( d->master);	CloseDispatchWindow( d->windowID);	#pragma unused( d, window)}static void RevertButton( raceWindowType *d, CWindowPtr window){#pragma unused( window)	Button_Window_NewWindow( "\pRevert Race", true, true,		-1, -1, Revert_Window_Callback, d->windowID);}static void Revert_Window_Callback( long whichButton, long windowID){	Handle							data = GetDispatchWindowDataHandle( windowID),									tempRaceData;	SignedByte						dataState;	raceWindowType					*d;	if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (raceWindowType *)*data;	if ( whichButton == 2)	{		short	oldRefNum = CurResFile();		Handle	originalStrings = nil;		//		HU_Handle_CopyDataFromResource( d->whichRace, 1, d->raceData, 'race', 500,//			d->resRefNum, sizeof( raceType));				tempRaceData = HRT_Resource_GetHandle( d->heraFile, 'race', 500, nil, nil);		if ( tempRaceData != nil)		{			HU_Data_CopyFromHandle( *d->raceData + ( sizeof( raceType) * d->whichRace),				tempRaceData, d->whichRace, sizeof( raceType));			DisposeHandle( tempRaceData);		}		//		UseResFile( d->resRefNum);	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);//		originalStrings = GetStringList( kRaceStringResID);		originalStrings = HRT_Resource_GetHandle( d->heraFile, 'STR#', kRaceStringResID, nil, nil);		if ( originalStrings != nil)		{			Str255	s;						StringListRemove( d->raceIndStrings, (d->whichRace * 4) + 1);			StringListInstall( d->raceIndStrings, (d->whichRace * 4) + 1,				StringListElt( originalStrings, (d->whichRace * 4) + 1));			RetrieveIndString( originalStrings, (d->whichRace * 4) + 1, s);						HUI_Control_SetListCell( 				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, 0, d->whichRace,				(Ptr)&s[1], s[0]);			StringListRemove( d->raceIndStrings, (d->whichRace * 4) + 2);			StringListInstall( d->raceIndStrings, (d->whichRace * 4) + 2,				StringListElt( originalStrings, (d->whichRace * 4) + 2));			StringListRemove( d->raceIndStrings, (d->whichRace * 4) + 3);			StringListInstall( d->raceIndStrings, (d->whichRace * 4) + 3,				StringListElt( originalStrings, (d->whichRace * 4) + 3));			StringListRemove( d->raceIndStrings, (d->whichRace * 4) + 4);			StringListInstall( d->raceIndStrings, (d->whichRace * 4) + 4,				StringListElt( originalStrings, (d->whichRace * 4) + 4));//			ReleaseResource( originalStrings);			DisposeHandle( originalStrings);		}		UseResFile( oldRefNum);		Window_SetControls_FromRaceIndex( d,			GetWindowPtrFromDispatchWindowID( windowID), d->whichRace);	} else if ( whichButton == 3)	{		DisposeHandle( d->raceData);		DisposeHandle( d->raceIndStrings);		GetAllData( d);	}	HSetState( data, dataState);}static void GetAllData( raceWindowType *d){	short						oldResRefNum = 0;	ControlHandle				aControl;	ListHandle					list;	long						raceNum = 0;		if ( d == nil) return;	oldResRefNum = CurResFile();//	UseResFile( d->resRefNum);	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);		if ( d->raceData != nil) DisposeHandle( d->raceData);		d->raceData = HRT_Resource_GetHandle( d->heraFile, 'race', 500, nil, nil);	if ( d->raceData == nil) d->raceData = NewHandle(0);	if ( d->raceData == nil)	{		goto GetAllData_error;	}	d->raceIndStrings = HRT_Resource_GetHandle( d->heraFile, 'STR#', kRaceStringResID,		nil, nil); //GetStringList( kRaceStringResID);	if ( d->raceIndStrings == nil) d->raceIndStrings = NewStringList();	if ( d->raceIndStrings == nil)	{		goto GetAllData_error;	}		aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Cell		cell;				raceNum = GetHandleSize( d->raceData) / sizeof( raceType);		GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			short	i = 1;			Str255	s;						LDelRow( 0, 0, list);	// delete all rows			(*list)->selFlags = lOnlyOne;						cell.h = 0;			do			{//				GetIndString( s, 4201, i);				RetrieveIndString( d->raceIndStrings, i, s);				if ( s[0] == 0) pstrcpy( s, "\puntitled");//				if ( s[0] != 0)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( (Ptr)(&s[1]), s[0], cell, list );				}				i += 4;				raceNum--;			} while ( raceNum > 0);		}	}	raceNum = GetHandleSize( d->raceData) / sizeof( raceType);	if ( d->whichRace >= raceNum) d->whichRace = raceNum - 1;	d->whichRace = HUI_Control_GetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, d->whichRace);	Window_SetControls_FromRaceIndex( d,		GetWindowPtrFromDispatchWindowID( d->windowID), d->whichRace);	GetAllData_error:		UseResFile( oldResRefNum);}static void Enable_Editing( raceWindowType *d, Boolean enable){	HUI_Cell_Set_Enabled( d->master, 0, kMain_Cell_X, kMain_Cell_Y, enable);}void Race_Do_Delete( raceWindowType *d, CWindowPtr whichWindow,	unsigned short modifiers, Boolean confirm){	ControlHandle	aControl;		if ((confirm) &&  (!( modifiers & cmdKey)))	{		if (!HU_Confirm_Delete("\pAre you sure you "				"want to delete this race?", modifiers))		{			return;		}	}	d->heraFile->changed = true;	StringListRemove( d->raceIndStrings, 4 + d->whichRace * 4);	StringListRemove( d->raceIndStrings, 3 + d->whichRace * 4);	StringListRemove( d->raceIndStrings, 2 + d->whichRace * 4);	StringListRemove( d->raceIndStrings, 1 + d->whichRace * 4);	HU_Handle_DeleteData( d->whichRace, d->raceData, 		sizeof( raceType), 0);	HUI_Control_DeleteListRows(		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, 1, d->whichRace);	{		long raceNum = ((GetHandleSize( d->raceData) /				sizeof( raceType)) - 1);		if ( d->whichRace > raceNum)		{			d->whichRace = raceNum;		}	}		d->whichRace = 		HUI_Control_GetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->whichRace);		aControl = HUI_Control_Get( 			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID);		Window_SetControls_FromRaceIndex(			d, whichWindow, d->whichRace);		if ( aControl != nil)		{			ListHandle	list = nil;						GetListBoxListHandle( aControl, &list);			if ( list != nil)			{				LAutoScroll(list);			}		}}#pragma mark ••PUBLIC FUNCTIONS••/******************************************\|**| public functions\******************************************/OSErr RaceEditor_NewWindow( heraScenarioFileType *heraFile,	long *windowID, short resRefNum, long callerID,	RaceEditor_callBack_procPtr callBack){	Rect						bounds;	CWindowPtr					newWindow = nil;	Str255						title;	ControlHandle				rootControl, aControl;	huiPlainControlParamType	buttonParam, textParam, groupParam;	huiCellParamType			cellParam;	huiMasterControlParamType	masterParam;	OSStatus					err;	Handle						data = nil;	raceWindowType				*d = nil;	huiPlainControlType			*hui;	short						oldResRefNum = 0;	#pragma unused ( err, textParam, aControl)		oldResRefNum = CurResFile();	// create the new window	*windowID = -1;	data = NewHandle( sizeof( raceWindowType));	if ( data == nil) return memFullErr;		HLock( data);	d = (raceWindowType *)*data;	d->master = nil;	d->raceData = nil;	d->raceIndStrings = nil;	d->whichRace = 0;		d->illegalColorWindowID = -1;	d->anyChanges = false;	d->illegalColorBits = 0;	d->resRefNum = resRefNum;	d->heraFile = heraFile;	d->callerID = callerID;	d->callBack = callBack;		if ( heraFile->fileRefNum > 0)		d->chooseOnly = false;	else		d->chooseOnly = true;//	UseResFile( resRefNum);	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);		d->raceData = HRT_Resource_GetHandle( d->heraFile, 'race', 500, nil, nil);	if ( d->raceData == nil) d->raceData = NewHandle(0);	if ( d->raceData == nil)	{		err = memFullErr;		goto RaceEditor_NewWindow_error;	}	d->raceIndStrings = HRT_Resource_GetHandle( d->heraFile, 'STR#', kRaceStringResID, nil, nil); //GetStringList( kRaceStringResID);	if ( d->raceIndStrings == nil) d->raceIndStrings = NewStringList();	if ( d->raceIndStrings == nil)	{		err = memFullErr;		goto RaceEditor_NewWindow_error;	}	GetIndString( title, kStrResID, 10);		SetRect( &bounds, 64, 64, 128, 128);	newWindow = NewDispatchWindow( &bounds, title, false,		kWindowDocumentProc, (WindowPtr)-1, false,		HandleEvent, 0,		windowID);	if ( newWindow == nil)	{		err = memFullErr;		goto RaceEditor_NewWindow_error;	}	SetDispatchWindowDataHandle( *windowID, data);	d->windowID = *windowID;		SetThemeWindowBackground( (WindowPtr)newWindow,		kThemeActiveDialogBackgroundBrush, true);	SetPortWindowPort( (WindowPtr)newWindow);	CreateRootControl( (WindowPtr)newWindow, &rootControl);	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kRowNum;	masterParam.colNum = kColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = gHera->smallFontSize;	d->master = HUI_MasterControl_New( nil, 0, 0, 0, &masterParam);		mAssert( d->master != nil);	if ( d->master == nil)	{		err = memFullErr;		goto RaceEditor_NewWindow_error;	}	d->master->tab[0][0].h = 112;	d->master->tab[0][0].hAlign = hui_halign_right;	d->master->tab[0][1].h = 112;	d->master->tab[0][1].hAlign = hui_halign_left;	// general cell set up	cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_left;	cellParam.vAlign = hui_valign_center;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	// separator	cellParam.minMaxBounds.right = kHUI_Pixel_Max;	cellParam.colSpan = 2;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_center;	SetRect( &cellParam.outSpace, 12, 2, 12, 2);	SetRect( &cellParam.inSpace, 0, 1, 0, 1);	HUI_Cell_Set( 0, kSeparator_Cell_X, kSeparator_Cell_Y, &cellParam);		// set up ok/cancel cell	cellParam.hAlign = hui_halign_right;	cellParam.baseLine = gHera->bigFontSize;	cellParam.colSpan = 2;	cellParam.rowSpan = 1;	SetRect( &cellParam.outSpace, 12, 0, 0, 0);	SetRect( &cellParam.inSpace, 0, 8, 12, 12);	HUI_Cell_Set( 0, kButton_Cell_X, kButton_Cell_Y, &cellParam);		// set up list cell	SetRect( &cellParam.outSpace, 0, -1, -1, 5);	SetRect( &cellParam.inSpace, 3, -1, 3, 3);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_right;	HUI_Cell_Set( 0, kList_Cell_X, kList_Cell_Y, &cellParam);	cellParam.minMaxBounds.top = 0;		// set up list button cells	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.baseLine = gHera->smallFontSize;	cellParam.hAlign = hui_halign_right;	d->master->rowDontExpand[kList_Button_Cell_Y] = true;	HUI_Cell_Set( 0, kList_Button_Cell_X, kList_Button_Cell_Y, &cellParam);	cellParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// set up main cell	cellParam.hAlign = hui_halign_center;	cellParam.baseLine = gHera->smallFontSize;	cellParam.colSpan = kMain_Cell_ColSpan;	cellParam.rowSpan = kMain_Cell_RowSpan;	SetRect( &cellParam.outSpace, -1, -1, 12, -1);	SetRect( &cellParam.inSpace, -1, 8, -1, 10);	HUI_Cell_Set( 0, kMain_Cell_X, kMain_Cell_Y, &cellParam);		// set up races data group		groupParam.master = d->master;	groupParam.visible = true;	groupParam.enabled = true;	groupParam.layer = 0;	groupParam.special.group.isSecondary = false;	groupParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;	groupParam.fontStyle.font = gHera->smallFontNum;	groupParam.fontStyle.size = gHera->smallFontSize;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;	groupParam.helpStringResID = -1;	groupParam.id = kRace_Group_ID;	groupParam.cellx = kMain_Cell_X;	groupParam.celly = kMain_Cell_Y;	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	GetIndString( groupParam.label, kStrResID, 9); // Races	HUI_Group_New_LiteralP( &groupParam);		// set up buttons, general	buttonParam.master = d->master;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	buttonParam.fontStyle.font = gHera->smallFontNum;	buttonParam.fontStyle.size = gHera->smallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = -1;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;		// make selection list	buttonParam.id = kList_ID;	buttonParam.minMaxBounds.left = 120;	buttonParam.minMaxBounds.right = 120;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;//200;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.bottom = 200;	buttonParam.cellx = kList_Cell_X;	buttonParam.celly = kList_Cell_Y;	buttonParam.special.listBox.ldesResID = 128;	buttonParam.special.listBox.refCon = 0;	buttonParam.flags = huiControlFlag_useCellV;	hui = HUI_ListBox_New_LiteralP( &buttonParam);	if ( hui != nil)	{		ListHandle	list;		Cell		cell;		long		raceNum = GetHandleSize( d->raceData) / sizeof( raceType);			err = GetListBoxListHandle( hui->generic.control, &list);		if (( list != nil) && ( err == noErr))		{			short	i = 1;			Str255	s;						(*list)->selFlags = lOnlyOne;						cell.h = 0;			do			{//				GetIndString( s, 4201, i);				RetrieveIndString( d->raceIndStrings, i, s);				if ( s[0] == 0) pstrcpy( s, "\puntitled");//				if ( s[0] != 0)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( (Ptr)(&s[1]), s[0], cell, list );				}				i += 4;				raceNum--;			} while ( raceNum > 0);		}		}		buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;		if ( d->chooseOnly) buttonParam.enabled = false;		// set up list buttons		buttonParam.id = kList_Remove_Button_ID;	buttonParam.cellx = kList_Button_Cell_X;	buttonParam.celly = kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kStrResID, 12);	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.id = kList_Add_Button_ID;	buttonParam.cellx = kList_Button_Cell_X;	buttonParam.celly = kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kStrResID, 13);	HUI_PushButton_New_LiteralP( &buttonParam);	// set up text, general		textParam.master = d->master;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = 8;	textParam.space.top = 10;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = -1;	textParam.cellx = kMain_Cell_X;	textParam.celly = kMain_Cell_Y;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;	if ( d->chooseOnly) textParam.enabled = false;		// adjective label	textParam.space.top = 12;	textParam.id = kRace_Adjective_ID -1;	GetIndString( textParam.label, kStrResID, 1); // adjective/singular	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_none;	HUI_StaticText_New_LiteralP( &textParam);		// adjective edit	textParam.id = kRace_Adjective_ID;	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	GetIndString( textParam.label, kStrResID, 1); // adjective/singular	HUI_EditText_New_LiteralP( &textParam);		// plural label	textParam.id = kRace_Plural_ID -1;	GetIndString( textParam.label, kStrResID, 2); // plural	textParam.minMaxBounds.left = 0;	textParam.flags = huiControlFlag_newLine;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		// plural edit	textParam.id = kRace_Plural_ID;	textParam.minMaxBounds.left = kEditTextFieldWidth;	GetIndString( textParam.label, kStrResID, 2); // plural	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		// military label	textParam.id = kRace_Military_ID -1;	GetIndString( textParam.label, kStrResID, 3); // military	textParam.minMaxBounds.left = 0;	textParam.flags = huiControlFlag_newLine;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		// military edit	textParam.id = kRace_Military_ID;	textParam.minMaxBounds.left = kEditTextFieldWidth;	GetIndString( textParam.label, kStrResID, 3); // military	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		// planet label	textParam.id = kRace_Planet_ID -1;	GetIndString( textParam.label, kStrResID, 4); // planet	textParam.minMaxBounds.left = 0;	textParam.flags = huiControlFlag_newLine;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);		// planet edit	textParam.id = kRace_Planet_ID;	textParam.minMaxBounds.left = kEditTextFieldWidth;	GetIndString( textParam.label, kStrResID, 4); // planet	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		// id label	textParam.id = kRace_ID_ID -1;	GetIndString( textParam.label, kStrResID, 5); // id	textParam.minMaxBounds.left = 0;	textParam.flags = huiControlFlag_newLine;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);	// id edit	textParam.id = kRace_ID_ID;	textParam.minMaxBounds.left = kEditTextFieldWidth;	GetIndString( textParam.label, kStrResID, 5); // id	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		// apparent color label	textParam.id = kRace_Color_ID -1;	GetIndString( textParam.label, kStrResID, 6); // apparent color	textParam.minMaxBounds.left = 0;	textParam.flags = huiControlFlag_newLine;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);			// apparent color menu	buttonParam.id = kRace_Color_ID;	buttonParam.cellx = kMain_Cell_X;	buttonParam.celly = kMain_Cell_Y;	buttonParam.special.menuStrList.strList = GetStringList( 590);	buttonParam.special.menuStrList.menuID = HU_GetNewMenuID();//129;	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 1;	buttonParam.flags = huiControlFlag_none;	buttonParam.space.left = 0;	GetIndString( buttonParam.label, kStrResID, 6); // apparent color	HUI_PopupButton_New_StrList( &buttonParam);	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;		// illegal color label	textParam.id = kRace_IllegalColors_ID -1;	GetIndString( textParam.label, kStrResID, 7); // apparent color	textParam.minMaxBounds.left = 0;	textParam.flags = huiControlFlag_newLine;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);			// illegal color menu	buttonParam.id = kRace_IllegalColors_ID;	buttonParam.cellx = kMain_Cell_X;	buttonParam.celly = kMain_Cell_Y;	buttonParam.special.menuStrList.strList = GetStringList( 590);	buttonParam.special.menuStrList.menuID = HU_GetNewMenuID();//130;	buttonParam.special.menuStrList.cicnResID = 128;	buttonParam.special.menuStrList.multiSelect = true;	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 1;	buttonParam.flags = huiControlFlag_none;	buttonParam.space.left = 8;	GetIndString( buttonParam.label, kStrResID, 7); // apparent color//	buttonParam.special.res.resID = 184;//208//	HUI_ResourceControl_New( &buttonParam);		HUI_BevelButtonMenu_New_StrList( &buttonParam);	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.id = kRace_IllegalColors_Edit_ID;	GetIndString( buttonParam.label, kStrResID, 11); // set…	buttonParam.space.left = 8;	HUI_PushButton_New_LiteralP( &buttonParam);		// advantage label	textParam.id = kRace_Advantage_ID -1;	GetIndString( textParam.label, kStrResID, 8); // id	textParam.minMaxBounds.left = 0;	textParam.flags = huiControlFlag_newLine;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	HUI_StaticText_New_LiteralP( &textParam);	// advantage edit	textParam.id = kRace_Advantage_ID;	textParam.minMaxBounds.left = kEditTextFieldWidth;	GetIndString( textParam.label, kStrResID, 8); // id	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		// set up separator	buttonParam.cellx = kSeparator_Cell_X;	buttonParam.celly = kSeparator_Cell_Y;	buttonParam.id = kSeparator_ID;	buttonParam.flags = huiControlFlag_useCellH;	buttonParam.minMaxBounds.bottom = 8;	buttonParam.space.top = 0;	buttonParam.space.left = 0;	HUI_SeparatorLine_New( &buttonParam);		// set up main buttons	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.minMaxBounds.left = 120;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.cellx = kButton_Cell_X;	buttonParam.celly = kButton_Cell_Y;	buttonParam.flags = huiControlFlag_none;	buttonParam.fontStyle.font = gHera->bigFontNum;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.size = gHera->bigFontSize;		buttonParam.enabled = true;		// cancel	buttonParam.id = kCancel_Button_ID;	buttonParam.space.left = 24;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 4); // cancel	HUI_PushButton_New_LiteralP( &buttonParam);		// revert	buttonParam.id = kRevert_Button_ID;	buttonParam.space.left = 24;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 5); // revert	HUI_PushButton_New_LiteralP( &buttonParam);		// ok	buttonParam.flags = (huiControlFlagType)((int)huiControlFlag_isDefault | (int)huiControlFlag_none);	buttonParam.id = kOK_Button_ID;	buttonParam.space.left = 0;	GetIndString( buttonParam.label, kHera_AppStrResID, 3); // ok	HUI_PushButton_New_LiteralP( &buttonParam);		ShowWindow( (WindowPtr)newWindow);	HUI_Master_Layout( d->master, (Point){0, 0}, (Point){0, 0});	HUI_Master_ShowLayer( d->master, 0);	HUI_Control_GetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, d->whichRace);	Window_SetControls_FromRaceIndex( d, newWindow, d->whichRace);		HUnlock( data);	UseResFile( oldResRefNum);	return noErr;RaceEditor_NewWindow_error:	UseResFile( oldResRefNum);	if ( d != nil)	{		if ( d->raceData != nil)			DisposeHandle( d->raceData);		if ( d->raceIndStrings != nil)			DisposeHandle( d->raceIndStrings);		if ( d->master != nil)			HUI_MasterControl_Delete( d->master);				HUnlock( data);		DisposeHandle( data);	}	if ( newWindow != nil) DisposeWindow( (WindowPtr)newWindow);	return err;}