/******************************************\|**| Make_Finder_Open.c\******************************************/#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#ifndef __AEREGISTRY__#include <AERegistry.h>#endif#ifndef __APPLEEVENTS__#	include <AppleEvents.h>#endif#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#pragma mark _this library includes_/* - this project*******************************************/#include "Make_Finder_Open.h"#include "AppleEvent_Utilities.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#pragma mark _macros_/* - macros*******************************************/#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/#pragma mark 본EXTERNAL GLOBALS본/******************************************\|**| external globals\******************************************/extern ProcessSerialNumber	*gFinderProcess;#pragma mark 본PRIVATE GLOBALS본/******************************************\|**| private globals\******************************************/#pragma mark 본PRIVATE PROTOTYPES본/******************************************\|**| private function prototypes\******************************************/static pascal OSErr MFE_AddParentAlias( AppleEvent *, AliasRecord **);static pascal OSErr MFE_AddChildAlias( AEDescList *,  AliasRecord **);static pascal OSErr MFE_SendSingleSelectionEvent( AliasRecord **, AEEventID);#pragma mark 본PRIVATE FUNCTIONS본/******************************************\|**| private functions\******************************************/static pascal OSErr MFE_AddParentAlias(AppleEvent *finderEvent,	AliasRecord **aliasH){	//	//	The goal here is to add a parent alias to 'finderEvent' as the direct	//	object as specified by the Apple Event Registry. If 'aliasH' is not a	//	volume, we add an alias of the parent of 'aliasH'. If 'aliasH' is a	//	volume, we want to add 'aliasH' itself as the container because lots	//	of events expect that bizarre behavior. We make a new alias to it	//	because we have no way of telling whether the incoming alias is a full	//	alias or not, and Finder demands one (and it tends to throw nasty	//	tantrums if it's not).	//	OSErr		err = noErr;	FSSpecPtr	fssP = (FSSpecPtr)(NewPtr (sizeof (FSSpec)));	if (!(err = MemError ( )))	{		if (!(err = HandToHand ((Handle *) &aliasH)))		{			Boolean wasChanged;			if (!(err = ResolveAlias (nil, (AliasHandle)(aliasH), fssP,				&wasChanged))) // aliasH is a copy			{				if (fssP->parID == fsRtParID ||					!(err = FSMakeFSSpec (fssP->vRefNum, fssP->parID, nil, fssP)))				{					AliasHandle parentAlias;					if (!(err = NewAlias (nil,fssP,&parentAlias)))					{						HLock ((Handle)parentAlias);						if (!(err = MemError ( )))						{							Size parentAliasSize =								GetHandleSize ((Handle)parentAlias);							if (!(err = MemError ( )))								err = AEPutParamPtr (finderEvent, keyDirectObject,									typeAlias, *parentAlias, parentAliasSize);						}						DisposeHandle ((Handle)parentAlias);					}				}			}			DisposeHandle ((Handle)aliasH);			if (!err) err = MemError ( );		}		DisposePtr ((Ptr)fssP);		if (!err) err = MemError ( );	}	return err;}static pascal OSErr MFE_AddChildAlias	(AEDescList *selection,  AliasRecord **aliasH){	OSErr err = noErr;	SInt8 hState = HGetState ((Handle)aliasH);	if (!(err = MemError ( )))	{		HLock ((Handle)aliasH);		if (!(err = MemError ( )))		{			Size aliasSize = GetHandleSize ((Handle)aliasH);			if (!(err = MemError ( )))			{				err = AEPutPtr (selection,0,typeAlias,*aliasH,aliasSize);			}			HSetState ((Handle)aliasH, hState);		}	}	return err;}static pascal OSErr MFE_SendSingleSelectionEvent	(AliasRecord **aliasH, AEEventID eventID){	OSErr err = noErr;	AppleEvent			event, reply;	OSErr				error;	AEDesc				target;	DescType			returnedType;	long				errNumber, actualSize, *replyData = nil, *connectionStatus;	Boolean				result = false;	AEIdleUPP			idleFunction = nil;	Str255				replyString;	long				hack1, hack2, hack3, hack4;	AEKeyword			hackKeyWord;		if ( gFinderProcess == nil) GetFinderSerialNumber();	if ( gFinderProcess == nil) return -1;		AECreate( &reply);	error = AECreateDesc( typeProcessSerialNumber, gFinderProcess,		sizeof( ProcessSerialNumber), &target);	if ( error == noErr)	{		error = AECreateAppleEvent( kAEFinderEvents, kAEOpenSelection, &target,			kAutoGenerateReturnID, kAnyTransactionID, &event);		AEDestroy( &target);		if ( error == noErr)		{			error = MFE_AddParentAlias ( &event,aliasH);			if ( error == noErr)			{				AEDescList selection = { typeNull, nil };				error =  AECreateList (nil,0,false,&selection);				if ( error == noErr)				{					error = MFE_AddChildAlias ( &selection,aliasH);					if ( error == noErr)					{						error = AEPutParamDesc (&event,keySelection,							&selection);/*			idleFunction = NewAEIdleProc( (ProcPtr)IdleHandle);			error = AESend( &event, &reply, kAEWaitReply + kAEAlwaysInteract,				kAENormalPriority, 0xffffffff, idleFunction, nil);*/						if ( error == noErr)						{							error = AESend ( &event, &reply, kAENoReply | kAEAlwaysInteract | kAECanSwitchLayer,kAENormalPriority,-1,nil,nil);//finderEvent.Send ( );						}						AEDisposeDesc (&selection);					}				}			}		}	}		AEDestroy( &event);		AEDestroy( &reply);	return err;}#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/OSErr Make_Finder_Open_Anything( FSSpec *spec){	OSErr		error = noErr;	AliasHandle	aliasH = nil;		error = NewAliasMinimal( spec, &aliasH);	if ( error == noErr)	{		error = MFE_SendSingleSelectionEvent( (AliasRecord **)aliasH, (unsigned long)kAEOpenSelection);		DisposeHandle( (Handle)aliasH);		if ( !error) error = MemError();	}		return error;}