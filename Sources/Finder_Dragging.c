/******************************************\|**| Finder_Dragging.c\******************************************/#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/#include "Finder_Dragging.h"#include "Technote.h"#include "Make_Finder_Open.h"#include "IconSuiteFromAlias.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#pragma mark _macros_/* - macros*******************************************/#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/#pragma mark 본EXTERNAL GLOBALS본/******************************************\|**| external globals\******************************************/#pragma mark 본PRIVATE GLOBALS본/******************************************\|**| private globals\******************************************/static ItemReference	gItemRef;				// valid when gApprovedDragRef is being receivedstatic DragReference	gApprovedDragRef;		// tracking handler approves, receive handler confirmsHFSFlavor		gHFSFlavor;				// data dragged in, re-used when dragging outstatic FSSpec			gDropLocation;			// cache where user dropped ???Handle			gIconSuite;				// cached from flavorTypeHFS dragged inBoolean			gDragProcessed = true;#pragma mark 본PRIVATE PROTOTYPES본/******************************************\|**| private function prototypes\******************************************/static pascal OSErr ShowDragHiliteWindow (DragReference dragRef, WindowRef wRef);static pascal OSErr WakeUpCurrentProcess (void);#pragma mark 본PRIVATE FUNCTIONS본/******************************************\|**| private functions\******************************************/static pascal OSErr WakeUpCurrentProcess (void){	ProcessSerialNumber curPSN = { 0, kCurrentProcess };	return WakeUpProcess (&curPSN); // "post" a null event}static pascal OSErr ShowDragHiliteWindow (DragReference dragRef, WindowRef wRef){	OSErr err = noErr;	RgnHandle hiliteRgn = NewRgn ( );	if (!hiliteRgn)		err = nilHandleErr;	else	{		Rect	windowBounds;						RectRgn (hiliteRgn, C2C_Window_GetPortBounds( wRef, &windowBounds));		err = ShowDragHilite (dragRef,hiliteRgn,true);		DisposeRgn (hiliteRgn);	}	return err;}#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/pascal OSErr ApproveDragReference (DragReference theDragRef, Boolean *approved){	//	//	We accept one item and one item only.	//	It must have either 'flavorTypeHFS' or 'flavorTypePromiseHFS'.	//	If the user held the option key down when beginning the drag	//	or is holding the option key down when the drag enters, we	//	accept only 'flavorTypePromiseHFS'.	//	//	Note that if a flavor can't be found, it's not really an	//	error; it only means the flavor wasn't there and we should	//	not accept the drag. Therefore, we translate 'badDragFlavorErr'	//	into a 'false' value for '*approved'.	//	OSErr err = noErr;	UInt16			itemCount;	DragAttributes	dragAttrs;	short			currentModifers,					mouseDownModifiers;	*approved = false;	if (!(err = GetDragAttributes (theDragRef,&dragAttrs)))	if (!(dragAttrs & kDragInsideSenderWindow))	if (!(err = CountDragItems (theDragRef,&itemCount)) && itemCount == 1)	if (!(err = GetDragItemReferenceNumber (theDragRef,1,&gItemRef)))	if (!(err = GetDragModifiers (theDragRef,&currentModifers,&mouseDownModifiers,nil)))	{		if ((currentModifers & optionKey) || (mouseDownModifiers & optionKey))			err = badDragFlavorErr; // pretend to have searched and not found		else		{			FlavorFlags flavorFlags;			err = GetFlavorFlags (theDragRef,gItemRef,flavorTypeHFS,&flavorFlags);		}		if (!err)			*approved = true;		else if (err == badDragFlavorErr)		{			PromiseHFSFlavor	promiseHFSFlavor;			Size				dataSize;			dataSize = sizeof (promiseHFSFlavor);			err = GetFlavorData (theDragRef,gItemRef,flavorTypePromiseHFS,&promiseHFSFlavor,&dataSize,0);			if (err == badDragFlavorErr)				err = noErr; // *approved = false;			else if (!err)			{				if (dataSize != sizeof (promiseHFSFlavor))					err = cantGetFlavorErr;				else					*approved = true;			}		}	}	return err;}pascal OSErr MyDragTrackingHandler	(DragTrackingMessage message, WindowPtr theWindow, void *, DragReference theDragRef){	Boolean approved;	switch (message)	{		case kDragTrackingEnterWindow	:			if (!ApproveDragReference (theDragRef,&approved) && approved)			if (!ShowDragHiliteWindow (theDragRef,theWindow))				gApprovedDragRef = theDragRef;			break;		case kDragTrackingInWindow		:			// do nothing			break;		case kDragTrackingLeaveWindow	:			(void) HideDragHilite (theDragRef);			// fall thru		default :			gApprovedDragRef = nil;			break;	}	return noErr; // there's no point in confusing Drag Manager or its caller}pascal OSErr MyDragReceiveHandler (WindowPtr w, void *, DragReference theDragRef){	//	//	Receive a drag.	//	//	First attempt to grab flavorTypePromiseHFS data	//	without specifying a drop location to induce Find File to	//	reveal its secrets. If we're not dealing	//	with Find File, make sure there's a folder to receive	//	the new file and and receive the file there.	//	//	Once the file's been received, we need a null event sent	//	to our event loop because that's when we check to see if	//	gHFSFlavor has changed. Since Drag Manager callbacks run	//	outside the event loop, we might otherwise only receive	//	a null event after quite a long time, especially if we	//	specify a long sleep time when calling WaitNextEvent.	//	(See RebuildIcon and its caller.)	//	OSErr err = dragNotAcceptedErr;	if (theDragRef == gApprovedDragRef)	{		err = GetHFSFlavorFromDragReference (gApprovedDragRef,gItemRef,&gHFSFlavor);		if (err == badDragFlavorErr)		{			err = ReceivePromisedFile (gApprovedDragRef,gItemRef,&gHFSFlavor,nil);			if (err == paramErr) // it's not from Find File			{				if (*(gDropLocation.name))					err = noErr;				else				{					// real programs don't use string constants					err = FSMakeFSSpec (0,0,"\pDropSpool",&gDropLocation);					if (err == fnfErr)					{						long createdDirID;						// specify smRoman because of the string constant						err = FSpDirCreate (&gDropLocation,smRoman,&createdDirID);					}				}				if (!err)					err = ReceivePromisedFile						(gApprovedDragRef,gItemRef,&gHFSFlavor,&gDropLocation);			}		}		if (!err)		{			if (!(err = WakeUpCurrentProcess ( )))			{				if (gIconSuite)				{					DisposeIconSuite (gIconSuite,true);					gIconSuite = nil;				}			}//			Make_Finder_Open_Anything( &gHFSFlavor.fileSpec);			{				GrafPtr	oldPort;								GetPort( &oldPort);				SetPortWindowPort( w);//				DrawFSpecSmallIcon( &gHFSFlavor.fileSpec, 0, 0);//				GetIconSuiteFromFSSpec( &gHFSFlavor.fileSpec, &gIconSuite);				gDragProcessed = false;				SetPort( oldPort);			}		}	}	return err;}pascal OSErr SetWindowForDragging (WindowRef wRef){	OSErr err = noErr;	DragReceiveHandlerUPP	dragReceiveHandlerUPP	= nil;	DragTrackingHandlerUPP	dragTrackingHandlerUPP	= nil;//	Rect					boundsRect;//	unsigned short			top;	{		dragTrackingHandlerUPP = NewDragTrackingHandlerUPP (MyDragTrackingHandler);		if (!dragTrackingHandlerUPP)			err = nilHandleErr;		else		{			dragReceiveHandlerUPP = NewDragReceiveHandlerUPP (MyDragReceiveHandler);			if (!dragReceiveHandlerUPP)				err = nilHandleErr;			else if (!(err = InstallTrackingHandler (dragTrackingHandlerUPP,wRef,nil)))			{				err = InstallReceiveHandler (dragReceiveHandlerUPP,wRef,nil);				if (err)					RemoveTrackingHandler (dragTrackingHandlerUPP,wRef);				else				{//					GrafPtr savedPort = qd.thePort;//					SetPort (wRef);//					TextSize (9);//					GetFontInfo (&gFontInfo);//					gIconLimitRect = qd.thePort->portRect;//					gIconLimitRect.bottom -= 3 * (gFontInfo.ascent + gFontInfo.leading + gFontInfo.descent);//					SetPort (savedPort);				}			}		}	}	if (err)	{		if (dragTrackingHandlerUPP)		{#ifndef TARGET_API_MAC_CARBON			DisposeRoutineDescriptor (dragTrackingHandlerUPP);#else			DisposeDragTrackingHandlerUPP( dragTrackingHandlerUPP);#endif TARGET_API_MAC_CARBON		}		if (dragReceiveHandlerUPP)		{#ifndef TARGET_API_MAC_CARBON			DisposeRoutineDescriptor (dragReceiveHandlerUPP);#else			DisposeDragReceiveHandlerUPP( dragReceiveHandlerUPP);#endif TARGET_API_MAC_CARBON		}	}	return err;}