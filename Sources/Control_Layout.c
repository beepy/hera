/******************************************\|**| Control_Layout.c\******************************************/#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "BP_Error.h"#pragma mark _this library includes_/* - this project*******************************************/#include "Control_Layout.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#pragma mark _macros_/* - macros*******************************************/#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/#pragma mark 본EXTERNAL GLOBALS본/******************************************\|**| external globals\******************************************/#pragma mark 본PRIVATE GLOBALS본/******************************************\|**| private globals\******************************************/#pragma mark 본PRIVATE PROTOTYPES본/******************************************\|**| private function prototypes\******************************************/void NewLayout( controlLayoutType **layout);#pragma mark 본PRIVATE FUNCTIONS본/******************************************\|**| private functions\******************************************/#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/controlLayoutType *CL_Layout_New( CWindowPtr window){	long				r, c, i;	controlLayoutType	*layout = nil;		layout = (controlLayoutType *)NewPtr( sizeof( controlLayoutType));		if ( layout == nil)	{		BP_UserError_Literal("Memory Error", "Couldn't create new layout");		return;	}		layout->colNum = 0;	layout->rowNum = 0;	layout->currentH = 0;	layout->currentV = 0;	layout->window = window;	layout->bounds.left = layout->bounds.top = 0;	layout->bounds.right = layout->bounds.bottom = -1;		for ( r = 0; r < kCL_MaxRow; r++)	{		for ( c = 0; c < kCL_MaxCol; c++)		{			layout->cell[c][r].hAlign = cl_halign_left;			layout->cell[c][r].vAlign = cl_valign_top;			layout->cell[c][r].controlLayout = nil;			layout->cell[c][r].bounds.left = layout->cell[c][r].bounds.top = 0;			layout->cell[c][r].bounds.right = layout->cell[c][r].bounds.bottom = -1;			layout->cell[c][r].controlNum = 0;			for ( i = 0; i < kCL_MaxCellControl; i++)			{				layout->cell[c][r].control[i].id = -1;				layout->cell[c][r].control[i].whichTab = -1;			}						for ( i = 0; i < kCL_MaxCellTab; i++)			{				layout->cell[c][r].tab[i].align = cl_halign_center;				layout->cell[c][r].tab[i].x = -1;			}		}	} 	return layout;}void CL_Layout_Delete( controlLayoutType *layout){	long	r, c;		for ( r = 0; r < kCL_MaxRow; r++)	{		for ( c = 0; c < kCL_MaxCol; c++)		{			if ( layout->cell[c][r].controlLayout != nil)			{				CL_Layout_Delete( layout->cell[c][r].controlLayout);				DisposePtr( (Ptr)layout->cell[c][r].controlLayout);			}		}	}}void CL_SetCellControl( controlLayoutType *layout, long id, long whichTab){	layout->cell[layout->currentH][layout->currentV].control.id = id;	layout->cell[layout->currentH][layout->currentV].control.whichTab = whichTab;}