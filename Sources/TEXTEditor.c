/******************************************\|**| TEXTEditor.c\******************************************/#pragma mark ¥¥INCLUDES¥¥/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Window Dispatch.h"#include "Control Utilities.h"#include "Hewey.h"#include "Hewey_Main.h"#include "Hewey_Layout.h"#include "Hewey_Utilities.h"#include "str_bp.h"#include "Set Font By String.h"#include "BP_Error.h"#include "strlist.h"#include "Hewey_Helpers.h"#include "Hewey_ScrollText.h"#include "Assert.h"#include "BPMacOutput.h"	// hack for bughunt#include "Hera_Global.h"#include "Hera_Utilities.h"#include "Hera_ResourceTracker.h"#include "PsuedoColumn_Utilities.h"#include "List_Utilities.h"#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/#include "TEXTEditor.h"#include "Hera_Utilities.h"#include "Button_Window.h"#pragma mark ¥¥DEFINITIONS¥¥/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kLarge_Tab_Width				80//112#define	kEditTextBigFieldWidth			150#define	kEditTextFieldWidth				38#define	kEditTextSmallFieldWidth		16#define	kPopup_Field_Width				150#define	kControl_H_Space				8#define	kColNum							2#define	kRowNum							4#define	kMain_Cell_X					1#define	kMain_Cell_Y					0#define	kMain_ID_Offset					100#define	kList_ID						6#define	kList_Cell_X					0#define	kList_Cell_Y					0#define	kList_Button_Cell_X				0#define	kList_Button_Cell_Y				1#define	kList_Button_ID_Offset			300#define	kList_Remove_Button_ID			(kList_Button_ID_Offset + 2)#define	kList_Add_Button_ID				(kList_Button_ID_Offset + 4)#define	kList_SortBy_Menu_ID			(kList_Button_ID_Offset + 6)#define	kSeparator_Cell_X				0#define	kSeparator_Cell_Y				2#define	kSeparator_ID					200#define	kButton_Cell_X					0#define	kButton_Cell_Y					3#define	kOK_Button_ID					1#define	kCancel_Button_ID				2#define	kRevert_Button_ID				3#define	kSmallFontSize					gHera->smallFontSize#define	kSmallFontNum					gHera->smallFontNum#define	kLargeFontNum					gHera->bigFontNum;#define kLargeFontSize					gHera->bigFontSize;#define	kMain_TEXT						( kMain_ID_Offset + 2)#define	kMain_TextTitle					( kMain_ID_Offset + 4)#define	kMain_TextID					( kMain_ID_Offset + 6)#define	kStrResID						8031#define	kSortByID						1#define	kSortByName						2#pragma mark _macros_/* - macros*******************************************/#pragma mark ¥¥TYPEDEFS¥¥/******************************************\|**| typedefs\******************************************//*typedef struct newTextType{	Handle							text;			// nil if to be deleted	short							resID;			// 0xffffffff if to be deleted	short							originalResID;	// 0xffffffff if new	newTextType						*next;	newTextType						*previous;	Str255							title;} newTextType;*/typedef struct TEXTEditorWindowType{	heraScenarioFileType			*heraFile;	huiMasterControlType			*master;	long							windowID;	short							resRefNum;	short							index;//	newTextType						*newText;	short							currentOriginalResID;	long							currentReferenceNum;	long							lastAllotedReferenceNum;	long							sortBy;	Text_Editor_Callback_procPtr	callBack;	Boolean							chooseButton;	Boolean							chooseRes;	Boolean							modal;	Boolean							chooseOnly;	Boolean							ownedByFactory;	short							defaultResID;	long							callerID;	long							columnFix;} TEXTEditorWindowType;#pragma mark ¥¥EXTERNAL GLOBALS¥¥/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark ¥¥PRIVATE GLOBALS¥¥/******************************************\|**| private globals\******************************************/#pragma mark ¥¥PRIVATE PROTOTYPES¥¥/******************************************\|**| private function prototypes\******************************************/static Boolean HandleEvent( EventRecord *, CWindowPtr, long, long);static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID);static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID);static void OK_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID);static void OK_Button( TEXTEditorWindowType *d);static void Cancel_Button( TEXTEditorWindowType *d);static Boolean UpdateListSelection( TEXTEditorWindowType *d, Boolean forceUpdate);static void SetUpList( TEXTEditorWindowType *d);static void Revert_Button( TEXTEditorWindowType *d);static OSErr ChangeWhichText( TEXTEditorWindowType *d, Boolean checkFirst);static short GetCellData( TEXTEditorWindowType *d, short textIndex,	long *referenceNumber, StringPtr title);static void KeepChangedText( TEXTEditorWindowType *d);static void AddNewText( TEXTEditorWindowType *d);static void DeleteText( TEXTEditorWindowType *d);static OSErr SortList( TEXTEditorWindowType *d, Boolean draw);/*static newTextType *GetNewText( TEXTEditorWindowType *d);static void DeleteNewText( TEXTEditorWindowType *d, newTextType *t);static newTextType *GetText_ByID( TEXTEditorWindowType *d, short id);*/static short CompareCellsByName( Ptr cell_a, long length_a, Ptr cell_b, long length_b);static short CompareCellsByID( Ptr cell_a, long length_a, Ptr cell_b, long length_b);//static Boolean IsIDLegal(TEXTEditorWindowType *d, short resID);static Boolean IsIDTextLegal( TEXTEditorWindowType *d, short *resID);#pragma mark ¥¥PRIVATE FUNCTIONS¥¥/******************************************\|**| private functions\******************************************/static Boolean HandleEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID, long command){	switch( command)	{		case kWDCloseWindowCommand:			break;				case kWDProcessEventCommand:			return( ProcessEvent( theEvent, whichWindow, dispatchID));			break;				case kWDSaveWindowCommand:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these texts?",										"\pBefore saving, the TEXT Editor "										"must be closed. Click Cancel to "										"abort the save.", nil, nil))				{					OK_Button_From_WindowID( whichWindow, dispatchID);							} else				{					gHera->currentSave = nil;				}			}			return false;			break;		case kWD_Close_ForQuit_Command:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these texts?",										"\pBefore quitting, the TEXT Editor "										"must be closed. Click Cancel to "										"abort the quit.", nil, nil))				{					OK_Button_From_WindowID( whichWindow, dispatchID);							} else				{					gHera->currentSave = nil;					return true;				}			}			return false;			break;//		case kWDProcessMenuChoiceCommand://			if ( Generic_ProcessMenuChoiceCommand( (unsigned long)theEvent,//				whichWindow, dispatchID)) return true;		case kWDProcessMenuChoiceCommand:			return( ProcessMenuChoiceCommand( (unsigned long)theEvent,				whichWindow, dispatchID));			break;						break;	}	return false;}static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	SignedByte						dataState;	TEXTEditorWindowType			*d;	Boolean							result = false;	GrafPtr							oldPort;	short							menuID = ((menuData & 0xffff0000) >> 16),									menuItem = (menuData & 0x0000ffff);										if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (TEXTEditorWindowType *)*data;	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);	result = Generic_ProcessMenuChoiceCommand( menuData, whichWindow,												dispatchID);	if ( result)	{		goto ProcessMenuChoiceCommand_Return;	}		switch( menuID)	{		case kEditMenuID:			switch( menuItem)			{				case kEdit_Undo_Item:					result = true;					break;				case kEdit_Add_Item:					result = true;					break;									case kEdit_Delete_Item:					result = true;					break;									case kEdit_Delete_All_Item:					result = true;					break;			}							break;		}	ProcessMenuChoiceCommand_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);}static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Boolean							result = false;	ControlHandle					aControl, oldControl;	short							whichPart, oldValue;	WindowPtr						scratchWindow;	Point							where;	char							whichChar;	GrafPtr							oldPort;	OSStatus						err;	TEXTEditorWindowType				*d;		if ( data == nil) return false;	if ( theEvent == nil) return false;		dataState = HGetState( data);	HLock( data);	d = (TEXTEditorWindowType *)*data;		if ( theEvent == nil) goto ProcessEvent_Return;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);		switch( theEvent->what)	{		case nullEvent:			IdleControls( (WindowPtr)whichWindow);						result = true;			break;					case updateEvt:				BeginUpdate ((WindowPtr)whichWindow);/*			SetPort( (WindowPtr)whichWindow);			CalcVis( (WindowPtr)whichWindow);			UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);*/			HU_GenericUpdateEventHandler( whichWindow);			EndUpdate ((WindowPtr)whichWindow);			result = true;			break;		case activateEvt:		{			Boolean	isActive = ((theEvent->modifiers & activeFlag) != 0);						if ( isActive)			{				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_scenarioFile_refNum);			}		}			// result != true so dispatch window will handle activation			// of controls etc.			break;					case mouseDown:			whichPart = FindWindow (theEvent->where, &scratchWindow);			switch( whichPart)			{				case inGrow:/*					{						Rect	growRect;						long	newSize;//						growRect = qd.screenBits.bounds;						C2C_ScreenBits_GetBounds( &growRect);						growRect.top = growRect.left = 120;						newSize = GrowWindow((WindowPtr)whichWindow,							theEvent->where ,&growRect);						if (newSize != 0)						{							SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,								(((newSize) >> 16) & 0xFFFF), true );							EraseRect(&whichWindow->portRect);							InvalRect( &whichWindow->portRect);						}					}*/					HU_GenericGrowWindow( whichWindow, theEvent->where);					result = true;					break;								case inContent:					where = theEvent->where;					scratchWindow = WD_FrontWindow();					if ( whichWindow != (CWindowPtr)scratchWindow)					{						goto ProcessEvent_Return;					}					SetPortWindowPort( (WindowPtr)whichWindow);					GlobalToLocal( &where);					whichPart = FindControl( where, (WindowPtr)whichWindow,						&aControl);					if ( aControl == nil)						goto ProcessEvent_Return;					oldValue = GetControlValue( aControl);					err = GetKeyboardFocus( (WindowPtr)whichWindow, &oldControl);					if (( err == noErr) && ( oldControl != aControl))					{						SetKeyboardFocus( (WindowPtr)whichWindow, aControl, whichPart);					}					if ( whichPart != 0)					{						huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);//						whichPart = HandleControlClick ( aControl, where,//							theEvent->modifiers, (ControlActionUPP)-1//nil//							);							if ( !ListBox_Appearance_1_0_1_Hack( aControl, where,									&whichPart))						{							whichPart = HUI_Control_Click_Handle( hui, where,								theEvent->modifiers);														}						if ( whichPart != kControlNoPart) switch( hui->generic.id)						{							case kOK_Button_ID:								result = true;								if ( UpdateListSelection( d, true))									OK_Button( d);								data = nil;								goto ProcessEvent_Return;								break;														case kCancel_Button_ID:								Cancel_Button( d);								data = nil;								result = true;								goto ProcessEvent_Return;								break;														case kRevert_Button_ID:								Revert_Button( d);								break;															case kList_Add_Button_ID:								AddNewText( d);								UpdateListSelection( d, false);								SortList( d, true);								d->index =  HUI_Control_GetListValue(									d->master, 0, kList_Cell_X, kList_Cell_Y,									kList_ID, d->index);								result = true;								break;														case kList_Remove_Button_ID:								if ( HU_Confirm_Delete("\pAre you sure you "									"want to delete this text?",										theEvent->modifiers))								{									DeleteText( d);									ChangeWhichText( d, false);								}								result = true;								break;															case kList_ID:								UpdateListSelection( d, false);								result = true;								break;														case kList_SortBy_Menu_ID:								oldValue = d->sortBy;																d->sortBy = HUI_Control_GetValueShort(									d->master, 0, kList_Button_Cell_X,									kList_Button_Cell_Y, kList_SortBy_Menu_ID);																	if ( d->sortBy != oldValue)								{									SortList( d, true);								}								result = true;								break;															default:								break;						}					} else // not in control					{						where = theEvent->where;						GlobalToLocal( &where);					}			}			break;					case keyDown:		case autoKey:			whichChar = theEvent->message & charCodeMask;						whichPart = kControlNoPart;			err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);			if (( err == noErr) && ( aControl != nil))			{				whichPart = HandleControlKey( aControl,					(theEvent->message & keyCodeMask)>>16,					theEvent->message & charCodeMask, theEvent->modifiers);				{					huiGenericControlType *hui =						(huiGenericControlType *)CU_GetControlReference( aControl);										if ( hui->kind != hui_ScrollTextControl) whichPart =						kControlNoPart;										switch( hui->id)					{						case kList_ID:							UpdateListSelection( d, false);							break;					}				}			}						if ( whichPart == kControlNoPart)			{				if ((whichChar=='\r' || whichChar==0x3))				{					// ok					long			soon = TickCount()+5;										aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,						kButton_Cell_Y, kOK_Button_ID);					if ( aControl != nil)					{						ActivateControl( aControl);						while ( TickCount() < soon){ /* do nothing */}						DeactivateControl( aControl);						result = true;						if ( UpdateListSelection( d, true))							OK_Button( d);						data = nil;						goto ProcessEvent_Return;					}				} else if ((whichChar==0x1b) || ((whichChar=='.') && (theEvent->modifiers & cmdKey)))				{					// cancel					long			soon = TickCount()+5;										aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,						kButton_Cell_Y, kCancel_Button_ID);					if ( aControl != nil)					{						ActivateControl( aControl);						while ( TickCount() < soon){ /* do nothing */}						DeactivateControl( aControl);												Cancel_Button( d);						data = nil;						result = true;						goto ProcessEvent_Return;					}				} else if ( whichChar == '\t')				{					if ( theEvent->modifiers & shiftKey)						ReverseKeyboardFocus( (WindowPtr)whichWindow);					else					{						AdvanceKeyboardFocus( (WindowPtr)whichWindow);					}					result = true;					break;				} else if (( whichChar == 0x08) && ( !d->chooseOnly) &&					( !d->ownedByFactory))				{					huiPlainControlType	*hui = nil;					err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);					hui = (huiPlainControlType	*)CU_GetControlReference( aControl);					if ( hui != nil)					{						if ( hui->generic.id == kList_ID)						{							if ( HU_Confirm_Delete("\pAre you sure you "								"want to delete this text?",								theEvent->modifiers))							{								DeleteText( d);								ChangeWhichText( d, false);							}						}					}					result = true;				}			}			break;	}		ProcessEvent_Return:	SetPort( oldPort);	if ( data != nil)		HSetState( data, dataState);	return( result);	}static void OK_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	TEXTEditorWindowType		*d;#pragma unused( whichWindow)	if ( data == nil) return;		dataState = HGetState( data);	HLock( data);	d = (TEXTEditorWindowType *)*data;	OK_Button( d);	// data has been deleted; window is closed}static void OK_Button( TEXTEditorWindowType *d){//	newTextType	*newText = d->newText, *deleteText;	short		oldResRefNum, resID;		mAssert ( d != nil);	oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);/*	// go through and DELETE all TEXT resources that have new IDs			while (newText != nil)	{		if ( newText->originalResID != newText->resID)		{			text = GetResource( 'TEXT', newText->originalResID);			if ( text != nil)			{				RemoveResource( text);			}		}		newText = newText->next;				}		UpdateResFile( d->resRefNum);	// go through and change all TEXT resources that have new titles or data			newText = d->newText;	while (newText != nil)	{		if (( newText->originalResID == newText->resID) && ( newText->text != nil))		{			text = GetResource( 'TEXT', newText->originalResID);			SetHandleSize( text, GetHandleSize( newText->text));			err = MemError();			if ( err != noErr)			{				BP_AnErrorOfTypeN_Literal("Resource Error", "CouldnÕt resize an"					" existing resource because an error of type ", err,					" occurred.");			} else			{				BlockMove( *newText->text, *text, GetHandleSize( newText->text));				SetResInfo( text, newText->resID, newText->title);				ChangedResource( text);			}		} else		{			if ( newText->text != nil)				AddResource( newText->text,  'TEXT', newText->resID, newText->title);		}		deleteText = newText;		newText = newText->next;				DisposePtr( (Ptr)deleteText);			}	UpdateResFile( d->resRefNum);	err = ResError();	if ( err != noErr)	{		BP_AnErrorOfTypeN_Literal("Resource Error", "CouldnÕt save the changes"			" because an error of type ", err,			" occurred.");	}*/	// we know that id is ok 	if ( IsIDTextLegal( d, &resID)) 	{	 	ChangeWhichText( d, true);		if ( d->modal) gHera->modalMode--;		if ( d->callBack != nil) d->callBack( d->callerID, resID);						HUI_MasterControl_Delete( d->master);		CloseDispatchWindow( d->windowID);	}		UseResFile( oldResRefNum);}static void Cancel_Button( TEXTEditorWindowType *d){	if ( d->modal) gHera->modalMode--;	HUI_MasterControl_Delete( d->master);	CloseDispatchWindow( d->windowID);}static void Revert_Button( TEXTEditorWindowType *d){	CWindowPtr whichWindow = GetWindowPtrFromDispatchWindowID( d->windowID);		if ( whichWindow == nil) return;	if ( !Button_Window_Modal( "\pRevert this TEXT resource?",							"\pClick Revert to restore this text to its "							"previous values. Click Cancel to "							"keep it as it is.", "\pRevert", nil))		return;	ChangeWhichText( d, false);}static Boolean UpdateListSelection( TEXTEditorWindowType *d, Boolean forceUpdate){	long	oldValue, newValue;	short	resID;		if ( !d->chooseRes)	{		ChangeWhichText( d, true);		return true;	}		oldValue = d->index;	newValue =  HUI_Control_GetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->index);	if (( oldValue != newValue) || ( forceUpdate))	{				if ( IsIDTextLegal( d, &resID))			ChangeWhichText( d, true);		else		{			d->index =  HUI_Control_SetListValue(					d->master, 0, kList_Cell_X, kList_Cell_Y,					kList_ID, oldValue);			HUI_Control_SetFocus( d->master, 0,				kMain_Cell_X - d->columnFix, kMain_Cell_Y, kMain_TextID);			BP_UserError_Literal("Illegal value",				"%s%d%s", "The resource ID ", resID,				" is already in use. Please enter a"				" different ID.");			return false;		}	}		return true;}static void AddNewText( TEXTEditorWindowType *d){	long			dataLength;//	newTextType		*newText = nil;	ControlHandle	aControl;	ListHandle		list;	Ptr				data = nil;	Str255			ids;	Point			cell;	short			id;		mAssert( d != nil);		// 1st get our current id	id = GetCellData( d, d->index, nil, nil);	/*	// increase it until its legal	do	{		id++;	} while (!IsIDLegal( d, id));*/	HRT_AddNewResource( d->heraFile, NewHandle(0), 'TEXT', &id, "\p<untitled>");		//	newText = GetNewText( d);//	if ( newText != nil)	{//		newText->originalResID = 0xffffffff;//		newText->resID = id;//		pstrcpy( newText->title, "\p<untitled>");//		newText->text = NewHandle(0);//		newText->next = nil;						aControl = HUI_Control_Get( 			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID);		if ( aControl != nil)		{			GetListBoxListHandle( aControl, &list);					if ( list != nil)			{				NumToString( id, ids);				data = PsuedoColumn_Data_Make( &dataLength,					d->lastAllotedReferenceNum++, ids, "\p\t", "\p<untitled>", "\p");				if ( data != nil)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.h = 0;					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( data, dataLength, cell, list );					DisposePtr( data);					HUI_Control_SetListValue( d->master, 0, kList_Cell_X,						kList_Cell_Y, kList_ID, (**list).dataBounds.bottom - 1);				} else					goto AddNewText_error;			} else				goto AddNewText_error;		} else			goto AddNewText_error;	}		// the list should be sorted after calling this, but not before	// 1st calling update list selection	return;AddNewText_error://	if ( newText != nil) DisposePtr( (Ptr)newText);	if ( data != nil) DisposePtr( data);}static void DeleteText( TEXTEditorWindowType *d){	long			id;//	newTextType		*newText = nil;		mAssert( d != nil);	// 1st get our current id	id = GetCellData( d, d->index, nil, nil);	/*	// find if any newtext already "belongs" to it	newText = d->newText;		if ( newText != nil)	{		while (( newText->next != nil)	&& (( newText->resID == id) ||			((newText->resID == 0xffffffff) && ( newText->originalResID == id))))			newText = newText->next;				// if we found one and it's already marked for deletion, exit		// (shouldn't be possible)		if ((newText->resID == 0xffffffff) && ( newText->originalResID == id))			return;				// if we didn't find one, nil newText		if ( newText->resID != id) newText = nil;	}		// if we didn't find one, then it's a resource that exists; make newText	// to mark for deletion	if ( newText == nil)	{		newText = GetNewText( d);		if ( newText != nil)		{			newText->text = nil;			newText->resID = 0xffffffff;			newText->originalResID = id;			newText->next = nil;			newText->title[0] = 0;		} else return;	// error	}		// if we have one	if ( newText != nil)	{		// and we haven't just marked it for deletion		if ( newText->resID != 0xffffffff)		{			newText->resID = 0xffffffff;				// if there's no original resid, then this is a text resource			// that isn't in res file -- we made it, so no need to mark it			// for deletion; just remove it			if ( newText->originalResID == 0xffffffff)			{				DeleteNewText( d, newText);			}		}	}*/		HRT_DeleteResource( d->heraFile, 'TEXT', id);		HUI_Control_DeleteListRows(		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, 1, d->index);	HUI_Control_SetListValue(		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, d->index);}static void SetUpList( TEXTEditorWindowType *d){	short						oldResRefNum = 0;	ControlHandle				aControl;	ListHandle					list;	long						textNum = 0;		if ( d == nil) return;		if ( !d->chooseRes) return;		oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);		textNum = CountResources('TEXT');			aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Cell		cell;				GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			short		i = 1, count = textNum, theID, resHomeFile;			Str255		ids, ns;			Handle		text;			ResType		theType;			Ptr			data = nil;			long		dataLength;			Boolean		done = false, dataExists;			newResourceType	*hrtPtr = nil;						LDelRow( 0, 0, list);	// delete all rows			(*list)->selFlags = lOnlyOne;						textNum = 0;			cell.h = 0;			do			{				dataExists = false;				if ( count > 0)				{					text = GetIndResource( 'TEXT', i);					if ( text != nil)					{						GetResInfo( text, &theID, &theType, ns);						resHomeFile = HomeResFile( text);						ReleaseResource( text);						if (( theID > 0) && ( mResOwner_IsOK( resHomeFile, d->heraFile)))						{							HRT_Resource_GetChanges( d->heraFile, 'TEXT',								&theID, ns);							if ( theID > 0)								dataExists = true;						}					}					count--;				} else				{					hrtPtr = HRT_Resource_GetNextNew( d->heraFile, 'TEXT',								hrtPtr, &theID, ns);					if ( hrtPtr == nil)					{						done = true;					} else dataExists = true;				}				if ( dataExists)				{												NumToString( theID, ids);						if ( ns[0] == 0) pstrcpy( ns, "\p<untitled>");												data = PsuedoColumn_Data_Make( &dataLength,							d->lastAllotedReferenceNum++, ids, "\p\t", ns, "\p");				} else data = nil;				if ( data != nil)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( data, dataLength, cell, list );					DisposePtr( data);					data = nil;					textNum++;				}				i++;			} while (!done);		}	}	{		OSErr err =			List_Utilities_QSort( list, (Point){0, 0}, (Point){textNum - 1, 0},				CompareCellsByID);			if ( err != noErr) SysBeep(20);	}		GetAllData_error:		UseResFile( oldResRefNum);}static OSErr ChangeWhichText( TEXTEditorWindowType *d, Boolean checkFirst){	ControlHandle		aControl;	TEHandle			text;	Handle				newText, keepText;	Str255				s;	short				theID, oldResRefNum, originalResID, resOwnerRefNum;		oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);	s[0] = 0;		mAssert( d != nil);		if ( checkFirst)		KeepChangedText( d);		if ( d->chooseRes)	{		d->index = HUI_Control_GetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, d->index);		mAssert( d->index >= 0);					// get the id by looking it up in the list		theID = GetCellData( d, d->index, &d->currentReferenceNum, nil);	} else	{		theID = d->defaultResID;	}		keepText = HRT_Resource_GetHandle_WithOwnerFile( d->heraFile, 'TEXT',		theID, &originalResID, &resOwnerRefNum, s);	if ( keepText == nil)	{	} else	{		d->currentOriginalResID = theID;	}	aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X - d->columnFix,					kMain_Cell_Y, kMain_TEXT);	if ( aControl != nil)	{		text = HUI_ScrollText_GetFromControl( aControl);		if ( text != nil)		{			HUI_ScrollText_Reset( (huiScrollTextControlType *)CU_GetControlReference( aControl));			TESetSelect( 0, 32767, text);			TEDelete( text);			newText = keepText;			if ( newText != nil)			{				HLock( newText);				TESetText( *newText, GetHandleSize( newText), text);				HUnlock( newText);				Draw1Control( aControl);			}		}	}	aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X - d->columnFix,					kMain_Cell_Y, kMain_TextTitle);	if ( aControl != nil)	{		SetControlTextItemString( aControl, s);		Draw1Control( aControl);	}	aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X - d->columnFix,					kMain_Cell_Y, kMain_TextID);	if ( aControl != nil)	{		NumToString( theID, s);		SetControlTextItemString( aControl, s);		Draw1Control( aControl);	}	if ( resOwnerRefNum != d->heraFile->fileRefNum)	{		d->ownedByFactory = true;		HUI_Control_Hilite( d->master, 0, kList_Button_Cell_X,			kList_Button_Cell_Y, kList_Remove_Button_ID, 0);		HUI_Control_Hilite( d->master, 0, kMain_Cell_X - d->columnFix,			kMain_Cell_Y, kMain_TextTitle, 0);		HUI_Control_Hilite( d->master, 0, kMain_Cell_X - d->columnFix,			kMain_Cell_Y, kMain_TextID, 0);	} else	{		d->ownedByFactory = false;		HUI_Control_Hilite( d->master, 0, kList_Button_Cell_X,			kList_Button_Cell_Y, kList_Remove_Button_ID, 1);		HUI_Control_Hilite( d->master, 0, kMain_Cell_X - d->columnFix,			kMain_Cell_Y, kMain_TextTitle, 1);		HUI_Control_Hilite( d->master, 0, kMain_Cell_X - d->columnFix,			kMain_Cell_Y, kMain_TextID, 1);	}	if ( keepText != nil) DisposeHandle( keepText);	UseResFile( oldResRefNum);	return noErr;	}static short GetCellData( TEXTEditorWindowType *d, short textIndex,	long *referenceNumber, StringPtr title){	ControlHandle		aControl;	Str255				s;	ListHandle			list;	short				result = -1;	mAssert( d != nil);			aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			long	tl;			short	length;			Ptr		data = List_Utilities_GetCell( list, (Point){textIndex, 0}, &length);						if ( data != nil)			{				PsuedoColumn_String_GetAll( data, length, referenceNumber, s, title, -1);								DisposePtr( data);				StringToNum( s, &tl);				result = tl;			}		}	}	return result;}/*	KeepChangedText		if the text has changed, this will append it to the list of changed text;	id must be confirmed as being legal 1st*/static void KeepChangedText( TEXTEditorWindowType *d){	ControlHandle		aControl;	TEHandle			text;	Str255				newTitle;	short				originalResID = -1, newID, oldResRefNum;	Handle				newText;	Boolean				different = false, titleDifferent = false,						idDifferent = false;	unsigned long		textChanges = 0;		mAssert( d != nil);	if ( d->chooseOnly) return;		aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X - d->columnFix,					kMain_Cell_Y, kMain_TextID);	if ( aControl != nil)	{		newID = GetControlTextItemLong( aControl);	}	aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X - d->columnFix,					kMain_Cell_Y, kMain_TEXT);	if ( aControl != nil)	{		// get the TEHandle		text = HUI_ScrollText_GetFromControl( aControl);		if ( text != nil)		{			// get the text of the TEHandle			newText = (Handle)TEGetText( text);			if ( newText != nil)			{				aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X - d->columnFix,								kMain_Cell_Y, kMain_TextTitle);				if ( aControl != nil)				{					GetControlTextItemString( aControl, newTitle);				}								oldResRefNum = CurResFile();				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_scenarioFile_refNum);				textChanges = HRT_KeepChangedResource( d->heraFile, newText, 'TEXT',					d->currentOriginalResID, newID, newTitle);				UseResFile( oldResRefNum);									// make changes to list				if ( d->chooseRes)				{					Ptr		data;					Str255	ids;					long	dataLength;										NumToString( newID, ids);					data = PsuedoColumn_Data_Make( &dataLength,						d->currentReferenceNum, ids, "\p\t",						newTitle, "\p");					if ( data != nil)					{						HUI_Control_SetListCell( d->master, 0, kList_Cell_X,							kList_Cell_Y, kList_ID, 0, d->index, data,							dataLength);						HUI_Control_Draw( d->master, 0, kList_Cell_X,							kList_Cell_Y, kList_ID);						DisposePtr( data);					}					// we have to resort if the relevant field has been changed					if ( ((textChanges & kHRT_ResourceDifferenceFlag_Title) &&						( d->sortBy == kSortByName)) ||						(( textChanges & kHRT_ResourceDifferenceFlag_ID) &&						( d->sortBy == kSortByID)))					{						SortList( d, true);					}				}			}		}	}}static OSErr SortList( TEXTEditorWindowType *d, Boolean draw){	short			currentSelectionIndex = 0, dataLength = 0;	long			currentSelectionReference = 0, i = 0, thisReference;	Ptr				data = nil;	OSErr			err = noErr;	ControlHandle	aControl = nil;	ListHandle		list = nil;	Boolean 		done, found;		// in order to preserve the selection,	// we have to get it's arbitrary reference #		if ( !d->chooseRes) return noErr;		currentSelectionIndex =  HUI_Control_GetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->index);		aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);			if ( aControl == nil) return paramErr;	GetListBoxListHandle( aControl, &list);		if ( list == nil) return paramErr;		data = List_Utilities_GetCell(list, (Point){currentSelectionIndex, 0},		&dataLength);		if ( data == nil) return memFullErr;		PsuedoColumn_String_GetAll( data, dataLength,		&currentSelectionReference, (StringPtr)-1);	DisposePtr( data);		if ( d->sortBy == kSortByName)		err = List_Utilities_QSort( list, (Point){0, 0},			(Point){(**list).dataBounds.bottom - 1, 0},			CompareCellsByName);	else if ( d->sortBy == kSortByID)		err = List_Utilities_QSort( list, (Point){0, 0},			(Point){(**list).dataBounds.bottom - 1, 0},			CompareCellsByID);		// now we have to find our selection; we may as well start with its original	// position		done = found = false;	i = 0;		while (( !done) && ( !found))	{		if ( (currentSelectionIndex + i) < (**list).dataBounds.bottom)		{			data = List_Utilities_GetCell(list, (Point){currentSelectionIndex + i, 0},				&dataLength);			if ( data != nil)			{				PsuedoColumn_String_GetAll( data, dataLength,					&thisReference, (StringPtr)-1);								if ( thisReference == currentSelectionReference)				{					found = true;					currentSelectionIndex = currentSelectionIndex + i;				}				DisposePtr( data);			}		} else done = true;		if ( (currentSelectionIndex - i) >= 0)		{			data = List_Utilities_GetCell(list, (Point){currentSelectionIndex - i, 0},				&dataLength);			if ( data != nil)			{				PsuedoColumn_String_GetAll( data, dataLength,					&thisReference, (StringPtr)-1);								if ( thisReference == currentSelectionReference)				{					found = true;					currentSelectionIndex = currentSelectionIndex - i;				}				DisposePtr( data);			}			done = false;		} else		{			// do nothing; if done was previously true, keep it true			// if it was false, keep it false		}		i++;	}	HUI_Control_SetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, currentSelectionIndex);	LAutoScroll( list);	if ( draw) Draw1Control( aControl);		return err;}static Boolean IsIDTextLegal( TEXTEditorWindowType *d, short *theID){	ControlHandle	aControl;		/* to determine if id is legal:		0.	legal if unchanged from original		1.	illegal if any newText has the same current id;		2.	illegal if any TEXT resource of same id exists AND there is no			newText with same original id			(there could be a newText with same original id and same current id,			but we ruled those out in 1)	*/	aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X - d->columnFix,					kMain_Cell_Y, kMain_TextID);	if ( aControl != nil)	{		*theID = GetControlTextItemLong( aControl);	} else	{		*theID = 0;		return false;	}	// if unchanged, is legal, exit	if ( *theID == d->currentOriginalResID) return true;	return ( HRT_IsIDLegal( d->heraFile, 'TEXT', *theID));}static short CompareCellsByName( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	name_a, name_b;	long	result;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, nil, name_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, nil, name_b, -1);	result = pstrcmp_nocase( name_a, name_b);	return -result;}static short CompareCellsByID( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	id_string_a, id_string_b;	long	id_a, id_b;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, id_string_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, id_string_b, -1);	StringToNum( id_string_a, &id_a);	StringToNum( id_string_b, &id_b);	if ( id_a < id_b)	{		return 1;	} else if ( id_a > id_b)	{		return -1;	} else	{		return 0;	}}#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/OSErr TEXTEditor_NewWindow( heraScenarioFileType *heraFile,	StringPtr title, short resRefNum, short callerID,	short resID, Boolean chooseRes, Boolean chooseButton, Boolean modal,	Text_Editor_Callback_procPtr callBack){	Rect						bounds;	CWindowPtr					newWindow;	ControlHandle				rootControl, aControl;	huiPlainControlParamType	buttonParam, textParam;	huiMasterControlParamType	masterParam;	OSStatus					err;	Handle						data, strList;	TEXTEditorWindowType		*d;	long						maxWidth = 0;	long						windowID = -1;	huiCellParamType			cellParam;	ListHandle					list;	#pragma unused ( err, textParam, aControl)			// create the new window	data = NewHandle( sizeof( TEXTEditorWindowType));	if ( data == nil) return memFullErr;		HLock( data);	d = (TEXTEditorWindowType *)*data;		SetRect( &bounds, 64, 64, 128, 128);	if ( modal)	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowMovableModalDialogProc, (WindowPtr)-1, false,			HandleEvent, 0,			&windowID);	} else	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowDocumentProc, (WindowPtr)-1, false,			HandleEvent, 0,			&windowID);	}	SetDispatchWindowDataHandle( windowID, data);	d->windowID = windowID;	d->resRefNum = resRefNum;	d->index = 0;	d->currentOriginalResID = -1;//	d->newText = nil;	d->sortBy = kSortByID;	d->currentReferenceNum = 0;	d->lastAllotedReferenceNum = 0;	d->chooseButton = chooseButton;	d->defaultResID = resID;	d->modal = modal;	d->callBack = callBack;	d->callerID = callerID;	d->chooseRes = chooseRes;	d->ownedByFactory = false;	if ( d->chooseRes) d->columnFix = 0;	else d->columnFix = 1;	d->heraFile = heraFile;	if ( heraFile->fileRefNum <= 0) d->chooseOnly = true;	else d->chooseOnly = false;		SetThemeWindowBackground( (WindowPtr)newWindow,		kThemeActiveDialogBackgroundBrush, true);	SetPortWindowPort( (WindowPtr)newWindow);	CreateRootControl( (WindowPtr)newWindow, &rootControl);	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kRowNum;	masterParam.colNum = kColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->master = HUI_MasterControl_New( nil, 0, 0, 0, &masterParam);		mAssert( d->master != nil);	if ( d->master == nil) return memFullErr;	d->master->tab[0][0].h = kLarge_Tab_Width;	d->master->tab[0][0].hAlign = hui_halign_right;	d->master->tab[0][1].h = kLarge_Tab_Width;	d->master->tab[0][1].hAlign = hui_halign_left;	cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, 12, -1, 3);	SetRect( &cellParam.inSpace, -1, 3, -1, 3);	if ( d->chooseRes)		cellParam.colSpan = 1;	else		cellParam.colSpan = 2;	cellParam.rowSpan = 2;	HUI_Cell_Set( 0, kMain_Cell_X - d->columnFix, kMain_Cell_Y, &cellParam);	// set up list cell	SetRect( &cellParam.outSpace, 12, 12, 3, 5);	SetRect( &cellParam.inSpace, 3, 3, 3, 3);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_right;	cellParam.minMaxBounds.top = 100;		if ( d->chooseRes)		HUI_Cell_Set( 0, kList_Cell_X, kList_Cell_Y, &cellParam);	cellParam.minMaxBounds.top = 0;	cellParam.minMaxBounds.top = 0;		// set up list button cells	SetRect( &cellParam.outSpace, 12, -1, 3, 3);	SetRect( &cellParam.inSpace, -1, -1, 3, 3);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.baseLine = gHera->smallFontSize;	cellParam.hAlign = hui_halign_center;	d->master->rowDontExpand[kList_Button_Cell_Y] = true;	if ( d->chooseRes)		HUI_Cell_Set( 0, kList_Button_Cell_X, kList_Button_Cell_Y, &cellParam);	cellParam.minMaxBounds.bottom = kHUI_Pixel_Max;	// set up buttons, general	buttonParam.master = d->master;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask | kControlUseJustMask;	buttonParam.fontStyle.font = kSmallFontNum;	buttonParam.fontStyle.size = kSmallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = teCenter;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;	buttonParam.flags = huiControlFlag_none;		// set up text, general		textParam.master = d->master;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = kControl_H_Space;//8;	textParam.space.top = 12;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = -1;	textParam.cellx = kMain_Cell_X - d->columnFix;	textParam.celly = kMain_Cell_Y;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;	if ( d->chooseOnly) buttonParam.enabled = false;	if ( d->chooseOnly) textParam.enabled = false;	// text title		textParam.id = kMain_TextTitle - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 1);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kMain_TextTitle;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	if ( d->chooseRes)		HUI_EditText_New_LiteralP( &textParam);		else		HUI_StaticText_New_LiteralP( &textParam);	// text id		textParam.id = kMain_TextID - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 3);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kMain_TextID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	if ( d->chooseRes)		HUI_EditText_New_LiteralP( &textParam);		else		HUI_StaticText_New_LiteralP( &textParam);	// set up scroll text	buttonParam.minMaxBounds.left = 300;	buttonParam.minMaxBounds.top = 300;	buttonParam.minMaxBounds.right = 300;	buttonParam.minMaxBounds.bottom = 300;	buttonParam.cellx = kMain_Cell_X - d->columnFix;	buttonParam.celly = kMain_Cell_Y;	buttonParam.id = kMain_TEXT;	buttonParam.special.scrollText.font = GetFontNumByString("\pMonaco");	buttonParam.special.scrollText.style = 0;	buttonParam.special.scrollText.size = 9;	buttonParam.special.scrollText.acceptTabs = false;	buttonParam.special.scrollText.acceptReturns = true;	buttonParam.special.scrollText.maxSize = -1;	buttonParam.flags = huiControlFlag_newLine;		HUI_ScrollText_New_LiteralP( &buttonParam);	// make selection list	buttonParam.enabled = true;	buttonParam.id = kList_ID;	buttonParam.minMaxBounds.left = 240;	buttonParam.minMaxBounds.right = 240;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;//200;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.bottom = 200;	buttonParam.cellx = kList_Cell_X;	buttonParam.celly = kList_Cell_Y;	buttonParam.special.listBox.ldesResID = 130;	// psuedo-column ldef	buttonParam.special.listBox.refCon = 131;		// psuedo-column params	buttonParam.flags = (huiControlFlagType )((int)huiControlFlag_useCellV |		(int)huiControlFlag_useCellH);	buttonParam.space.left = 4;	buttonParam.space.top = 4;	if ( d->chooseRes)		HUI_ListBox_New_LiteralP( &buttonParam);		buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// set up list buttons		buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	textParam.cellx =  kList_Button_Cell_X;	textParam.celly =  kList_Button_Cell_Y;	// sort by menu		textParam.id = kList_SortBy_Menu_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kStrResID, 2);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	if ( d->chooseRes)		HUI_StaticText_New_LiteralP( &textParam);	textParam.id = kList_SortBy_Menu_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;		strList = GetStringList( 8032);	if ( strList != nil)	{		textParam.special.menuStrList.strList = strList;		textParam.special.menuStrList.menuID = HU_GetNewMenuID();		textParam.minMaxBounds.right = kHUI_Pixel_Max;		textParam.minMaxBounds.left = 0;		if ( d->chooseRes)			HUI_PopupButton_New_StrList( &textParam);		ReleaseResource( strList);		textParam.minMaxBounds.right = kHUI_Pixel_Max;	}	if ( d->chooseOnly) buttonParam.enabled = false;	buttonParam.id = kList_Add_Button_ID;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 9);	if ( d->chooseRes)		HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.id = kList_Remove_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 10);	if ( d->chooseRes)		HUI_PushButton_New_LiteralP( &buttonParam);	if ( chooseButton)	{		strList = GetStringList( kHera_ChooseMainButtonsStrResID);	} else	{		strList = GetStringList( kHera_DefaultMainButtonStrResID);	}	if ( strList != nil)	{		HUI_Main_Buttons_H_Setup( d->master, 0,			kSeparator_Cell_X, kColNum, kSeparator_Cell_Y, 1,				true, strList);				ReleaseResource( strList);	}		SetUpList( d);	ShowWindow( (WindowPtr)newWindow);	HUI_Master_Layout( d->master, (Point){0, 0}, (Point){0, 0});	HUI_Master_ShowLayer( d->master, 0);		if ( d->chooseRes)	{		list = HUI_List_Get( d->master, 0, kList_Cell_X, kList_Cell_Y, kList_ID);		if ( list != nil)		{			d->index = PsuedoColumn_CellV_FindFromNumber( list, 0, d->defaultResID);			if ( d->index < 0) d->index = 0;		}				d->index =  HUI_Control_SetListValue(				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, d->index);		if ( list != nil)		{			LAutoScroll( list);		}	}	ChangeWhichText( d, false);	if ( modal) gHera->modalMode++;		HUnlock( data);	return noErr;}