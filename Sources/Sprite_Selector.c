/******************************************\|**| Sprite_Selector.c\******************************************/#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************///#include <Appearance.h>	// for getrootcontrol#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Window Dispatch.h"#include "Control Utilities.h"#include "Hewey.h"#include "Hewey_Main.h"#include "Hewey_Layout.h"#include "Hewey_Utilities.h"#include "str_bp.h"#include "Set Font By String.h"#include "BP_Error.h"#include "Assert.h"#include "strlist.h"#include "Hewey_Helpers.h"#include "PsuedoColumn_Utilities.h"#include "List_Utilities.h"#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/// hera#include "Sprite_Selector.h"#include "Hera_Utilities.h"#include "Hera_Global.h"#include "Sprite_Importer.h"#include "Hera_ResourceTracker.h"#include "Button_Window.h"#include "Smart_File.h"// ares#include "NatePixTable.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kLarge_Tab_Width				80//112#define	kEditTextBigFieldWidth			150#define	kEditTextFieldWidth				38#define	kEditTextSmallFieldWidth		16#define	kPopup_Field_Width				150#define	kControl_H_Space				8#define	kColNum							2#define	kRowNum							4#define	kMain_Cell_X					1#define	kMain_Cell_Y					0#define	kMain_ID_Offset					100#define	kMain_Sprite					( kMain_ID_Offset + 2)#define	kMain_SpriteTitle				( kMain_ID_Offset + 4)#define	kMain_SpriteID					( kMain_ID_Offset + 6)#define	kMain_Preview_CheckBox			( kMain_ID_Offset + 8)#define	kMain_Light_Background_CheckBox	( kMain_ID_Offset + 10)	#define	kMain_Scale_Menu				( kMain_ID_Offset + 12)#define	kSeparator_Cell_X				0#define	kSeparator_Cell_Y				2#define	kSeparator_ID					200#define	kButton_Cell_X					0#define	kButton_Cell_Y					3#define	kOK_Button_ID					1#define	kCancel_Button_ID				2#define	kRevert_Button_ID				3// list cell// :master#define	kList_Cell_X					0#define	kList_Cell_Y					0#define	kList_ID_Offset					300#define	kList_ID						(kList_ID_Offset + 2)// list button cell// :master#define	kList_Button_Cell_X				0#define	kList_Button_Cell_Y				1#define	kList_Button_ID_Offset			400#define	kList_Remove_Button_ID			(kList_Button_ID_Offset + 2)#define	kList_Add_Button_ID				(kList_Button_ID_Offset + 4)#define	kList_SortBy_Menu_ID			(kList_Button_ID_Offset + 6)#define	kSmallFontSize					gHera->smallFontSize#define	kSmallFontNum					gHera->smallFontNum#define	kLargeFontNum					gHera->bigFontNum;#define kLargeFontSize					gHera->bigFontSize;#define	kStrResID						8037#define	kSortByID						1#define	kSortByName						2#define	kAnimation_Tick_Delay			15#define	kPix_Preview_Max_Height			400#pragma mark _macros_/* - macros*******************************************/#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/typedef struct Sprite_SelectorWindowType{	heraScenarioFileType			*heraFile;	huiMasterControlType			*master;	long							windowID;	short							resRefNum;	short							currentOriginalResID;	short							defaultResID;//	short							theID;	long							currentReferenceNum;	long							lastAllotedReferenceNum;	long							index;	long							sortBy;	GWorldPtr						spriteWorld;	short							resID;	Boolean							animate;	Boolean							lightBackground;	long							lastFrameTime;	long							currentFrame;	long							scale;	Boolean							isModal;	Boolean							chooseOnly;	long							callerID;	Boolean							ownedByFactory;	Sprite_Selector_Callback_procPtr	callBack;} Sprite_SelectorWindowType;#pragma mark 본EXTERNAL GLOBALS본/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark 본PRIVATE GLOBALS본/******************************************\|**| private globals\******************************************/#pragma mark 본PRIVATE PROTOTYPES본/******************************************\|**| private function prototypes\******************************************/static Boolean HandleEvent( EventRecord *, CWindowPtr, long, long);static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID);static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID);static void SampleSprite_Draw( CWindowPtr window, Sprite_SelectorWindowType *d);static void CenterRectInRect( Rect *bigRect, Rect *rect);static Boolean UpdateListSelection( Sprite_SelectorWindowType *d,	Boolean forceUpdate);static Boolean IsIDSpriteLegal( Sprite_SelectorWindowType *d, short *theID);static short GetCellData( Sprite_SelectorWindowType *d, short textIndex,	long *referenceNumber, StringPtr title);static void OK_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID);static void OK_Button( Sprite_SelectorWindowType *d);static void Cancel_Button( Sprite_SelectorWindowType *d);static void Revert_Button( Sprite_SelectorWindowType *d);static void Setup_List( Sprite_SelectorWindowType *d);static OSErr SortList( Sprite_SelectorWindowType *d, Boolean draw);static short CompareCellsByName( Ptr cell_a, long length_a, Ptr cell_b, long length_b);static short CompareCellsByID( Ptr cell_a, long length_a, Ptr cell_b, long length_b);GWorldPtr GWorld_Create( Rect *bounds);void DeleteSprite( Sprite_SelectorWindowType *d);void EZMakeSpriteFromID( heraScenarioFileType *heraFile, short resID,	Handle *spriteTable, spritePix *aSpritePix, char **pixData, long whichShape);void EZDrawSpriteCenteredInRectBySprite( spritePix *aSpritePix,	PixMapHandle pixBase, long thisScale, Rect *bounds);static void NPTMOptScaleSpritePixInPixMap( spritePix *sprite, Point where, long scale, longRect *dRect,		longRect *clipRect, PixMapHandle pixMap);static OSErr ChangeWhichSprite( Sprite_SelectorWindowType *d,	Boolean checkFirst);static void KeepChangedSprite( Sprite_SelectorWindowType *d);static void New_Sprite_Callback( long dispatchID, Handle newSprite);#pragma mark 본PRIVATE FUNCTIONS본/******************************************\|**| private functions\******************************************/static Boolean HandleEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID, long command){	switch( command)	{		case kWDCloseWindowCommand:			break;				case kWDProcessEventCommand:			return( ProcessEvent( theEvent, whichWindow, dispatchID));			break;				case kWDSaveWindowCommand:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these sprites?",										"\pBefore saving, the Sprite Selector "										"must be closed. Click Cancel to "										"abort the save.", nil, nil))				{					OK_Button_From_WindowID( whichWindow, dispatchID);				} else				{					gHera->currentSave = nil;				}			}			return false;			break;		case kWD_Close_ForQuit_Command:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( Button_Window_Modal( "\pSave changes to these sprites?",										"\pBefore quitting, the Sprite Selector "										"must be closed. Click Cancel to "										"abort the quit.", nil, nil))				{					OK_Button_From_WindowID( whichWindow, dispatchID);				} else				{					gHera->currentSave = nil;					return true;				}			}			return false;			break;		case kWDProcessMenuChoiceCommand:			return( ProcessMenuChoiceCommand( (unsigned long)theEvent,				whichWindow, dispatchID));			break;	}	return false;}static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	SignedByte						dataState;	Sprite_SelectorWindowType			*d;	Boolean							result = false;	GrafPtr							oldPort;	short							menuID = ((menuData & 0xffff0000) >> 16),									menuItem = (menuData & 0x0000ffff);										if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (Sprite_SelectorWindowType *)*data;	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);	result = Generic_ProcessMenuChoiceCommand( menuData, whichWindow,												dispatchID);	if ( result)	{		goto ProcessMenuChoiceCommand_Return;	}		switch( menuID)	{		case kEditMenuID:			switch( menuItem)			{				case kEdit_Undo_Item:					result = true;					break;				case kEdit_Add_Item:					result = true;					break;									case kEdit_Delete_Item:					result = true;					break;									case kEdit_Delete_All_Item:					result = true;					break;			}							break;		}	ProcessMenuChoiceCommand_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);}static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Boolean							result = false;	ControlHandle					aControl, oldControl;	short							whichPart, oldValue;	WindowPtr						scratchWindow;	Point							where;	char							whichChar;	GrafPtr							oldPort;	OSStatus						err;	Sprite_SelectorWindowType				*d;		if ( data == nil) return false;	if ( theEvent == nil) return false;		dataState = HGetState( data);	HLock( data);	d = (Sprite_SelectorWindowType *)*data;		if ( theEvent == nil) goto ProcessEvent_Return;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);		switch( theEvent->what)	{		case nullEvent:			IdleControls( (WindowPtr)whichWindow);			if ( d->animate)			{				long	currentTime = TickCount();								if ( ( currentTime < d->lastFrameTime) ||					(( currentTime - d->lastFrameTime) >=						kAnimation_Tick_Delay))				{					d->currentFrame++;					SampleSprite_Draw( whichWindow, d);					d->lastFrameTime = currentTime;				}			}			result = true;			break;					case updateEvt:				BeginUpdate ((WindowPtr)whichWindow);/*			SetPort( (WindowPtr)whichWindow);//			CalcVis( (WindowPtr)whichWindow);			UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);*/			HU_GenericUpdateEventHandler( whichWindow);			SampleSprite_Draw( whichWindow, d);			EndUpdate ((WindowPtr)whichWindow);			result = true;			break;		case activateEvt:		{			Boolean	isActive = ((theEvent->modifiers & activeFlag) != 0);						if ( isActive)			{				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_spriteFile_refNum);			}		}			oldValue = ((theEvent->modifiers & activeFlag) != 0);			if ( oldValue)			{				aControl = nil;				err = GetRootControl( (WindowPtr)whichWindow, &aControl);				if (( err == noErr) && ( aControl != nil))				{					ActivateControl( aControl);					SampleSprite_Draw( whichWindow, d);					result = true;				}			}			break;					case mouseDown:			whichPart = FindWindow (theEvent->where, &scratchWindow);			switch( whichPart)			{				case inGrow:/*					{						Rect	growRect;						long	newSize;//						growRect = qd.screenBits.bounds;						C2C_ScreenBits_GetBounds( &growRect);						growRect.top = growRect.left = 120;						newSize = GrowWindow((WindowPtr)whichWindow,							theEvent->where ,&growRect);						if (newSize != 0)						{							SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,								(((newSize) >> 16) & 0xFFFF), true );							EraseRect(&whichWindow->portRect);							InvalRect( &whichWindow->portRect);						}					}*/					HU_GenericGrowWindow( whichWindow, theEvent->where);					result = true;					break;								case inContent:					where = theEvent->where;					scratchWindow = WD_FrontWindow();					if ( whichWindow != (CWindowPtr)scratchWindow)					{						goto ProcessEvent_Return;					}					SetPortWindowPort( (WindowPtr)whichWindow);					GlobalToLocal( &where);					whichPart = FindControl( where, (WindowPtr)whichWindow,						&aControl);					if ( aControl == nil)						goto ProcessEvent_Return;					oldValue = GetControlValue( aControl);					err = GetKeyboardFocus( (WindowPtr)whichWindow, &oldControl);					if (( err == noErr) && ( oldControl != aControl))					{						SetKeyboardFocus( (WindowPtr)whichWindow, aControl, whichPart);					}					if ( whichPart != 0)					{						huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);//						whichPart = HandleControlClick ( aControl, where,//							theEvent->modifiers, nil);							if ( !ListBox_Appearance_1_0_1_Hack( aControl, where,									&whichPart))						{							whichPart = HUI_Control_Click_Handle( hui, where,								theEvent->modifiers);														}						if ( whichPart != kControlNoPart) switch( hui->generic.id)						{							case kOK_Button_ID:								result = true;								OK_Button( d);								data = nil;								goto ProcessEvent_Return;								break;														case kCancel_Button_ID:								Cancel_Button( d);								data = nil;								result = true;								goto ProcessEvent_Return;								break;															case kRevert_Button_ID:								Revert_Button( d);								break;															case kList_SortBy_Menu_ID:								oldValue = d->sortBy;																d->sortBy = HUI_Control_GetValueShort(									d->master, 0, kList_Button_Cell_X,									kList_Button_Cell_Y, kList_SortBy_Menu_ID);																	if ( d->sortBy != oldValue)								{									SortList( d, true);								}								result = true;								break;															case kList_ID:								UpdateListSelection( d, false);								result = true;								break;														case kList_Add_Button_ID:							{								FSSpec	theFile;								OSErr	error;								error = SmartFile_SelectFile( &theFile, 300);																if ( error == noErr)									Sprite_Importer_NewWindow( d->heraFile,									"\pImport Sprite",									&theFile, dispatchID, New_Sprite_Callback);															}								result = true;								break;															case kList_Remove_Button_ID:								if ( HU_Confirm_Delete("\pAre you sure you "									"want to delete this sprite?",										theEvent->modifiers))									DeleteSprite( d);								result = true;								break;															case kMain_Preview_CheckBox:								ReverseCheckBox( aControl);								if ( GetControlValue( aControl))								{									d->animate = true;									d->lastFrameTime = 0;									d->currentFrame = 0;								} else								{									d->animate = false;//									d->currentFrame = 0;								}																result = true;								break;															case kMain_Light_Background_CheckBox:								ReverseCheckBox( aControl);								if ( GetControlValue( aControl))								{									d->lightBackground = true;								} else								{									d->lightBackground = false;								}								SampleSprite_Draw( whichWindow, d);																result = true;								break;														case kMain_Scale_Menu:								switch( GetControlValue( aControl))								{									case 1:										d->scale = SCALE_SCALE;										break;																		case 2:										d->scale = kTimesTwoScale;										break;																		case 3:										d->scale = kTimesTwoScale * 2;										break;								}								SampleSprite_Draw( whichWindow, d);								result = true;								break;															default:								break;						}					} else // not in control					{						where = theEvent->where;						GlobalToLocal( &where);					}			}			break;					case keyDown:		case autoKey:			whichChar = theEvent->message & charCodeMask;			if ((whichChar=='\r' || whichChar==0x3))			{				// ok				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kOK_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);					result = true;					OK_Button( d);					data = nil;					goto ProcessEvent_Return;				}			} else if ((whichChar==0x1b) || ((whichChar=='.') && (theEvent->modifiers & cmdKey)))			{				// cancel				long			soon = TickCount()+5;								aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,					kButton_Cell_Y, kCancel_Button_ID);				if ( aControl != nil)				{					ActivateControl( aControl);					while ( TickCount() < soon){ /* do nothing */}					DeactivateControl( aControl);										Cancel_Button( d);					data = nil;					result = true;					goto ProcessEvent_Return;				}			} else if ( whichChar == '\t')			{				if ( theEvent->modifiers & shiftKey)					ReverseKeyboardFocus( (WindowPtr)whichWindow);				else					AdvanceKeyboardFocus( (WindowPtr)whichWindow);				result = true;				break;			} else if (( whichChar == 0x08) && ( !d->chooseOnly) &&					( !d->ownedByFactory))			{				huiPlainControlType	*hui = nil;				err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);				hui = (huiPlainControlType	*)CU_GetControlReference( aControl);				if ( hui != nil)				{					if ( hui->generic.id == kList_ID)					{						if ( HU_Confirm_Delete("\pAre you sure you "							"want to delete this sprite?",								theEvent->modifiers))							DeleteSprite( d);					}				}				result = true;			}						err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);			if (( err == noErr) && ( aControl != nil))			{				whichPart = HandleControlKey( aControl,					(theEvent->message & keyCodeMask)>>16,					theEvent->message & charCodeMask, theEvent->modifiers);				{					huiGenericControlType *hui =						(huiGenericControlType *)CU_GetControlReference( aControl);										if ( hui->kind != hui_ScrollTextControl) whichPart =						kControlNoPart;										switch( hui->id)					{						case kList_ID:								UpdateListSelection( d, false);								result = true;							break;					}				}			}			break;	}		ProcessEvent_Return:	SetPort( oldPort);	if ( data != nil)		HSetState( data, dataState);	return( result);	}static void SampleSprite_Draw( CWindowPtr window, Sprite_SelectorWindowType *d){	ControlHandle	aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X,						kMain_Cell_Y, kMain_Sprite);	spritePix		aSpritePix;	Handle			spriteTable = nil;	char			*pixData;	CGrafPtr		originalWorld, windowPort;	GDHandle		originalDevice;	PixMapHandle	offPixBase = nil;	Rect			bounds, destBounds, controlBounds;	RGBColor		c;	Point			spriteLocation;	if ( aControl == nil) return;	if ( d->spriteWorld == nil) return;		GetGWorld( &originalWorld, &originalDevice);	SetGWorld( d->spriteWorld, nil);	c.red = c.blue = c.green = 0;	RGBForeColor ( &c);	c.red = c.blue = c.green = 65535;	RGBBackColor( &c);	offPixBase = GetGWorldPixMap( d->spriteWorld);	bounds = (**offPixBase).bounds;		if ( d->lightBackground)	{		c.red = c.blue = c.green = 65535;		RGBForeColor ( &c);	}	PaintRect( &bounds);	if ( d->lightBackground)	{	c.red = c.blue = c.green = 0;		RGBForeColor ( &c);	}	EZMakeSpriteFromID( d->heraFile, d->resID, &spriteTable, &aSpritePix, &pixData,		d->currentFrame);		if ( spriteTable != nil)	{		longRect	dRect, spriteRect;				dRect.left = bounds.left;		dRect.right = bounds.right;		dRect.top = bounds.top;		dRect.bottom = bounds.bottom;//		EZDrawSpriteCenteredInRectBySprite( &aSpritePix, offPixBase, d->scale,//			&bounds);		spriteLocation.h = ((bounds.right - bounds.left) / 2);		spriteLocation.v = ((bounds.bottom - bounds.top) / 2);		NPTMOptScaleSpritePixInPixMap( &aSpritePix, spriteLocation,			d->scale, &spriteRect, &dRect, offPixBase);		DisposeHandle( spriteTable);	}		SetGWorld( originalWorld, originalDevice);		c.red = c.blue = c.green = 0;	RGBForeColor ( &c);	c.red = c.blue = c.green = 65535;	RGBBackColor( &c);	destBounds = bounds;//	OffsetRect( &destBounds, (((**aControl).contrlRect.right -//				(**aControl).contrlRect.left) / 2) - aSpritePix.center.h +//				(**aControl).contrlRect.left,//				(((**aControl).contrlRect.bottom -//				(**aControl).contrlRect.top) / 2) - aSpritePix.center.v +//				(**aControl).contrlRect.top);//	CenterRectInRect( &destBounds, &bounds);	CU_GetControlBounds( aControl, &controlBounds);	OffsetRect( &destBounds, controlBounds.left,		controlBounds.top);					DrawThemeGenericWell(&controlBounds, kThemeStateActive, false);	if ( d->lightBackground)	{		c.red = c.blue = c.green = 65535;		RGBForeColor ( &c);	}	PaintRect( &controlBounds);	if ( d->lightBackground)	{	c.red = c.blue = c.green = 0;		RGBForeColor ( &c);	}	windowPort = GetWindowPort( window);#ifndef TARGET_API_MAC_CARBON		CopyBits( (BitMap *)*offPixBase, &(((WindowPtr)window)->portBits), &bounds,		&destBounds, srcCopy, nil);#else	mAssert( windowPort != nil);	CopyBits( (BitMap *)*offPixBase, GetPortBitMapForCopyBits( windowPort), &bounds,		&destBounds, srcCopy, nil);#endif TARGET_API_MAC_CARBON}static Boolean UpdateListSelection( Sprite_SelectorWindowType *d,	Boolean forceUpdate){	long	oldValue, newValue;	short	resID;		oldValue = d->index;	newValue =  HUI_Control_GetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->index);	if (( oldValue != newValue) || ( forceUpdate))	{				if ( IsIDSpriteLegal( d, &resID))			ChangeWhichSprite( d, true);		else		{			d->index =  HUI_Control_SetListValue(					d->master, 0, kList_Cell_X, kList_Cell_Y,					kList_ID, oldValue);			HUI_Control_SetFocus( d->master, 0,				kMain_Cell_X, kMain_Cell_Y, kMain_SpriteID);			BP_UserError_Literal("Illegal value",				"%s%d%s", "The resource ID ", resID,				" is already in use. Please enter a"				" different ID.");			return false;		}	}		return true;}static void CenterRectInRect( Rect *bigRect, Rect *rect){	int			w, h;		w = rect->right - rect->left;	h = rect->bottom - rect->top;	rect->left =  bigRect->left + ( bigRect->right - bigRect->left) / 2 -			(w / 2);	rect->top = bigRect->top + ( bigRect->bottom - bigRect->top) / 2 -		(h / 2);	rect->right = rect->left + w;	rect->bottom = rect->top + h;}static void New_Sprite_Callback( long dispatchID, Handle newSprite){	Handle						windowData =									GetDispatchWindowDataHandle( dispatchID);	SignedByte					dataState;	Sprite_SelectorWindowType	*d;	short						id;	ControlHandle				aControl;	ListHandle					list;	Ptr							data = nil;	Str255						ids;	Point						cell;	long						dataLength;		if ( windowData == nil) return;	if ( newSprite == nil) return;		dataState = HGetState( windowData);	HLock( windowData);	d = (Sprite_SelectorWindowType *)*windowData;		HSetState( windowData, dataState);	id = GetCellData( d, d->index, nil, nil);	HRT_AddNewResource( d->heraFile, newSprite, 'SMIV', &id, "\p<untitled>");	DisposeHandle( newSprite);		aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			NumToString( id, ids);			data = PsuedoColumn_Data_Make( &dataLength,				d->lastAllotedReferenceNum++, ids, "\p\t", "\p<untitled>", "\p");			if ( data != nil)			{				LAddRow( 1, (**list).dataBounds.bottom, list );				cell.h = 0;				cell.v = (**list).dataBounds.bottom - 1;				LSetCell( data, dataLength, cell, list );				DisposePtr( data);				data = nil;				HUI_Control_SetListValue( d->master, 0, kList_Cell_X,					kList_Cell_Y, kList_ID, (**list).dataBounds.bottom - 1);				SortList( d, true);			} else				goto New_Sprite_Callback_error;		} else			goto New_Sprite_Callback_error;	} else		goto New_Sprite_Callback_error;	HLock( windowData);	d = (Sprite_SelectorWindowType *)*windowData;	ChangeWhichSprite( d, false);		HSetState( windowData, dataState);		// the list should be sorted after calling this, but not before	// 1st calling update list selection	return;New_Sprite_Callback_error://	if ( newText != nil) DisposePtr( (Ptr)newText);	if ( data != nil) DisposePtr( data);	}static Boolean IsIDSpriteLegal( Sprite_SelectorWindowType *d, short *theID){	ControlHandle	aControl;		/* to determine if id is legal:		0.	legal if unchanged from original		1.	illegal if any newText has the same current id;		2.	illegal if any TEXT resource of same id exists AND there is no			newText with same original id			(there could be a newText with same original id and same current id,			but we ruled those out in 1)	*/	aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X,					kMain_Cell_Y, kMain_SpriteID);	if ( aControl != nil)	{		*theID = GetControlTextItemLong( aControl);	} else	{		*theID = 0;		return false;	}	// if unchanged, is legal, exit	if ( *theID == d->currentOriginalResID) return true;	return ( HRT_IsIDLegal( d->heraFile, 'SMIV', *theID));}static OSErr ChangeWhichSprite( Sprite_SelectorWindowType *d,	Boolean checkFirst){	ControlHandle		aControl;	Handle				keepSprite, newSprite;	Str255				s;	short				theID, oldResRefNum, originalResID, resOwnerRefNum;	CWindowPtr			window;	#pragma unused( checkFirst, newSprite)	oldResRefNum = CurResFile();//	UseResFile( d->resRefNum);	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_spriteFile_refNum);	s[0] = 0;		mAssert( d != nil);		if ( checkFirst)		KeepChangedSprite( d);		d->index = HUI_Control_GetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->index);	mAssert( d->index >= 0);			// get the id by looking it up in the list	theID = GetCellData( d, d->index, &d->currentReferenceNum, nil);	d->resID = theID;			keepSprite = HRT_Resource_GetHandle_WithOwnerFile( d->heraFile, 'SMIV',		theID, &originalResID, &resOwnerRefNum, s);	if ( keepSprite == nil)	{	} else	{		d->currentOriginalResID = theID;	}/*	aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X - d->columnFix,					kMain_Cell_Y, kMain_TEXT);	if ( aControl != nil)	{		text = HUI_ScrollText_GetFromControl( aControl);		if ( text != nil)		{			HUI_ScrollText_Reset( (huiScrollTextControlType *)CU_GetControlReference( aControl));			TESetSelect( 0, 32767, text);			TEDelete( text);			newSprite = keepSprite;			if ( newSprite != nil)			{				HLock( newSprite);				TESetText( *newSprite, GetHandleSize( newSprite), text);				HUnlock( newSprite);				Draw1Control( aControl);			}		}	}*/	d->resID = theID;		aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X,					kMain_Cell_Y, kMain_SpriteTitle);	if ( aControl != nil)	{		SetControlTextItemString( aControl, s);		Draw1Control( aControl);	}	aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X,					kMain_Cell_Y, kMain_SpriteID);	if ( aControl != nil)	{		NumToString( theID, s);		SetControlTextItemString( aControl, s);		Draw1Control( aControl);	}	if ( resOwnerRefNum != d->heraFile->fileRefNum)	{		d->ownedByFactory = true;		HUI_Control_Hilite( d->master, 0, kList_Button_Cell_X,			kList_Button_Cell_Y, kList_Remove_Button_ID, 0);		HUI_Control_Hilite( d->master, 0, kMain_Cell_X,			kMain_Cell_Y, kMain_SpriteTitle, 0);		HUI_Control_Hilite( d->master, 0, kMain_Cell_X,			kMain_Cell_Y, kMain_SpriteID, 0);	} else	{		d->ownedByFactory = false;		HUI_Control_Hilite( d->master, 0, kList_Button_Cell_X,			kList_Button_Cell_Y, kList_Remove_Button_ID, 1);		HUI_Control_Hilite( d->master, 0, kMain_Cell_X,			kMain_Cell_Y, kMain_SpriteTitle, 1);		HUI_Control_Hilite( d->master, 0, kMain_Cell_X,			kMain_Cell_Y, kMain_SpriteID, 1);	}	if ( keepSprite != nil) DisposeHandle( keepSprite);	UseResFile( oldResRefNum);		window = GetWindowPtrFromDispatchWindowID( d->windowID);	SampleSprite_Draw( window, d);	return noErr;	}static void KeepChangedSprite( Sprite_SelectorWindowType *d){	ControlHandle		aControl;	Str255				newTitle;	short				originalResID = -1, newID, oldResRefNum;	Boolean				different = false, titleDifferent = false,						idDifferent = false;	unsigned long		spriteChanges = 0;	Handle				spriteTable;		mAssert( d != nil);		aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X,					kMain_Cell_Y, kMain_SpriteID);	if ( aControl != nil)	{		newID = GetControlTextItemLong( aControl);	}//	aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X,//					kMain_Cell_Y, kMain_TEXT);//	if ( aControl != nil)	{		// get the TEHandle//		text = HUI_ScrollText_GetFromControl( aControl);//		if ( text != nil)		{			// get the text of the TEHandle//			newText = (Handle)TEGetText( text);			spriteTable = HRT_Resource_GetHandle( d->heraFile, kPixResType,				d->resID, nil, nil);//			if ( newText != nil)			{				aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X,								kMain_Cell_Y, kMain_SpriteTitle);				if ( aControl != nil)				{					GetControlTextItemString( aControl, newTitle);				}								oldResRefNum = CurResFile();				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_spriteFile_refNum);				spriteChanges = HRT_KeepChangedResource( d->heraFile, spriteTable, 					kPixResType, d->currentOriginalResID, newID, newTitle);				UseResFile( oldResRefNum);									// make changes to list//				if ( d->chooseRes)				{					Ptr		data;					Str255	ids;					long	dataLength;										NumToString( newID, ids);					data = PsuedoColumn_Data_Make( &dataLength,						d->currentReferenceNum, ids, "\p\t",						newTitle, "\p");					if ( data != nil)					{						HUI_Control_SetListCell( d->master, 0, kList_Cell_X,							kList_Cell_Y, kList_ID, 0, d->index, data,							dataLength);						HUI_Control_Draw( d->master, 0, kList_Cell_X,							kList_Cell_Y, kList_ID);						DisposePtr( data);					}					// we have to resort if the relevant field has been changed					if ( ((spriteChanges & kHRT_ResourceDifferenceFlag_Title) &&						( d->sortBy == kSortByName)) ||						(( spriteChanges & kHRT_ResourceDifferenceFlag_ID) &&						( d->sortBy == kSortByID)))					{						SortList( d, true);					}				}			}		}	}}static short GetCellData( Sprite_SelectorWindowType *d, short spriteIndex,	long *referenceNumber, StringPtr title){	ControlHandle		aControl;	Str255				s;	ListHandle			list;	short				result = -1;	mAssert( d != nil);			aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			long	tl;			short	length;			Ptr		data = List_Utilities_GetCell( list, (Point){spriteIndex, 0}, &length);						if ( data != nil)			{				PsuedoColumn_String_GetAll( data, length, referenceNumber, s, title, -1);								DisposePtr( data);				StringToNum( s, &tl);				result = tl;			}		}	}	return result;}static void Setup_List( Sprite_SelectorWindowType *d){	short						oldResRefNum = 0;	ControlHandle				aControl;	ListHandle					list;	long						spriteNum = 0;		if ( d == nil) return;	oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_spriteFile_refNum);			spriteNum = CountResources('SMIV');	aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Cell		cell;				GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			short		i = 1, count = spriteNum, theID, resHomeFile,						tempHomeFile;			Str255		ids, ns;			Handle		sprite;			ResType		theType;			Ptr			data = nil;			long		dataLength;			Boolean		done = false, dataExists;			newResourceType	*hrtPtr = nil;						LDelRow( 0, 0, list);	// delete all rows			(*list)->selFlags = lOnlyOne;						spriteNum = 0;			cell.h = 0;			do			{				dataExists = false;				if ( count > 0)				{					sprite = GetIndResource( 'SMIV', i);					if ( sprite != nil)					{						GetResInfo( sprite, &theID, &theType, ns);						resHomeFile = HomeResFile( sprite);						ReleaseResource( sprite);						if (( theID > 0) &&							( mResOwner_IsOK( resHomeFile, d->heraFile)))						{							HRT_Resource_GetChanges( d->heraFile, 'SMIV', &theID, ns);														if ( theID > 0)								sprite = HRT_Resource_GetHandle_WithOwnerFile(										d->heraFile, 'SMIV', theID, nil,										&tempHomeFile, nil);							else								sprite = nil;														if ( sprite != nil)							{								DisposeHandle( sprite);								if ( tempHomeFile == resHomeFile)									dataExists = true;							}						}					}					count--;				} else				{					hrtPtr = HRT_Resource_GetNextNew( d->heraFile, 'SMIV', hrtPtr, &theID,						ns);					if ( hrtPtr == nil)					{						done = true;					} else dataExists = true;				}				if ( dataExists)				{												NumToString( theID, ids);						if ( ns[0] == 0) pstrcpy( ns, "\p<untitled>");												data = PsuedoColumn_Data_Make( &dataLength,							d->lastAllotedReferenceNum++, ids, "\p\t", ns, "\p");				} else data = nil;				if ( data != nil)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.v = (**list).dataBounds.bottom - 1;					LSetCell( data, dataLength, cell, list );					DisposePtr( data);					data = nil;					spriteNum++;				}				i++;			} while (!done);		}	}	if ( d->index >= spriteNum) d->index = spriteNum - 1;	d->index = HUI_Control_SetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, d->index);	{		OSErr err =			List_Utilities_QSort( list, (Point){0, 0}, (Point){spriteNum - 1, 0},				CompareCellsByID);			if ( err != noErr) SysBeep(20);	}//	SortList( d, false);	Setup_List_error:		UseResFile( oldResRefNum);}static OSErr SortList( Sprite_SelectorWindowType *d, Boolean draw){	short			currentSelectionIndex = 0, dataLength = 0;	long			currentSelectionReference = 0, i = 0, thisReference;	Ptr				data = nil;	OSErr			err = noErr;	ControlHandle	aControl = nil;	ListHandle		list = nil;	Boolean 		done, found;		// in order to preserve the selection,	// we have to get it's arbitrary reference #		currentSelectionIndex =  HUI_Control_GetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->index);		aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);			if ( aControl == nil) return paramErr;	GetListBoxListHandle( aControl, &list);		if ( list == nil) return paramErr;		data = List_Utilities_GetCell(list, (Point){currentSelectionIndex, 0},		&dataLength);		if ( data == nil) return memFullErr;		PsuedoColumn_String_GetAll( data, dataLength,		&currentSelectionReference, (StringPtr)-1);	DisposePtr( data);		if ( d->sortBy == kSortByName)		err = List_Utilities_QSort( list, (Point){0, 0},			(Point){(**list).dataBounds.bottom - 1, 0},			CompareCellsByName);	else if ( d->sortBy == kSortByID)		err = List_Utilities_QSort( list, (Point){0, 0},			(Point){(**list).dataBounds.bottom - 1, 0},			CompareCellsByID);		// now we have to find our selection; we may as well start with its original	// position		done = found = false;	i = 0;		while (( !done) && ( !found))	{		if ( (currentSelectionIndex + i) < (**list).dataBounds.bottom)		{			data = List_Utilities_GetCell(list, (Point){currentSelectionIndex + i, 0},				&dataLength);			if ( data != nil)			{				PsuedoColumn_String_GetAll( data, dataLength,					&thisReference, (StringPtr)-1);								if ( thisReference == currentSelectionReference)				{					found = true;					currentSelectionIndex = currentSelectionIndex + i;				}				DisposePtr( data);			}		} else done = true;		if ( (currentSelectionIndex - i) >= 0)		{			data = List_Utilities_GetCell(list, (Point){currentSelectionIndex - i, 0},				&dataLength);			if ( data != nil)			{				PsuedoColumn_String_GetAll( data, dataLength,					&thisReference, (StringPtr)-1);								if ( thisReference == currentSelectionReference)				{					found = true;					currentSelectionIndex = currentSelectionIndex - i;				}				DisposePtr( data);			}			done = false;		} else		{			// do nothing; if done was previously true, keep it true			// if it was false, keep it false		}		i++;	}	d->index = HUI_Control_SetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, currentSelectionIndex);	LAutoScroll( list);	if ( draw) Draw1Control( aControl);		return err;}static short CompareCellsByName( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	name_a, name_b;	long	result;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, nil, name_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, nil, name_b, -1);	result = pstrcmp_nocase( name_a, name_b);	return -result;}static short CompareCellsByID( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	id_string_a, id_string_b;	long	id_a, id_b;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, id_string_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, id_string_b, -1);	StringToNum( id_string_a, &id_a);	StringToNum( id_string_b, &id_b);	if ( id_a < id_b)	{		return 1;	} else if ( id_a > id_b)	{		return -1;	} else	{		return 0;	}}static void OK_Button_From_WindowID( CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Sprite_SelectorWindowType		*d;#pragma unused( whichWindow)	if ( data == nil) return;		dataState = HGetState( data);	HLock( data);	d = (Sprite_SelectorWindowType *)*data;	OK_Button( d);	// data has been deleted; window is closed}static void OK_Button( Sprite_SelectorWindowType *d){	if ( d->isModal) gHera->modalMode--;	UpdateListSelection( d, true);	if ( d->callBack != nil) d->callBack( d->callerID, d->resID);	HUI_MasterControl_Delete( d->master);	CloseDispatchWindow( d->windowID);}static void Cancel_Button( Sprite_SelectorWindowType *d){	if ( d->isModal) gHera->modalMode--;	HUI_MasterControl_Delete( d->master);	CloseDispatchWindow( d->windowID);}static void Revert_Button( Sprite_SelectorWindowType *d){	CWindowPtr whichWindow = GetWindowPtrFromDispatchWindowID( d->windowID);		if ( whichWindow == nil) return;	if ( !Button_Window_Modal( "\pRevert this sprite?",							"\pClick Revert to restore this sprite to its "							"previous state. Click Cancel to "							"keep it as it is.", "\pRevert", nil))		return;	ChangeWhichSprite( d, false);}void DeleteSprite( Sprite_SelectorWindowType *d){	long			id;		mAssert( d != nil);	// 1st get our current id	id = GetCellData( d, d->index, nil, nil);		if ( id < 0) return;		HRT_DeleteResource( d->heraFile, 'SMIV', id);		HUI_Control_DeleteListRows(		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, 1, d->index);	d->index = HUI_Control_SetListValue(		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID, d->index);	ChangeWhichSprite( d, false);}/* EZMakeSpriteFromID	Given resID, loads resource into spriteTable and fills out aSpritePix.	spriteTable is locked and unlocking it invalidates aSpritePix->pixData.	Note that, unfortunately, you have to keep the pixData ptr alive.*/void EZMakeSpriteFromID( heraScenarioFileType *heraFile, short resID,	Handle *spriteTable, spritePix *aSpritePix, char **pixData, long whichShape){	*spriteTable = HRT_Resource_GetHandle( heraFile, kPixResType, resID, nil, nil);	if ( *spriteTable == nil) return;	HLock( *spriteTable);	whichShape %= GetNatePixTablePixNum( *spriteTable);	*pixData = GetNatePixTableNatePixData( *spriteTable, whichShape);		aSpritePix->data = pixData;	aSpritePix->center.h = GetNatePixTableNatePixHRef( *spriteTable, whichShape);	aSpritePix->center.v = GetNatePixTableNatePixVRef( *spriteTable, whichShape);	aSpritePix->width = GetNatePixTableNatePixWidth( *spriteTable, whichShape);	aSpritePix->height = GetNatePixTableNatePixHeight( *spriteTable, whichShape);}void EZDrawSpriteCenteredInRectBySprite( spritePix *aSpritePix,	PixMapHandle pixBase, long thisScale, Rect *bounds){	coordPointType		coord;	long				tlong;	Point				where;	longRect			dRect, spriteRect;		dRect.left = bounds->left;	dRect.right = bounds->right;	dRect.top = bounds->top;	dRect.bottom = bounds->bottom;		coord.h = aSpritePix->center.h;	coord.h *= thisScale;	coord.h >>= SHIFT_SCALE;	tlong = aSpritePix->width;	tlong *= thisScale;	tlong >>= SHIFT_SCALE;	where.h = ( (bounds->right - bounds->left) / 2) - ( tlong / 2);	where.h += dRect.left + coord.h;	coord.v = aSpritePix->center.v;	coord.v *= thisScale;	coord.v >>= SHIFT_SCALE;	tlong = aSpritePix->height;	tlong *= thisScale;	tlong >>= SHIFT_SCALE;	where.v = ( (bounds->bottom - bounds->top) / 2) - ( tlong / 2);	where.v += dRect.top + coord.v;			// draw the sprite	NPTMOptScaleSpritePixInPixMap( aSpritePix, where, thisScale,			&spriteRect, &dRect, pixBase);}static void NPTMOptScaleSpritePixInPixMap( spritePix *sprite, Point where, long scale, longRect *dRect,		longRect *clipRect, PixMapHandle pixMap){	long		mapWidth, mapHeight, x, y, i, h, v, d, last;	long		shapeRowPlus, destRowPlus, rowbytes, *hmap, *vmap, *hmapoffset, *lhend,				scaleCalc;	char		*destByte, *shapeByte, *hend, *vend, *chunkByte;	Boolean		clipped;// = FALSE;	longRect	mapRect, sourceRect;		scaleCalc = ((long)sprite->width * scale);	scaleCalc >>= SHIFT_SCALE;	mapWidth = scaleCalc;	scaleCalc = ((long)sprite->height * scale);	scaleCalc >>= SHIFT_SCALE;	mapHeight = scaleCalc;	if ((( where.h + (int)mapWidth) > clipRect->left) && (( where.h -(int) mapWidth) <			clipRect->right) && (( where.v + (int)mapHeight) > clipRect->top) &&			(( where.v - (int)mapHeight < clipRect->bottom)) && ( mapHeight > 0) &&			( mapWidth > 0))	{		scaleCalc = (long)sprite->center.h * scale;		scaleCalc >>= SHIFT_SCALE;		dRect->left = where.h - (int)scaleCalc;		scaleCalc = (long)sprite->center.v * scale;		scaleCalc >>= SHIFT_SCALE;		dRect->top = where.v - (int)scaleCalc;				mapRect.left = mapRect.top = 0;		mapRect.right = mapWidth;		mapRect.bottom = mapHeight;		dRect->right = dRect->left + mapWidth;		dRect->bottom = dRect->top + mapHeight;		sourceRect.left = sourceRect.top = 0;		sourceRect.right = sprite->width;		sourceRect.bottom = sprite->height;				if ( dRect->left < clipRect->left)		{			mapRect.left += clipRect->left - dRect->left;			dRect->left = clipRect->left;			clipped = TRUE;		}		if ( dRect->right > clipRect->right)		{			mapRect.right -= dRect->right - clipRect->right;// + 1;			dRect->right = clipRect->right;// - 1;			clipped = TRUE;		}		if ( dRect->top < clipRect->top)		{			mapRect.top += clipRect->top - dRect->top;			dRect->top = clipRect->top;			clipped = TRUE;		}		if ( dRect->bottom > clipRect->bottom)		{			mapRect.bottom -= dRect->bottom - clipRect->bottom;// + 1;			dRect->bottom = clipRect->bottom;// - 1;			clipped = TRUE;		}		if (( (dRect->left + 1) < clipRect->right) && ( dRect->right > clipRect->left) &&				( dRect->top < clipRect->bottom) && ( dRect->bottom > clipRect->top))		{			if ( scale <= SCALE_SCALE)			{				h = sprite->width - 1;				v = ( mapWidth - 1) << 1;				d = v - h;				h = v - ( h << 1);				x = y = i = last = 0;				hmap = gHera->scaleHMap;				if ( v == 0) v = 1;								while (( x < sprite->width) || ( y < mapWidth))				{					x++;					i++;					if ( d > 0)					{						*hmap = ( x - (i >> 1L)) - last;						last += *hmap;						i = 0;						y++;						hmap++;						d += h;					} else d += v;				}				*hmap = sprite->width - last;								h = sprite->height - 1;				v = ( mapHeight - 1) << 1;				d = v - h;				h = v - ( h << 1);				x = y = i = last = 0;				vmap = gHera->scaleVMap;				if ( v == 0) v = 1;								while (( x < sprite->height) || ( y < mapHeight))				{					x++;					i++;					if ( d > 0)					{						*vmap = ( x - ( i >> 1L)) - last;						last += *vmap;						i = 0;						y++;						vmap++;						d += h;					} else d += v;				}								*vmap = sprite->height - last;								if ( clipped)				{					sourceRect.left = 0;					hmap = gHera->scaleHMap;					d = mapRect.left;					while ( d > 0) { sourceRect.left += *hmap++; d--;}										sourceRect.right = sourceRect.left;					d = mapRect.right - mapRect.left + 1;					while ( d > 0) { sourceRect.right += *hmap++; d--;}										sourceRect.top = 0;					vmap = gHera->scaleVMap;					d = mapRect.top;					while ( d > 0) { sourceRect.top += *vmap++; d--;}										sourceRect.bottom = sourceRect.top;					d = mapRect.bottom - mapRect.top + 1;					while ( d > 0) { sourceRect.bottom += *vmap++; d--;}														} // otherwise sourceRect is set									scaleCalc = (dRect->right - dRect->left);//				rowbytes = 0x0000ffff & (long)((*pixMap)->rowBytes ^ ROW_BYTES_MASK);				rowbytes = (long)(*pixMap)->rowBytes;				rowbytes &= 0x0000ffff;				rowbytes |= 0x00008000;				rowbytes ^= 0x00008000;								destRowPlus = rowbytes - scaleCalc;				shapeRowPlus = (long)sprite->width - (sourceRect.right - sourceRect.left);												//KLUDGE ALERT				destByte = (*pixMap)->baseAddr + dRect->top * rowbytes + dRect->left;				shapeByte = *(sprite->data) + sourceRect.top * sprite->width + sourceRect.left;								vmap = gHera->scaleVMap + mapRect.top;				hmapoffset = gHera->scaleHMap + mapRect.left;				vend = destByte + rowbytes * (dRect->bottom - dRect->top);				y = dRect->bottom - dRect->top;								shapeRowPlus += *(hmapoffset + scaleCalc);				mapWidth = (long)sprite->width;				chunkByte = (*pixMap)->baseAddr + (long)((*pixMap)->bounds.bottom) * rowbytes;								// for debugging//				x = dRect->left;//				y = dRect->top;								do				{					hmap = hmapoffset;					hend = destByte + scaleCalc;					// for debugging//					x = dRect->left;//					TestByte( destByte);					do					{						if ( *shapeByte)							*destByte = *shapeByte;						#ifdef kByteLevelTesting						TestByte( (char *)destByte, *pixMap, "\pSMALLSP");#endif						//						// debugging												shapeByte += *hmap++;						destByte++;						//						// debugging//						if ( x > clipRect->right)//						{//							WriteDebugLine( (char *)"\pX:");//							WriteDebugLong( hend - destByte);//						}//						x++;					} while ( destByte < hend);					destByte += destRowPlus;										// debugging//					y++;//					if ( y > clipRect->bottom)//					{//						WriteDebugLine( (char *)"\pY:");//						WriteDebugLong( y);//					}										shapeByte += (*vmap++ - 1) * mapWidth + shapeRowPlus;				} while ( destByte < vend);			} else if ( scale <= MAX_SCALE)			{				h = mapWidth - 1;				v = ( sprite->width - 1) << 1;				d = v - h;				h = v - ( h << 1);				x = y = i = last = 0;				hmap = gHera->scaleHMap;				vmap = hmapoffset = nil;				while (( x < mapWidth - 1) || ( y < sprite->width - 1))				{					x++;					i++;					if ( d > 0)					{						*hmap = i;												i = 0;						y++;						hmap++;						d += h;					} else d += v;				}				*hmap = i + 1;								h = mapHeight - 1;				v = ( sprite->height - 1) << 1;				d = v - h;				h = v - ( h << 1);				x = y = i = last = 0;				vmap = gHera->scaleVMap;				hmapoffset = hmap = nil;				while (( x < mapHeight - 1) || ( y < sprite->height - 1))				{					x++;					i++;					if ( d > 0)					{						*vmap = i;												i = 0;						y++;						vmap++;						d += h;					} else d += v;				}				*vmap = i + 1;								if ( clipped)				{					sourceRect.left = h = 0;					hmap = gHera->scaleHMap;					while ( ( h + *hmap) < mapRect.left) { h += *hmap++; sourceRect.left++;}					x = *hmap;					*hmap -= mapRect.left - h;					h += x - *hmap;					sourceRect.right = sourceRect.left;					while ( ( h + *hmap) < mapRect.right) { h += *hmap++; sourceRect.right++;}					*hmap = mapRect.right - h;					sourceRect.right++;					sourceRect.top = h = 0;					vmap = gHera->scaleVMap;					while ( ( h + *vmap) < mapRect.top) { h += *vmap++; sourceRect.top++;}					x = *vmap;					*vmap -= mapRect.top - h;					h += x - *vmap;					sourceRect.bottom = sourceRect.top;					while ( ( h + *vmap) < mapRect.bottom) { h += *vmap++; sourceRect.bottom++;}					*vmap = mapRect.bottom - h;					if ( sourceRect.bottom < sprite->height) sourceRect.bottom++;				} // otherwise sourceRect is already set								scaleCalc = (dRect->right - dRect->left);				rowbytes = 0x0000ffff & (long)((*pixMap)->rowBytes ^ ROW_BYTES_MASK);				destRowPlus = rowbytes - scaleCalc;				destByte = (*pixMap)->baseAddr + dRect->top * rowbytes + dRect->left;				shapeByte = *(sprite->data) + sourceRect.top * (long)sprite->width + sourceRect.left;								vmap = gHera->scaleVMap + sourceRect.top;				hmapoffset = gHera->scaleHMap + sourceRect.left;				shapeRowPlus = sprite->width;				mapWidth = (long)sprite->width;				vend = *(sprite->data) + sourceRect.bottom * (long)sprite->width + sourceRect.left;				lhend = gHera->scaleHMap + sourceRect.right;								while ( shapeByte < vend)				{					v = *vmap;					while ( v > 0)					{						hmap = hmapoffset;						chunkByte = shapeByte; 						while ( hmap < lhend)						{							if (( *chunkByte) && ( *hmap))							{								for ( h = *hmap; h > 0; h--)									*destByte++ = *chunkByte;							} else destByte += *hmap;							hmap++;							chunkByte++;						}						destByte += destRowPlus;						v--;					}					vmap++;					shapeByte += shapeRowPlus;				}							} else dRect->left = dRect->right = dRect->top = dRect->bottom = 0;		} else dRect->left = dRect->right = dRect->top = dRect->bottom = 0;	} else dRect->left = dRect->right = dRect->top = dRect->bottom = 0;}#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/OSErr Sprite_Selector_NewWindow( heraScenarioFileType *heraFile,	StringPtr title, short resRefNum,	short resID, long callerID, Boolean modal,	Sprite_Selector_Callback_procPtr callBack){	Rect						bounds;	CWindowPtr					newWindow;	ControlHandle				rootControl, aControl;	huiPlainControlParamType	buttonParam, textParam;	huiMasterControlParamType	masterParam;	OSStatus					err;	Handle						data, strList;	Sprite_SelectorWindowType		*d;	long						maxWidth = 0;	long						windowID = -1;	huiCellParamType			cellParam;	GWorldPtr					spriteWorld;	ListHandle					list;	#pragma unused ( err, textParam, aControl)		bounds.left = bounds.top = 0;	bounds.right = MAX_PIX_SIZE;	bounds.bottom = kPix_Preview_Max_Height;//MAX_PIX_SIZE;	spriteWorld = GWorld_Create( &bounds);		// create the new window	data = NewHandle( sizeof( Sprite_SelectorWindowType));	if ( data == nil) return memFullErr;		HLock( data);	d = (Sprite_SelectorWindowType *)*data;	d->resRefNum = resRefNum;	d->currentReferenceNum = 0;	d->lastAllotedReferenceNum = 0;	d->index = 0;	d->sortBy = kSortByID;	d->spriteWorld = spriteWorld;	d->defaultResID = d->resID = d->currentOriginalResID = resID;	d->lastFrameTime = 0;	d->currentFrame = 0;	d->animate = false;	d->lightBackground = false;	d->scale = SCALE_SCALE;	d->isModal = modal;	d->callBack = callBack;	d->callerID = callerID;	d->heraFile = heraFile;	d->ownedByFactory = false;	if ( heraFile->fileRefNum <= 0) d->chooseOnly = true;	else d->chooseOnly = false;		SetRect( &bounds, 64, 64, 128, 128);	if ( modal)	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowMovableModalDialogProc, (WindowPtr)-1, false,			HandleEvent, 0,			&windowID);	} else	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowDocumentProc, (WindowPtr)-1, false,			HandleEvent, 0,			&windowID);	}	SetDispatchWindowDataHandle( windowID, data);	d->windowID = windowID;		SetThemeWindowBackground( (WindowPtr)newWindow,		kThemeActiveDialogBackgroundBrush, true);	SetPortWindowPort( (WindowPtr)newWindow);	CreateRootControl( (WindowPtr)newWindow, &rootControl);	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kRowNum;	masterParam.colNum = kColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = kSmallFontSize;	d->master = HUI_MasterControl_New( nil, 0, 0, 0, &masterParam);		mAssert( d->master != nil);	if ( d->master == nil) return memFullErr;	HUI_Master_ShowLayer( d->master, 0);	d->master->tab[0][0].h = 112;	d->master->tab[0][0].hAlign = hui_halign_right;	cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	// set up main cell	cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_top;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, 3, -1, 3);	SetRect( &cellParam.inSpace, -1, 12, -1, 3);	cellParam.colSpan = 1;	cellParam.rowSpan = 2;	HUI_Cell_Set( 0, kMain_Cell_X, kMain_Cell_Y, &cellParam);	// set up list cell	SetRect( &cellParam.outSpace, 12, 12, 3, 5);	SetRect( &cellParam.inSpace, 3, 3, 3, 3);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_right;	cellParam.minMaxBounds.top = 100;		HUI_Cell_Set( 0, kList_Cell_X, kList_Cell_Y, &cellParam);	cellParam.minMaxBounds.top = 0;	cellParam.minMaxBounds.top = 0;		// set up list button cells	SetRect( &cellParam.outSpace, 12, -1, 3, 3);	SetRect( &cellParam.inSpace, -1, -1, 3, 3);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.baseLine = gHera->smallFontSize;	cellParam.hAlign = hui_halign_center;	d->master->rowDontExpand[kList_Button_Cell_Y] = true;	HUI_Cell_Set( 0, kList_Button_Cell_X, kList_Button_Cell_Y, &cellParam);	cellParam.minMaxBounds.bottom = kHUI_Pixel_Max;	// set up buttons, general	buttonParam.master = d->master;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask | kControlUseJustMask;	buttonParam.fontStyle.font = kSmallFontNum;	buttonParam.fontStyle.size = kSmallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = teCenter;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;	buttonParam.flags = huiControlFlag_none;		// set up text, general	textParam.master = d->master;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = kControl_H_Space;//8;	textParam.space.top = 12;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = -1;	textParam.cellx = kMain_Cell_X;	textParam.celly = kMain_Cell_Y;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;	if ( d->chooseOnly) buttonParam.enabled = false;	if ( d->chooseOnly) textParam.enabled = false;		// sprite title		textParam.cellx = buttonParam.cellx = kMain_Cell_X;	textParam.celly = buttonParam.celly = kMain_Cell_Y;		textParam.id = kMain_SpriteTitle - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 1);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kMain_SpriteTitle;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextBigFieldWidth;	HUI_EditText_New_LiteralP( &textParam);		// sprite id		textParam.id = kMain_SpriteID - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 2);	textParam.minMaxBounds.left = 0;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kMain_SpriteID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.minMaxBounds.left = kEditTextFieldWidth;	HUI_EditText_New_LiteralP( &textParam);		buttonParam.id = kMain_Preview_CheckBox;	buttonParam.flags = huiControlFlag_newLine;	GetIndString( buttonParam.label, kStrResID, 3);	HUI_CheckBox_New_LiteralP( &buttonParam);	// preview animation		buttonParam.id = kMain_Light_Background_CheckBox;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kStrResID, 4);	buttonParam.space.left = 40;	HUI_CheckBox_New_LiteralP( &buttonParam);	buttonParam.space.left = 4;//8;		textParam.enabled = true;	buttonParam.enabled = true;		// preview scale menu label	textParam.id = kMain_Scale_Menu - 1;	textParam.flags = huiControlFlag_none;	GetIndString( textParam.label, kStrResID, 5);	textParam.minMaxBounds.left = 0;	textParam.space.left = 0;//8;	HUI_StaticText_New_LiteralP( &textParam);	textParam.space.left = kControl_H_Space;//8;	// preview scale menu		buttonParam.id = kMain_Scale_Menu;	buttonParam.cellx = kMain_Cell_X;	buttonParam.celly = kMain_Cell_Y;	buttonParam.special.menuStrList.strList = GetStringList( 8039);	buttonParam.special.menuStrList.menuID = HU_GetNewMenuID();//129;	buttonParam.flags = huiControlFlag_none;	buttonParam.space.left = 0;	GetIndString( buttonParam.label, kStrResID, 5); // apparent color	buttonParam.space.left = 4;	HUI_PopupButton_New_StrList( &buttonParam);	buttonParam.id = kMain_Sprite;	buttonParam.flags = huiControlFlag_newLine;//	buttonParam.flags = (huiControlFlagType )((int)huiControlFlag_newLine |//		(int)huiControlFlag_useCellH);	buttonParam.minMaxBounds.right = MAX_PIX_SIZE;	buttonParam.minMaxBounds.bottom = kPix_Preview_Max_Height;	HUI_UserPane_New_LiteralP( &buttonParam);	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// make selection list	buttonParam.id = kList_ID;	buttonParam.minMaxBounds.left = 160;	buttonParam.minMaxBounds.right = 160;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;//200;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.bottom = 200;	buttonParam.cellx = kList_Cell_X;	buttonParam.celly = kList_Cell_Y;	buttonParam.special.listBox.ldesResID = 130;	buttonParam.special.listBox.refCon = 131;	buttonParam.flags = (huiControlFlagType )((int)huiControlFlag_useCellV |		(int)huiControlFlag_useCellH);	HUI_ListBox_New_LiteralP( &buttonParam);		buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// set up list buttons		// sort by menu		buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	textParam.cellx =  kList_Button_Cell_X;	textParam.celly =  kList_Button_Cell_Y;	textParam.id = kList_SortBy_Menu_ID - 1;	textParam.flags = huiControlFlag_newLine;	GetIndString( textParam.label, kHera_AppStrResID, 12);	textParam.minMaxBounds.left = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	HUI_StaticText_New_LiteralP( &textParam);	textParam.id = kList_SortBy_Menu_ID;	textParam.flags = huiControlFlag_none;	textParam.label[0] = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;		strList = GetStringList( 8032);	if ( strList != nil)	{		textParam.special.menuStrList.strList = strList;		textParam.special.menuStrList.menuID = HU_GetNewMenuID();		textParam.minMaxBounds.right = kHUI_Pixel_Max;		textParam.minMaxBounds.left = 0;		HUI_PopupButton_New_StrList( &textParam);		ReleaseResource( strList);		textParam.minMaxBounds.right = kHUI_Pixel_Max;	}	if ( d->chooseOnly) buttonParam.enabled = false;	buttonParam.id = kList_Add_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 11); // add	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.id = kList_Remove_Button_ID;	buttonParam.cellx =  kList_Button_Cell_X;	buttonParam.celly =  kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kHera_AppStrResID, 10); // remove	HUI_PushButton_New_LiteralP( &buttonParam);	strList = GetStringList( 8040); // cancel, choose	if ( strList != nil)	{		HUI_Main_Buttons_H_Setup( d->master, 0,			kSeparator_Cell_X, kColNum, kSeparator_Cell_Y, 1,				true, strList);				ReleaseResource( strList);	}		ShowWindow( (WindowPtr)newWindow);	HUI_Master_Layout( d->master, (Point){0, 0}, (Point){0, 0});	HUI_Master_ShowLayer( d->master, 0);		Setup_List( d);		{		list = HUI_List_Get( d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID);		if ( list != nil)		{			d->index = PsuedoColumn_CellV_FindFromNumber( list, 0,				d->defaultResID);			if ( d->index < 0) d->index = 0;		}				d->index =  HUI_Control_SetListValue(				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, d->index);		if ( list != nil)		{			LAutoScroll( list);		}	}	ChangeWhichSprite( d, false);		if ( modal) gHera->modalMode++;	HUnlock( data);	return noErr;}GWorldPtr GWorld_Create( Rect *bounds){	QDErr			error;	PixMapHandle 	pixBase;	CGrafPtr		originalWorld;	GDHandle		originalDevice;	GWorldPtr		newWorld = nil;	Boolean			pixelsLocked;		/*		NewGWorld creates the world.  See p.21-12퉴13 in IM VI.  Note that		by setting pix depth to 0, we are using bounds as global rect which		determines the depth of the GWorld by using the deepest depth of any		device that rect intersects.  We should use the bounding rect of our		device of choice, but I'm too lazy.	*/	GetGWorld( &originalWorld, &originalDevice);	error = NewGWorld ( &newWorld, 8, bounds, gHera->theCLUT, nil, 0);	mAssert( error == noErr);		SetGWorld( newWorld, nil);		pixBase = GetGWorldPixMap( newWorld);	pixelsLocked = LockPixels( pixBase);	if ( !pixelsLocked)	{		mAssert( pixelsLocked);		DisposeGWorld( newWorld);		return( nil);	}	SetGWorld( originalWorld, originalDevice);		return ( newWorld);}