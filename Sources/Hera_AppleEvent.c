/******************************************\|**| Ares_AppleEvent.c\******************************************/#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#pragma mark _this library includes_/* - this project*******************************************/#include "Hera_Global.h"#include "Hera_AppleEvent.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kAEInitErr					76#pragma mark _macros_/* - macros*******************************************/#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/#pragma mark 본EXTERNAL GLOBALS본/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;void OpenAresScenarioFile( FSSpecPtr);#pragma mark 본PRIVATE GLOBALS본/******************************************\|**| private globals\******************************************/#pragma mark 본PRIVATE PROTOTYPES본/******************************************\|**| private function prototypes\******************************************/pascal OSErr HandleOApp( const AppleEvent *theAppleEvent, AppleEvent *reply,  long refcon);pascal OSErr HandleQuit( const AppleEvent *theAppleEvent, AppleEvent *reply,  long refcon);pascal OSErr HandlePrint( const AppleEvent *theAppleEvent, AppleEvent *reply,  long refcon);pascal OSErr HandleAnswer( const AppleEvent *theAppleEvent, AppleEvent *reply,  long refcon);pascal OSErr HandleOpenDoc( const AppleEvent *theAppleEvent, AppleEvent *reply,		 long refcon);pascal OSErr GotRequiredParams( const AppleEvent *theAppleEvent);#pragma mark 본PRIVATE FUNCTIONS본/******************************************\|**| private functions\******************************************/pascal OSErr HandleOApp( const AppleEvent *theAppleEvent, AppleEvent *reply,  long refcon){	OSErr	error;#pragma unused( reply, refcon)	error = GotRequiredParams( theAppleEvent);	if ( error != noErr) return ( error);	// no action		return( noErr);}pascal OSErr HandleQuit( const AppleEvent *theAppleEvent, AppleEvent *reply,  long refcon){	OSErr	error;	#pragma unused( reply, refcon)	error = GotRequiredParams( theAppleEvent);	if ( error != noErr) return ( error);		gHera->wantToQuit = true;//	DoQuit( true);	return( noErr);}pascal OSErr HandlePrint( const AppleEvent *theAppleEvent, AppleEvent *reply,  long refcon){	OSErr error;	#pragma unused( reply, refcon)	error = GotRequiredParams( theAppleEvent);	if ( error != noErr) return ( error);		// no action		return( noErr);}pascal OSErr HandleAnswer( const AppleEvent *theAppleEvent, AppleEvent *reply,  long refcon){	OSErr error = noErr;	#pragma unused( theAppleEvent, reply, refcon)//	error = GotRequiredParams( theAppleEvent);	if ( error != noErr) 	{		return ( error);	}		// no action		return( noErr);}pascal OSErr HandleOpenDoc( const AppleEvent *theAppleEvent, AppleEvent *reply,		 long refcon){	OSErr		error, ignoreError;	FSSpec		myFSS;	AEDescList	docList;	long		index, itemsInList;	Size		actualSize;	AEKeyword	keywd;	DescType	returnedType;	#pragma unused( reply, refcon)	//    {get the direct parameter--a descriptor list--and put it into doclist	error = AEGetParamDesc(theAppleEvent, keyDirectObject, typeAEList, &docList);	if ( error == noErr)	{		// check for missing params		error = GotRequiredParams( theAppleEvent);		if ( error == noErr)		{			// count the # of descriptor records in list			error = AECountItems (&docList, &itemsInList);			if ( error == noErr)			{				// get each descriptor from list				// coerce into FSSpec record				// and open				for ( index = 1; index <= itemsInList; index++)				{					error = AEGetNthPtr(&docList, index, typeFSS,                                            &keywd, &returnedType, &myFSS,                                            sizeof(myFSS), &actualSize);					if ( error == noErr)					{						OpenAresScenarioFile( &myFSS);					}				}			} 		} else		{			ignoreError = AEDisposeDesc( &docList);		}	} else	{		return( error);	}	return( error);}// see IM:VI p6-48pascal OSErr GotRequiredParams( const AppleEvent *theAppleEvent){	DescType	theType;	Size		theSize;	OSErr		error;		error = AEGetAttributePtr( theAppleEvent, keyMissedKeywordAttr, typeWildCard, &theType, nil,			0, &theSize);	if (error == errAEDescNotFound) // all required params gotten	{		return( noErr);	}	else if ( error == noErr) // missed param, because missed keyword exists	{		return( errAEEventNotHandled);	}	else	{		return( error);	}}#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/OSErr AAE_Init( void){	AEEventHandlerUPP		upp = nil;	OSErr					err;#ifndef TARGET_API_MAC_CARBON	upp = NewAEEventHandlerProc( (ProcPtr)HandleOApp);#else	upp = NewAEEventHandlerUPP( HandleOApp);#endif TARGET_API_MAC_CARBON	err = AEInstallEventHandler( kCoreEventClass, kAEOpenApplication,			upp, 0, false);	if ( err != noErr)	{//		ShowErrorOfTypeOccurred( eQuitErr, kErrorStrID, kAEInitErr, err, __FILE__, 0);		return err;	}#ifndef TARGET_API_MAC_CARBON	upp = NewAEEventHandlerProc( (ProcPtr)HandleQuit);#else	upp = NewAEEventHandlerUPP( HandleQuit);#endif TARGET_API_MAC_CARBON	err = AEInstallEventHandler( kCoreEventClass, kAEQuitApplication,			upp, 0, false);	if ( err != noErr)	{//		ShowErrorOfTypeOccurred( eQuitErr, kErrorStrID, kAEInitErr, err, __FILE__, 1);		return err;	}#ifndef	TARGET_API_MAC_CARBON	upp = NewAEEventHandlerProc( (ProcPtr)HandlePrint);#else	upp = NewAEEventHandlerUPP( HandlePrint);#endif TARGET_API_MAC_CARBON	err = AEInstallEventHandler( kCoreEventClass, kAEPrint,			upp, 0, false);	if ( err != noErr)	{//		ShowErrorOfTypeOccurred( eQuitErr, kErrorStrID, kAEInitErr, err, __FILE__, 2);		return err;	}#ifndef TARGET_API_MAC_CARBON	upp = NewAEEventHandlerProc( (ProcPtr)HandleOpenDoc);#else	upp = NewAEEventHandlerUPP( HandleOpenDoc);#endif TARGET_API_MAC_CARBON	err = AEInstallEventHandler( kCoreEventClass, kAEOpenDocuments,			upp, 0, false);		if ( err != noErr)	{//		ShowErrorOfTypeOccurred( eQuitErr, kErrorStrID, kAEInitErr, err, __FILE__, 3);		return err;	}//	upp = NewAEEventHandlerProc( (ProcPtr)HandleAnswer);//	err = AEInstallEventHandler( kCoreEventClass, kAEAnswer, upp, 0, false);//		if ( err != noErr)//	{//		ShowErrorOfTypeOccurred( eQuitErr, kErrorStrID, kAEInitErr, err, __FILE__, 4);//		return err;//	}	//	gAresGlobal->aeInited = true;	return noErr;}