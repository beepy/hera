/******************************************\|**| Object_Editor.c\******************************************/#pragma mark ¥¥INCLUDES¥¥/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Window Dispatch.h"#include "Control Utilities.h"#include "Hewey.h"#include "Hewey_Main.h"#include "Hewey_Layout.h"#include "Hewey_Utilities.h"#include "Hewey_Helpers.h"#include "str_bp.h"#include "Set Font By String.h"#include "BP_Error.h"#include "BPMacOutput.h"#include "Assert.h"#include "strlist.h"#include "String Numerics.h"#include "List_Utilities.h"#include "PsuedoColumn_Utilities.h"#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/// ares#include "Space Object.h"#include "Scenario_Data.h"// hera#include "Hera_Global.h"#include "Data_Selector.h"#include "Object_Editor.h"#include "Bit_Flipper.h"#include "Hera_Utilities.h"#include "Button_Window.h"#include "Action_Editor.h"#include "Hera_Name_Maker.h"#include "Hera_Data.h"#include "Sprite_Selector.h"#pragma mark ¥¥DEFINITIONS¥¥/******************************************\|**| #defines\******************************************//* - definitions*******************************************/// from ares Sprite Handling.c#define	kSolidSquareBlip		0x00000000#define	kTriangeUpBlip			0x00000001#define	kDiamondBlip			0x00000002#define	kPlusBlip				0x00000003#define	kFramedSquareBlip		0x00000004#define	kBlipTypeShift			4#define	kBlipSizeMask			0x0000000f#define	kBlipTypeMask			0x000000f0#define	kEditTextFieldWidth				50#define	kEditTextSmallFieldWidth		16#define	kLarge_Tab_Width				80//112#define	kEditTextHugeFieldWidth			((kLarge_Tab_Width * 2) + kEditTextFieldWidth)// 150#define	kCellTabWidth					60#define	kCellBigTabWidth				86#define	kRotateSpriteKind				0#define	kAnimatedSpriteKind				1#define	kBeamKind						2#define	kDeviceKind						3#define	kColNum							2#define	kRowNum							5#define	kOK_Button_ID					1#define	kCancel_Button_ID				2#define	kRevert_Button_ID				3#define	kPrevious_Button_ID				4#define	kNext_Button_ID					5#define	kList_ID						6#define	kList_Cell_X					0#define	kList_Cell_Y					1#define	kList_Header_Cell_X				0#define	kList_Header_Cell_Y				0#define	kList_Header_ID					350#define	kList_Button_Cell_X				0#define	kList_Button_Cell_Y				2#define	kList_Button_ID_Offset			300#define	kList_Remove_Button_ID			(kList_Button_ID_Offset + 1)#define	kList_Add_Button_ID				(kList_Button_ID_Offset + 2)#define	kList_SortBy_Menu_ID			(kList_Button_ID_Offset + 4)#define	kMain_Cell_X					1#define	kMain_Cell_Y					0#define	kMain_Cell_RowSpan				3#define	kMain_Cell_ColSpan				1#define	kSeparator_Cell_X				0#define	kSeparator_Cell_Y				3#define	kButton_Cell_X					0#define	kButton_Cell_Y					4#define	kSeparator_ID					200#define kTab_ID							100#define	kTabPanel_ColNum				3#define	kTabPanel_RowNum				1#define	kTabPanel_PanelNum				8#define	kTab_Cell_1_X					0#define	kTab_Cell_1_Y					0#define	kTab_Cell_2_X					1#define	kTab_Cell_2_Y					0#define	kTab_Cell_3_X					2#define	kTab_Cell_3_Y					0#define	kStrResID						8010#define	kObjectNameLongStrResID			5000#define	kObjectNameShortStrResID		5001#define	kObjectNoteStrResID				5002// BS = basic panel#define	kBS_Panel_Index					0#define	kBS_Base_ID						1200#define	kBS_ShortName_ID				(kBS_Base_ID + 2)#define	kBS_LongName_ID					(kBS_Base_ID + 4)#define	kBS_DevNote_ID					(kBS_Base_ID + 6)#define	kBS_Blessings_Group_ID			(kBS_Base_ID + 8)#define	kBS_NotBlessed_ID				(kBS_Base_ID + 10)#define	kBS_WarpInFlare_ID				(kBS_Base_ID + 12)#define	kBS_WarpOutFlare_ID				(kBS_Base_ID + 14)#define	kBS_PlayersBody_ID				(kBS_Base_ID + 16)#define	kBS_EnergyBlob_ID				(kBS_Base_ID + 18)#define	kBS_ShortName_Len_ID			(kBS_Base_ID + 20)#define	kBS_LongName_Len_ID				(kBS_Base_ID + 22)#define	kBS_DevNote_Len_ID				(kBS_Base_ID + 24)#define	kBS_PictureResID_ID				(kBS_Base_ID + 26)#define	kBS_Blessings_Cell_X			kTab_Cell_3_X#define	kBS_Blessings_Cell_Y			kTab_Cell_3_Y// AP = attributes panel#define	kAP_Panel_Index					1#define	kAP_Class_ID					210#define	kAP_Race_ID						212#define	kAP_Offensive_Value_ID			214#define	kAP_Target_Class_ID				216#define	kAP_Max_Velocity_ID				218#define	kAP_Warp_Speed_ID				220#define	kAP_Warp_Out_Distance_ID		222#define	kAP_Calc_Warpout_Now_ID			224#define	kAP_Initial_Velocity_ID			226#define	kAP_Velocity_Range_ID			228#define	kAP_Mass_ID						230#define	kAP_Maximum_Thrust_ID			232#define	kAP_Health_ID					234#define	kAP_Damage_Caused_ID			236#define	kAP_Energy_ID					238#define	kAP_Initial_Age_ID				240#define	kAP_Initial_Age_Range_ID		242#define	kAP_Natural_Scale_ID			244#define	kAP_Sprite_Layer_ID				246#define	kAP_Long_Range_Size_ID			248#define	kAP_Long_Range_Kind_ID			250#define	kAP_Initial_Direction_ID		252#define	kAP_Direction_Range_ID			254#define	kAP_Friendly_Needs_ID			256#define	kAP_Danger_Threshold_ID			258#define	kAP_Skill_Numerator_ID			260#define	kAP_Skill_Denominator_ID		262#define	kAP_Build_Ratio_ID				264#define	kAP_Build_Time_ID				266#define	kAP_Shield_Color_ID				268#define	kAP_Price_ID					270#define	kAP_First_List_Item				kAP_Class_ID#define	kAP_Last_List_Item				kAP_Price_ID#define	kAP_Attribute_Flags_Menu_ID		280#define	kAP_Attribute_Flags_Button_ID	282#define	kAP_Build_Flags_Menu_ID			284#define	kAP_Build_Flags_Button_ID		286#define	kAP_Order_Flags_Menu_ID			288#define	kAP_Order_Flags_Button_ID		290#define	kAP_First_Bit_Menu				kAP_Attribute_Flags_Menu_ID#define	kAP_Last_Bit_Menu				kAP_Order_Flags_Menu_ID// WP = weapon panel#define	kWP_Panel_Index					2#define	kWP_Pulse_Weapon_CheckBox_ID	509#define kWP_Pulse_Weapon_ID				510#define kWP_Pulse_Position_Num_ID		512#define kWP_Pulse_X_1_ID				514#define	kWP_Pulse_Y_1_ID				516#define	kWP_Pulse_X_2_ID				518#define	kWP_Pulse_Y_2_ID				520#define	kWP_Pulse_X_3_ID				522#define	kWP_Pulse_Y_3_ID				524#define	kWP_Beam_Weapon_CheckBox_ID		525#define kWP_Beam_Weapon_ID				526#define kWP_Beam_Position_Num_ID		528#define kWP_Beam_X_1_ID					530#define	kWP_Beam_Y_1_ID					532#define	kWP_Beam_X_2_ID					534#define	kWP_Beam_Y_2_ID					536#define	kWP_Beam_X_3_ID					538#define	kWP_Beam_Y_3_ID					540#define	kWP_Special_Weapon_CheckBox_ID	541#define kWP_Special_Weapon_ID			542#define kWP_Special_Position_Num_ID		544#define kWP_Special_X_1_ID				546#define	kWP_Special_Y_1_ID				548#define	kWP_Special_X_2_ID				550#define	kWP_Special_Y_2_ID				552#define	kWP_Special_X_3_ID				554#define	kWP_Special_Y_3_ID				556#define	kWP_Special_Direction_ID		558#define	kWP_Pulse_Choose_Button_ID		572#define	kWP_Beam_Choose_Button_ID		574#define	kWP_Special_Choose_Button_ID	576// CP = action panel#define	kCP_Panel_Index					3#define	kCP_Destroy_Action_Index_ID		610#define	kCP_Destroy_Action_Num_ID		612#define	kCP_Expire_Action_Index_ID		614#define	kCP_Expire_Action_Num_ID		616#define	kCP_Create_Action_Index_ID		618#define	kCP_Create_Action_Num_ID		620#define	kCP_Collide_Action_Index_ID		622#define	kCP_Collide_Action_Num_ID		624#define	kCP_Activate_Action_Index_ID	626#define	kCP_Activate_Action_Num_ID		628#define	kCP_Arrive_Action_Index_ID		630#define	kCP_Arrive_Action_Num_ID		632#define	kCP_Periodic_Time_ID			634#define	kCP_Periodic_Time_Range_ID		636#define	kCP_First_List_Item				kCP_Destroy_Action_Index_ID#define	kCP_Last_List_Item				kCP_Periodic_Time_Range_ID#define	kCP_Destroy_Action_DontDieFlag_ID		638#define	kCP_Arrive_Action_Distance_ID	640#define	kCP_Edit_Button_Offset		1000#define	kCP_Select_Button_Offset	1002// RP = rotation panel#define	kRP_Panel_Index					4#define	kRP_Shape_Offset_ID				710#define	kRP_Rot_Res_ID					712#define	kRP_Max_Turn_Rate_ID			714#define	kRP_Turn_Acceleration_ID		716#define	kRP_Shape_Field_ID				718#define	kRP_Choose_Shape_Button			720#define	kRP_First_List_Item				kRP_Shape_Offset_ID#define	kRP_Last_List_Item				kRP_Shape_Field_ID// MP = animation panel#define	kMP_Panel_Index					5#define	kMP_First_Shape_ID				810#define	kMP_Last_Shape_ID				812#define	kMP_Frame_Direction_ID			814#define	kMP_Frame_Direction_Range_ID	816#define	kMP_Frame_Speed_ID				818#define	kMP_Frame_Speed_Range_ID		820#define	kMP_Frame_Shape_ID				822#define	kMP_Frame_Shape_Range_ID		824#define	kMP_Shape_Field					826#define	kMP_Choose_Shape_Button			828#define	kMP_First_List_Item				kMP_First_Shape_ID#define	kMP_Last_List_Item				kMP_Shape_Field// BP = beam panel#define	kBP_Panel_Index					6#define	kBP_Color_ID					910#define	kBP_Kind_ID						912#define	kBP_Accuracy_ID					914#define	kBP_Range_ID					916#define kBP_First_List_Item				kBP_Color_ID#define	kBP_Last_List_Item				kBP_Range_ID// DP = device panel#define	kDP_Panel_Index					7#define	kDP_Usage_ID					1010#define	kDP_Energy_Cost_ID				1012#define	kDP_Fire_Time_ID				1014#define	kDP_Ammo_ID						1016#define	kDP_Range_ID					1018#define	kDP_Calc_Range_Now_ID			1020#define	kDP_Inverse_Speed_ID			1022#define	kDP_Calc_Inverse_Speed_Now_ID	1024#define	kDP_Restock_Cost_ID				1026#define	kDP_Usage_Button_ID				1050#define	kDP_First_List_Item				kDP_Usage_ID#define	kDP_Last_List_Item				kDP_Restock_Cost_ID/*// AP = attributes panelkAP_Class_IDkAP_Race_IDkAP_Offensive_Value_IDkAP_Target_Class_IDkAP_Max_Velocity_IDkAP_Warp_Speed_IDkAP_Warp_Out_Distance_IDkAP_Calc_Warpout_Now_IDkAP_Initial_Velocity_IDkAP_Velocity_Range_IDkAP_Mass_IDkAP_Maximum_Thrust_IDkAP_Health_IDkAP_Damage_Caused_IDkAP_Energy_IDkAP_Initial_Age_IDkAP_Initial_Age_Range_IDkAP_Natural_Scale_IDkAP_Sprite_Layer_IDkAP_Long_Range_Size_IDkAP_Shield_Color_IDkAP_Initial_Direction_IDkAP_Direction_Range_IDkAP_Friendly_Needs_IDkAP_Danger_Threshold_ID// WP = weapon panelkWP_Pulse_Weapon_IDkWP_Pulse_Position_Num_IDkWP_Pulse_X_1_IDkWP_Pulse_Y_1_IDkWP_Pulse_X_2_IDkWP_Pulse_Y_2_IDkWP_Pulse_X_3_IDkWP_Pulse_Y_3_IDkWP_Beam_Weapon_IDkWP_Beam_Position_Num_IDkWP_Beam_X_1_IDkWP_Beam_Y_1_IDkWP_Beam_X_2_IDkWP_Beam_Y_2_IDkWP_Beam_X_3_IDkWP_Beam_Y_3_IDkWP_Special_Weapon_IDkWP_Special_Position_Num_IDkWP_Special_X_1_IDkWP_Special_Y_1_IDkWP_Special_X_2_IDkWP_Special_Y_2_IDkWP_Special_X_3_IDkWP_Special_Y_3_ID// CP = action panelkCP_Destroy_Action_Index_IDkCP_Destroy_Action_Num_IDkCP_Expire_Action_Index_IDkCP_Expire_Action_Num_IDkCP_Create_Action_Index_IDkCP_Create_Action_Num_IDkCP_Collide_Action_Index_IDkCP_Collide_Action_Num_IDkCP_Activate_Action_Index_IDkCP_Activate_Action_Num_IDkCP_Arrive_Action_Index_IDkCP_Arrive_Action_Num_IDkCP_Destroy_Action_DontDieFlag_IDkCP_Periodic_Time_IDkCP_Periodic_Time_Range_ID// RP = rotation panelkRP_Shape_Offset_IDkRP_Rot_Res_IDkRP_Max_Turn_Rate_IDkRP_Turn_Acceleration_ID// MP = animation panelkMP_First_Shape_IDkMP_Last_Shape_IDkMP_Frame_Direction_IDkMP_Frame_Direction_Range_IDkMP_Frame_Speed_IDkMP_Frame_Speed_Range_IDkMP_Frame_Shape_IDkMP_Frame_Shape_Range_ID// BP = beam panelkBP_Color_IDkBP_Kind_IDkBP_Accuracy_IDkBP_Range_ID// DP = device panelkDP_Usage_IDkDP_Energy_Cost_IDkDP_Fire_Time_IDkDP_Ammo_IDkDP_Range_IDkDP_Inverse_Speed_IDkDP_Calc_Inverse_Speed_Now_IDkDP_Restock_Cost_ID*/#define	kSortByID						1#define	kSortByClass					2#define	kSortByRace						3#define	kSortByName						4#define	kObject_Editor_DestroyAction	0#define	kObject_Editor_ExpireAction		1#define	kObject_Editor_CreateAction		2#define	kObject_Editor_CollideAction	3#define	kObject_Editor_ActivateAction	4#define	kObject_Editor_ArriveAction		5#define	kDestinationMargin		50000#pragma mark _macros_/* - macros*******************************************/#pragma mark ¥¥TYPEDEFS¥¥/******************************************\|**| typedefs\******************************************/typedef struct objectWindowType{	heraScenarioFileType	*heraFile;	huiMasterControlType	*master;	huiMasterControlType	*panel;	Handle					huiCoordData;	baseObjectType			object;	Str255					shortName;	Str255					longName;	Str255					devNotes;	long					whichObject;	Boolean					anyChanges;	short					resRefNum;	long					windowID;	long					currentPanel;	long					setAttributes_WindowID;	long					setBuildFlags_WindowID;	long					setOrderFlags_WindowID;	long					setUsage_WindowID;	long					warpInFlareID;	long					warpOutFlareID;	long					playerBodyID;	long					energyBlobID;	Handle					discreteObjectData;	Handle					discreteObjectStringData;	short					sortBy;	Boolean					chooseOnly;	Boolean					includePhysicalObjects;	Boolean					includeDevices;	Boolean					isModal;	Object_Editor_Callback_procPtr	callBack;	long					currentObjectID;	long					callerID;	Str255					titlePrefix;} objectWindowType;typedef struct huiCoordDataType{	short					id;	short					panel;	short					cellx;	short					celly;	short					stringResID;	short					stringNum;	short					helpResID;	short					helpOnIndex;	short					helpOffIndex;	short					helpDisabledIndex;} huiCoordDataType;#pragma mark ¥¥EXTERNAL GLOBALS¥¥/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;#pragma mark ¥¥PRIVATE GLOBALS¥¥/******************************************\|**| private globals\******************************************/#pragma mark ¥¥PRIVATE PROTOTYPES¥¥/******************************************\|**| private function prototypes\******************************************/static Boolean HandleEvent( EventRecord *, CWindowPtr, long, long);static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID);static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID);static Boolean Handle_Control_Click( objectWindowType *d,	CWindowPtr whichWindow,	long dispatchID, ControlHandle aControl, huiPlainControlType *hui,	short whichPart, EventRecord *theEvent);static void Paste_ObjectWalker_Callback( Handle discreteObjectData,	Handle discreteActionData, unsigned long userData);static void Update_List_Entry( objectWindowType *d, long index);static long Insert_Object( CWindowPtr whichWindow, objectWindowType *d,	long where, Handle discreteObjectSource, heraScenarioFileType *sourceFile);static void Window_SetControls_FromObjectIndex( objectWindowType *d, CWindowPtr window,	long index);static void Window_SaveData_FromObjectIndex( objectWindowType *d, CWindowPtr window,	long index);static void IllegalColorMenu_SetFromBits( objectWindowType *d, unsigned long bits,	long startBit, long endBit, short id);static void SetIllegalColorBits( long windowID, unsigned long bits);static Boolean Save_From_WindowID( CWindowPtr whichWindow, long dispatchID);static void CancelButton_From_WindowID( CWindowPtr whichWindow, long dispatchID);static void OKButton( objectWindowType *d, CWindowPtr window);static void CancelButton( objectWindowType *d, CWindowPtr window);static void RevertButton( objectWindowType *d, CWindowPtr window);static void Revert_Window_Callback( long whichButton, long windowID);static void GetAllData( objectWindowType *d);void HU_HeweyParam_SetFromHC( Handle huiCoordData, long id, huiPlainControlParamType *p);static void SetObjectField( objectWindowType *d, baseObjectType *o, long id, Boolean draw);static void GetObjectField( objectWindowType *d, baseObjectType *o, long id);static long GetObjectKind( baseObjectType *o);static long CorrectPanelNumber( long panelNumber, baseObjectType *o);static void ChangePanelNumber( objectWindowType *d, long newPanelNumber);static void UpdateLengthField( objectWindowType *d, long lengthFieldID,	Boolean draw);static void SetAttributeBits( long windowID, unsigned long bits);static void SetOrderBits( long windowID, unsigned long bits);static void SetBuildBits( long windowID, unsigned long bits);static void SetUsageBits( long windowID, unsigned long bits);static short CompareCellsByName( Ptr cell_a, long length_a, Ptr cell_b, long length_b);static short CompareCellsByID( Ptr cell_a, long length_a, Ptr cell_b, long length_b);static short CompareCellsByClass( Ptr cell_a, long length_a, Ptr cell_b, long length_b);static short CompareCellsByRace( Ptr cell_a, long length_a, Ptr cell_b, long length_b);static OSErr SortObjectList( objectWindowType *d, Boolean draw);static void Pulse_Choose_Callback( long dispatchID, long objectChoiceID);static void Beam_Choose_Callback( long dispatchID, long objectChoiceID);static void Special_Choose_Callback( long dispatchID, long objectChoiceID);static void Action_Window_Create( objectWindowType *d, CWindowPtr window,	long dispatchID, long whichObjectAction, Boolean flipOff);static void DestroyAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber);static void ExpireAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber);static void CreateAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber);static void CollideAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber);static void ActivateAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber);static void ArriveAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber);static void Sprite_Choose_CallBack( long windowID, long resID);static void Sprite_Animation_Choose_CallBack( long windowID, long resID);static void BaseObject_Clear( baseObjectType *aBase);static void Enable_Editing( objectWindowType *d, Boolean enable);smallFixedType GetWeaponMaxVelocity( objectWindowType *d, long *life);static void Object_Do_Delete( objectWindowType *d, CWindowPtr whichWindow,	unsigned short modifiers, Boolean confirm);	#pragma mark ¥¥PRIVATE FUNCTIONS¥¥/******************************************\|**| private functions\******************************************/static Boolean HandleEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID, long command){	switch( command)	{		case kWD_Close_ForQuit_Command:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				CancelButton_From_WindowID( whichWindow, dispatchID);			}			return false;			break;				case kWDProcessEventCommand:			return( ProcessEvent( theEvent, whichWindow, dispatchID));			break;				case kWDSaveWindowCommand:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				if ( !Save_From_WindowID( whichWindow, dispatchID))				{					gHera->currentSave = nil;				}			}			return false;			break;		case kWDProcessMenuChoiceCommand:			return( ProcessMenuChoiceCommand( (unsigned long)theEvent,				whichWindow, dispatchID));			break;			}	return false;}static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Handle							data =										GetDispatchWindowDataHandle( dispatchID),									discreteDataSource = nil;	SignedByte						dataState;	objectWindowType				*d;	Boolean							result = false;	GrafPtr							oldPort;	short							menuID = ((menuData & 0xffff0000) >> 16),									menuItem = (menuData & 0x0000ffff);	huiPlainControlType				*hui = nil;	OSErr							err = noErr;	ControlHandle					aControl;		if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (objectWindowType *)*data;	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);	result = Generic_ProcessMenuChoiceCommand( menuData, whichWindow,												dispatchID);	if ( result)	{		goto ProcessMenuChoiceCommand_Return;	}	err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);	if (( err == noErr) && ( aControl != nil))	{		hui = (huiPlainControlType *)CU_GetControlReference( aControl);	}			switch( menuID)	{		case kEditMenuID:			switch( menuItem)			{				case kEdit_Undo_Item:					result = true;					break;									case kEdit_Cut_Item:					result = true;					break;									case kEdit_Copy_Item:					if ( hui != nil)					{						switch ( hui->generic.id)						{							case kList_ID:								Window_SaveData_FromObjectIndex( d,									whichWindow, d->whichObject);								gHera->clipboard.type = 0;								if ( gHera->clipboard.sourceData != nil)									DisposeHandle( gHera->clipboard.sourceData);								gHera->clipboard.sourceData =									d->discreteObjectData;								HandToHand( &gHera->clipboard.sourceData);								err = MemError();								if ( err != noErr)								{									BP_UserError_Literal("Object Editor",											"CouldnÕt allocate space for the "											"object on the clipboard.");									gHera->clipboard.sourceData = nil;								} else								{									gHera->clipboard.type = kHera_Object_Type;									gHera->clipboard.dataID = d->currentObjectID;									gHera->clipboard.dataRange = 0;									gHera->clipboard.sourceFile = d->heraFile;								}								break;														default:								if ( gHera->clipboard.sourceData != nil)									DisposeHandle( gHera->clipboard.sourceData);								gHera->clipboard.type = 0;								break;						}					}					result = true;					break;									case kEdit_Paste_Item:					if ( hui != nil)					{						switch ( hui->generic.id)						{							case kList_ID:								d->heraFile->changed = true;								if (( gHera->clipboard.type ==											kHera_Object_Type)									&& ( gHera->clipboard.sourceData != nil))								{									if ( gHera->clipboard.sourceFile->fileRefNum !=										d->heraFile->fileRefNum)									{										Window_SaveData_FromObjectIndex( d,											whichWindow, d->whichObject);										// if the source is from a 										// different file, we have to										// walk the object										/*										HD_ObjectWalker(											gHera->clipboard.sourceFile,											gHera->clipboard.dataID,											dispatchID,											Paste_ObjectWalker_Callback);*/																				HD_DiscreteData_SetAllFlags(											d->heraFile, 0, 0, 0xffffffff);										HD_DiscreteData_ClearAllRealIndexes(											d->heraFile, 0);										HD_DiscreteData_SetAllFlags(											gHera->clipboard.sourceFile, 0, 0, 0xffffffff);										HD_DiscreteData_ClearAllRealIndexes(											gHera->clipboard.sourceFile, 0);										HD_Object_Copy(											gHera->clipboard.sourceFile,											gHera->clipboard.sourceData,											d->heraFile);										} else									{										Insert_Object( whichWindow, d,											d->whichObject + 1,											gHera->clipboard.sourceData,											gHera->clipboard.sourceFile);									}									GetAllData( d);									Window_SetControls_FromObjectIndex(										d, whichWindow, d->whichObject);								}								break;														default:								gHera->clipboard.type = 0;								break;						}					}					result = true;					break;									case kEdit_Clear_Item:					result = true;					break;									case kEdit_Select_All_Item:					result = true;					break;									case kEdit_Add_Item:					result = true;					break;									case kEdit_Delete_Item:					result = true;					break;									case kEdit_Delete_All_Item:					result = true;					break;			}							break;			}	ProcessMenuChoiceCommand_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);}static void Paste_ObjectWalker_Callback( Handle discreteObjectData,	Handle discreteActionData, unsigned long userData){	long								dispatchID = userData;	Handle								wData, newActionData;	objectWindowType					*d;	SignedByte							dataState;	CWindowPtr							whichWindow;	baseObjectType						*o;	long								sourceActionID, newActionID,										number, newObjectID;	void								*sourceActions, *newActions;		wData = GetDispatchWindowDataHandle( dispatchID);	if ( wData == nil) goto Paste_ObjectWalker_Callback_error;		whichWindow = GetWindowPtrFromDispatchWindowID( dispatchID);	if ( whichWindow == nil) goto Paste_ObjectWalker_Callback_error;		dataState = HGetState( wData);	HLock( wData);	d = (objectWindowType *)*wData;		if ( discreteActionData == nil)	{		newObjectID = Insert_Object( whichWindow, d,			d->whichObject + 1,			discreteObjectData,			gHera->clipboard.sourceFile);		((heraDataHeaderType *)*discreteObjectData)->realIndex =			newObjectID;			} else	{		// we have an action and the object which is invoking it		if ( discreteObjectData == nil) goto Paste_ObjectWalker_Callback_error;				sourceActionID = ((heraDataHeaderType *)*discreteActionData)->id;		newActionID = HD_Get_NextID_From_Type( d->heraFile, kHera_Action_Type);		number = HD_DiscreteData_GetElementNumber( discreteActionData,			kHera_Action_Type);		newActionData = HD_Create_Discrete_Data( d->heraFile, nil,			0, number, newActionID, kHera_Action_Type);		if ( newActionData == nil) goto Paste_ObjectWalker_Callback_error;		newActionID = ((heraDataHeaderType *)*newActionData)->id;				sourceActions = HD_DiscreteData_GetNthElement( discreteActionData,			kHera_Action_Type, 0);		newActions = HD_DiscreteData_GetNthElement( newActionData,			kHera_Action_Type, 0);		if (( sourceActions != nil) && ( newActions != nil))		BlockMove( sourceActions, newActions, sizeof( objectActionType) *			number);				// we have to manually check each of the source object's actions		// against the source action's id to see which ones to replace				discreteObjectData = HD_Find_Discrete_Data( d->heraFile,			((heraDataHeaderType *)*discreteObjectData)->realIndex, 0, nil,			kHera_Object_Type);				if ( discreteObjectData == nil) goto			Paste_ObjectWalker_Callback_error;		o = (baseObjectType *)HD_DiscreteData_GetNthElement( discreteObjectData,			kHera_Object_Type, 0);		mAssert( o != nil);				if ( o->destroyAction == sourceActionID)			o->destroyAction = newActionID;		if ( o->expireAction == sourceActionID)			o->expireAction = newActionID;		if ( o->createAction == sourceActionID)			o->createAction = newActionID;		if ( o->collideAction == sourceActionID)			o->collideAction = newActionID;		if ( o->activateAction == sourceActionID)			o->activateAction = newActionID;		if ( o->arriveAction == sourceActionID)			o->arriveAction = newActionID;	}	Paste_ObjectWalker_Callback_error:		if ( wData != nil) HSetState( wData, dataState);}static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Boolean							result = false;	ControlHandle					aControl, oldControl;	short							whichPart, oldValue;	WindowPtr						scratchWindow;	Point							where;	char							whichChar;	GrafPtr							oldPort;	OSStatus						err;	objectWindowType				*d;	huiPlainControlType				*hui = nil;		if ( data == nil) return false;	if ( theEvent == nil) return false;		dataState = HGetState( data);	HLock( data);	d = (objectWindowType *)*data;		if ( theEvent == nil) goto ProcessEvent_Return;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);		switch( theEvent->what)	{		case nullEvent:			IdleControls( (WindowPtr)whichWindow);			if ( !gHera->inBackground)			{				long	tc = TickCount();								if (( tc < gHera->lastNullUpdate) || (( tc -					gHera->lastNullUpdate) > kHera_Null_Update_Time))				{					gHera->lastNullUpdate = tc;					Update_List_Entry( d, d->whichObject);				}			}			result = true;			break;					case updateEvt:				BeginUpdate ((WindowPtr)whichWindow);/*			SetPort( (WindowPtr)whichWindow);			CalcVis( (WindowPtr)whichWindow);			UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);*/			HU_GenericUpdateEventHandler( whichWindow);			EndUpdate ((WindowPtr)whichWindow);			result = true;			break;		case mouseDown:			whichPart = FindWindow (theEvent->where, &scratchWindow);			switch( whichPart)			{				case inGrow:/*					{						Rect	growRect;						long	newSize;//						growRect = qd.screenBits.bounds;						C2C_ScreenBits_GetBounds( &growRect);						growRect.top = growRect.left = 120;						newSize = GrowWindow((WindowPtr)whichWindow,							theEvent->where ,&growRect);						if (newSize != 0)						{							SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,								(((newSize) >> 16) & 0xFFFF), true );							EraseRect(&whichWindow->portRect);							InvalRect( &whichWindow->portRect);						}					}*/					HU_GenericGrowWindow( whichWindow, theEvent->where);					result = true;					break;								case inContent:					where = theEvent->where;					scratchWindow = WD_FrontWindow();					if ( whichWindow != (CWindowPtr)scratchWindow)					{						goto ProcessEvent_Return;					}					SetPortWindowPort( (WindowPtr)whichWindow);					GlobalToLocal( &where);//					whichPart = FindControl( where, (WindowPtr)whichWindow,//						&aControl);					aControl = FindControlUnderMouse( where, (WindowPtr)whichWindow,						&whichPart);					BPMOWritePString("\p\rpart: ");					BPMOWriteLong( whichPart);					BPMOWritePString("\p\r");					if ( aControl == nil)						goto ProcessEvent_Return;					oldValue = GetControlValue( aControl);					err = GetKeyboardFocus( (WindowPtr)whichWindow, &oldControl);					if (( err == noErr) && ( oldControl != aControl))					{						SetKeyboardFocus( (WindowPtr)whichWindow, aControl, whichPart);					}					if ( whichPart != 0)					{						hui = (huiPlainControlType	*)CU_GetControlReference( aControl);//						whichPart = HandleControlClick ( aControl, where,//							theEvent->modifiers, nil);						if ( !ListBox_Appearance_1_0_1_Hack( aControl, where,									&whichPart))						{							whichPart = HUI_Control_Click_Handle( hui, where,								theEvent->modifiers);														}						if ( whichPart != 0)						{							result = Handle_Control_Click( d,  whichWindow,								dispatchID, aControl,  hui, whichPart,								theEvent);						}					} else // not in control					{						where = theEvent->where;						GlobalToLocal( &where);					}			}			break;					case keyDown:		case autoKey:			whichChar = theEvent->message & charCodeMask;			whichPart = kControlNoPart;						err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);			if (( err == noErr) && ( aControl != nil))			{				whichPart = HandleControlKey( aControl,					(theEvent->message & keyCodeMask)>>16,					theEvent->message & charCodeMask, theEvent->modifiers);				{					hui = (huiPlainControlType	*)CU_GetControlReference( aControl);					if ( ((huiGenericControlType *)hui)->kind != hui_ScrollTextControl) whichPart =						kControlNoPart;					switch( hui->generic.id)					{													case kList_ID:							oldValue = d->whichObject;							d->whichObject = HUI_Control_GetListValue(									d->master, 0, kList_Cell_X, kList_Cell_Y,									kList_ID, d->whichObject);														if ( d->whichObject != oldValue)							{								Window_SaveData_FromObjectIndex( d,									whichWindow, oldValue);								Window_SetControls_FromObjectIndex(									d, whichWindow, d->whichObject									);								ChangePanelNumber( d, d->currentPanel); // auto corrects if not								// showing right special panel							}							break;												case kBS_ShortName_ID:							UpdateLengthField( d, kBS_ShortName_Len_ID, true);							break;													case kBS_LongName_ID:							UpdateLengthField( d, kBS_LongName_Len_ID, true);							break;						case kBS_DevNote_ID:							UpdateLengthField( d, kBS_DevNote_Len_ID, true);							break;					}				}			}			if ( whichPart == kControlNoPart)			{				if ((whichChar=='\r' || whichChar==0x3))				{					// ok					long			soon = TickCount()+5;										aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,						kButton_Cell_Y, kOK_Button_ID);					if ( aControl != nil)					{						ActivateControl( aControl);						while ( TickCount() < soon){ /* do nothing */}						DeactivateControl( aControl);						result = true;						OKButton( d, whichWindow);//						CloseDispatchWindow( dispatchID);						goto ProcessEvent_Return;					}				} else if ((whichChar==0x1b) || ((whichChar=='.') && (theEvent->modifiers & cmdKey)))				{					// cancel					long			soon = TickCount()+5;										aControl = HUI_Control_Get( d->master, 0, kButton_Cell_X,						kButton_Cell_Y, kCancel_Button_ID);					if ( aControl != nil)					{						ActivateControl( aControl);						while ( TickCount() < soon){ /* do nothing */}						DeactivateControl( aControl);						CancelButton( d, whichWindow);	//					CloseDispatchWindow( dispatchID);						result = true;						goto ProcessEvent_Return;					}				} else if ( whichChar == '\t')				{					if ( theEvent->modifiers & shiftKey)						ReverseKeyboardFocus( (WindowPtr)whichWindow);					else						AdvanceKeyboardFocus( (WindowPtr)whichWindow);					result = true;					break;				} else if (( whichChar == 0x08) && ( !d->chooseOnly))				{					huiPlainControlType	*hui = nil;					err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);					hui = (huiPlainControlType	*)CU_GetControlReference( aControl);					if ( hui != nil)					{						if ( hui->generic.id == kList_ID)						{							Object_Do_Delete( d, whichWindow, theEvent->modifiers,								true);						}					}				}			}						break;	}		ProcessEvent_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);	}static Boolean Handle_Control_Click( objectWindowType *d,	CWindowPtr whichWindow,	long dispatchID, ControlHandle aControl, huiPlainControlType *hui,	short whichPart, EventRecord *theEvent){	long			oldValue;	Boolean			result = false;		switch( hui->generic.id)	{		case kList_ID:			oldValue = d->whichObject;						d->whichObject = HUI_Control_GetListValue(					d->master, 0, kList_Cell_X, kList_Cell_Y,					kList_ID, d->whichObject);			if ( d->whichObject != oldValue)			{							Window_SaveData_FromObjectIndex( d,					whichWindow, oldValue);				Window_SetControls_FromObjectIndex(					d, whichWindow, d->whichObject);									ChangePanelNumber( d, d->currentPanel); // auto corrects if not				// showing right special panel			}			result = true;			break;											case kList_Add_Button_ID:			{				Insert_Object( whichWindow, d, d->whichObject + 1, 					nil, nil);				result = true;			}			break;				case kList_Remove_Button_ID:/*			if ( d->discreteObjectData != nil)			{				d->anyChanges = true;				HUI_Control_DeleteListRows(					d->master, 0, kList_Cell_X, kList_Cell_Y,					kList_ID, 1, d->whichObject);				d->whichObject = 					HUI_Control_SetListValue(						d->master, 0, kList_Cell_X, kList_Cell_Y,						kList_ID, d->whichObject);				HD_Delete_Discrete_Data( d->heraFile, d->discreteObjectData);				d->discreteObjectData = nil;				HD_Delete_Discrete_Data( d->heraFile, d->discreteObjectStringData);				d->discreteObjectStringData = nil;				Window_SetControls_FromObjectIndex( d, whichWindow, d->whichObject);			}*/			Object_Do_Delete( d, whichWindow, theEvent->modifiers, true);			result = true;			break;				case kList_SortBy_Menu_ID:			oldValue = d->sortBy;						d->sortBy = HUI_Control_GetValueShort(				d->master, 0, kList_Button_Cell_X,				kList_Button_Cell_Y, kList_SortBy_Menu_ID);							if ( d->sortBy != oldValue)			{				SortObjectList( d, true);			}			break;		case kOK_Button_ID:			OKButton( d, whichWindow);			result = true;//			CloseDispatchWindow( dispatchID);			break;				case kCancel_Button_ID:			CancelButton( d, whichWindow);			result = true;			break;				case kRevert_Button_ID:			RevertButton( d, whichWindow);			result = true;			break;				case kTab_ID:			{				long newPanel = HUI_Control_GetValueShort( d->master, 0, kMain_Cell_X,					kMain_Cell_Y, kTab_ID) - 1;				ChangePanelNumber( d, newPanel);			}			break;				case kAP_Attribute_Flags_Button_ID://			gHera->modalMode++;			BitFlipper_NewWindow( &d->setAttributes_WindowID,				"\pAttributes",				GetStringList( 600),				d->object.attributes, dispatchID,				SetAttributeBits);			result = true;			break;				case kAP_Attribute_Flags_Menu_ID:		{			unsigned long bit;						if ( whichPart == kControlMenuPart)			{				oldValue = GetBevelMenuValue( aControl) - 1;				bit = 0x01 << oldValue;				d->object.attributes ^= bit;				HU_Menu_SetCheckFromBits( aControl, d->object.attributes,					oldValue, oldValue);			}		}			result = true;			break;					case kAP_Build_Flags_Button_ID://			gHera->modalMode++;			BitFlipper_NewWindow( &d->setBuildFlags_WindowID,				"\pBuild Flags",				GetStringList( 640),				d->object.buildFlags, dispatchID,				SetBuildBits);			result = true;			break;				case kAP_Build_Flags_Menu_ID:		{			unsigned long bit;						if ( whichPart == kControlMenuPart)			{				oldValue = GetBevelMenuValue( aControl) - 1;				bit = 0x01 << oldValue;				d->object.buildFlags ^= bit;				HU_Menu_SetCheckFromBits( aControl, d->object.buildFlags,					oldValue, oldValue);			}		}			result = true;			break;					case kAP_Order_Flags_Button_ID://			gHera->modalMode++;			BitFlipper_NewWindow( &d->setOrderFlags_WindowID,				"\pOrder Flags",				GetStringList( 641),				d->object.orderFlags, dispatchID,				SetOrderBits);			result = true;			break;				case kAP_Order_Flags_Menu_ID:		{			unsigned long bit;						if ( whichPart == kControlMenuPart)			{				oldValue = GetBevelMenuValue( aControl) - 1;				bit = 0x01 << oldValue;				d->object.orderFlags ^= bit;				HU_Menu_SetCheckFromBits( aControl, d->object.orderFlags,					oldValue, oldValue);			}		}			result = true;			break;					case kDP_Usage_Button_ID://			gHera->modalMode++;			BitFlipper_NewWindow( &d->setUsage_WindowID,				"\pDevice Usage",				GetStringList( 8014),				d->object.frame.weapon.usage, dispatchID,				SetUsageBits);			result = true;			break;				case kDP_Usage_ID:		{			unsigned long bit;						if ( whichPart == kControlMenuPart)			{				oldValue = GetBevelMenuValue( aControl) - 1;				bit = 0x01 << oldValue;				d->object.frame.weapon.usage ^= bit;				HU_Menu_SetCheckFromBits( aControl, d->object.frame.weapon.usage,					oldValue, oldValue);			}		}			result = true;			break;				case kCP_Destroy_Action_DontDieFlag_ID:			ReverseCheckBox( aControl);			{				baseObjectType	*o = nil;								if ( d->discreteObjectData != nil)				{					o = (baseObjectType *)HD_DiscreteData_GetNthElement(										d->discreteObjectData, kHera_Object_Type, 0);					mAssert( o != nil);					o->destroyActionNum ^= kDestroyActionDontDieFlag;				}			}			result = true;			break;					case kCP_Destroy_Action_Index_ID - 1:			{				Action_Window_Create( d, whichWindow, dispatchID,					kObject_Editor_DestroyAction, true);			}			result = true;			break;					case (kCP_Destroy_Action_Index_ID + kCP_Edit_Button_Offset):			Action_Window_Create( d, whichWindow, dispatchID,				kObject_Editor_DestroyAction, false);			result = true;			break;					case kCP_Expire_Action_Index_ID - 1:			{				Action_Window_Create( d, whichWindow, dispatchID,					kObject_Editor_ExpireAction, true);			}			result = true;			break;					case (kCP_Expire_Action_Index_ID + kCP_Edit_Button_Offset):			Action_Window_Create( d, whichWindow, dispatchID,				kObject_Editor_ExpireAction, false);			result = true;			break;					case kCP_Create_Action_Index_ID - 1:			{				Action_Window_Create( d, whichWindow, dispatchID,					kObject_Editor_CreateAction, true);			}			result = true;			break;					case (kCP_Create_Action_Index_ID + kCP_Edit_Button_Offset):			Action_Window_Create( d, whichWindow, dispatchID,				kObject_Editor_CreateAction, false);			result = true;			break;					case kCP_Collide_Action_Index_ID - 1:			{				Action_Window_Create( d, whichWindow, dispatchID,					kObject_Editor_CollideAction, true);			}			result = true;			break;					case (kCP_Collide_Action_Index_ID + kCP_Edit_Button_Offset):			Action_Window_Create( d, whichWindow, dispatchID,				kObject_Editor_CollideAction, false);			result = true;			break;					case kCP_Activate_Action_Index_ID - 1:			{				Action_Window_Create( d, whichWindow, dispatchID,					kObject_Editor_ActivateAction, true);			}			result = true;			break;					case (kCP_Activate_Action_Index_ID + kCP_Edit_Button_Offset):			Action_Window_Create( d, whichWindow, dispatchID,				kObject_Editor_ActivateAction, false);			result = true;			break;					case kCP_Arrive_Action_Index_ID - 1:			{				Action_Window_Create( d, whichWindow, dispatchID,					kObject_Editor_ArriveAction, true);			}			result = true;			break;					case (kCP_Arrive_Action_Index_ID + kCP_Edit_Button_Offset):			Action_Window_Create( d, whichWindow, dispatchID,				kObject_Editor_ArriveAction, false);			result = true;			break;							case kRP_Choose_Shape_Button:		{//				baseObjectType *o = (baseObjectType *)*d->objectData +//					d->whichObject;				baseObjectType	*o = nil;								if ( d->discreteObjectData != nil)				{					o = (baseObjectType *)HD_DiscreteData_GetNthElement(										d->discreteObjectData, kHera_Object_Type, 0);					mAssert( o != nil);					Sprite_Selector_NewWindow( d->heraFile,						"\pSelect Sprite", gHera->default_spriteFile_refNum,						d->object.pixResID, dispatchID, true, Sprite_Choose_CallBack);				}			result = true;		}			break;				case kMP_Choose_Shape_Button:		{//				baseObjectType *o = (baseObjectType *)*d->objectData +//					d->whichObject;				baseObjectType	*o = nil;								if ( d->discreteObjectData != nil)				{					o = (baseObjectType *)HD_DiscreteData_GetNthElement(										d->discreteObjectData, kHera_Object_Type, 0);					mAssert( o != nil);					Sprite_Selector_NewWindow( d->heraFile,						"\pSelect Sprite", gHera->default_spriteFile_refNum,						d->object.pixResID, dispatchID, true, Sprite_Animation_Choose_CallBack);				}			result = true;		}			break;				case kWP_Pulse_Weapon_CheckBox_ID:			if ( d->object.pulse >= 0)			{				Pulse_Choose_Callback( dispatchID, -999);			} else			{				long newWindowID = -1;				Str255	tString;								pstrcpy( tString, d->titlePrefix);				pstrcat( tString, "\p: ");				pstrcat( tString, d->longName);				pstrcat( tString, "\p: Pulse Weapon");								ObjectEditor_NewWindow( d->heraFile,					&newWindowID, dispatchID, d->object.pulse, tString,					d->resRefNum, true, false, true, true, Pulse_Choose_Callback);			}			result = true;			break;					case kWP_Pulse_Choose_Button_ID:			{				long newWindowID = -1;				Str255	tString;								pstrcpy( tString, d->titlePrefix);				pstrcat( tString, "\p: ");				pstrcat( tString, d->longName);				pstrcat( tString, "\p: Pulse Weapon");								ObjectEditor_NewWindow( d->heraFile,					&newWindowID, dispatchID, d->object.pulse, tString,					d->resRefNum, true, false, true, true, Pulse_Choose_Callback);			}			result = true;			break;					case kWP_Beam_Weapon_CheckBox_ID:			if ( d->object.beam >= 0)			{				Beam_Choose_Callback( dispatchID, -999);			} else			{				long newWindowID = -1;				Str255	tString;								pstrcpy( tString, d->titlePrefix);				pstrcat( tString, "\p: ");				pstrcat( tString, d->longName);				pstrcat( tString, "\p: Beam Weapon");				ObjectEditor_NewWindow( d->heraFile,					&newWindowID, dispatchID, d->object.beam, tString,					d->resRefNum, true, false, true, true, Beam_Choose_Callback);			}			result = true;			break;					case kWP_Beam_Choose_Button_ID:			{				long newWindowID = -1;				Str255	tString;								pstrcpy( tString, d->titlePrefix);				pstrcat( tString, "\p: ");				pstrcat( tString, d->longName);				pstrcat( tString, "\p: Beam Weapon");								ObjectEditor_NewWindow( d->heraFile,					&newWindowID, dispatchID, d->object.beam, tString,					d->resRefNum, true, false, true, true, Beam_Choose_Callback);			}			result = true;			break;					case kWP_Special_Weapon_CheckBox_ID:			if ( d->object.special >= 0)			{				Special_Choose_Callback( dispatchID, -999);			} else			{				long newWindowID = -1;				Str255	tString;								pstrcpy( tString, d->titlePrefix);				pstrcat( tString, "\p: ");				pstrcat( tString, d->longName);				pstrcat( tString, "\p: Special Weapon");				ObjectEditor_NewWindow( d->heraFile,					&newWindowID, dispatchID, d->object.special, tString,					d->resRefNum, true, false, true, true, Special_Choose_Callback);			}			result = true;			break;					case kWP_Special_Choose_Button_ID:			{				long newWindowID = -1;				Str255	tString;								pstrcpy( tString, d->titlePrefix);				pstrcat( tString, "\p: ");				pstrcat( tString, d->longName);				pstrcat( tString, "\p: Special Weapon");								ObjectEditor_NewWindow( d->heraFile,					&newWindowID, dispatchID, d->object.special, tString,					d->resRefNum, true, false, true, true, Special_Choose_Callback);			}			result = true;			break;				case kAP_Calc_Warpout_Now_ID:/*mlong = mFixedToLong( (mobject)->warpSpeed);\mdouble = mFixedToFloat( (mobject)->maxThrust);\mdouble = (double)(mobject)->warpOutDistance * (double)(mobject)->warpOutDistance * (double)3 + (( (((double)(mobject)->warpOutDistance * (double)(mobject)->warpOutDistance) * 3) * (((double)(mobject)->warpOutDistance * (double)(mobject)->warpOutDistance) * 3)) * mdouble) / (double)2;\(mobject)->warpOutDistance = mdouble;\(mobject)->warpOutDistance *= (mobject)->warpOutDistance;\(mobject)->warpOutDistance /= 3;\// // 4800*/		{			huiPlainControlParamType	dummyParam;			unsigned long				warpSpeed = 0,										warpOutDistance = 0,										thrust = 0;			long						tlong;			double						td, td2, warpTime;												HU_HeweyParam_SetFromHC( d->huiCoordData, kAP_Maximum_Thrust_ID,				&dummyParam);			aControl = HUI_Control_Get( d->panel, dummyParam.layer,				dummyParam.cellx, dummyParam.celly, kAP_Maximum_Thrust_ID);			if ( aControl != nil)				thrust = GetControlTextItemSmallFixed( aControl);						HU_HeweyParam_SetFromHC( d->huiCoordData, kAP_Warp_Speed_ID,				&dummyParam);			aControl = HUI_Control_Get( d->panel, dummyParam.layer,				dummyParam.cellx, dummyParam.celly, kAP_Warp_Speed_ID);			if ( aControl != nil)				warpSpeed = GetControlTextItemLong( aControl);						tlong = mFixedToLong( warpSpeed);			warpTime = tlong * 3;			td = mFixedToFloat( thrust);						td2 = (float)tlong * warpTime;			td2 -= ((warpTime * warpTime) * td) / (float)2;			td2 *= td2;			warpOutDistance = td2;						HU_HeweyParam_SetFromHC( d->huiCoordData, kAP_Warp_Out_Distance_ID,				&dummyParam);			aControl = HUI_Control_Get( d->panel, dummyParam.layer,				dummyParam.cellx, dummyParam.celly, kAP_Warp_Out_Distance_ID);			if ( aControl != nil)			{				SetControlTextItemLong( aControl, warpOutDistance);				Draw1Control( aControl);			}					}			result = true;			break;				case kDP_Calc_Inverse_Speed_Now_ID:		{			smallFixedType	weaponMaxVelocity = 								GetWeaponMaxVelocity( d, nil);			double			td;			huiPlainControlParamType	dummyParam;						HU_HeweyParam_SetFromHC( d->huiCoordData, kDP_Inverse_Speed_ID,				&dummyParam);						if ( weaponMaxVelocity == 0) weaponMaxVelocity = mLongToFixed( 1);			td = mFixedToFloat( weaponMaxVelocity);			td = 1.0 / td;			weaponMaxVelocity = mFloatToFixed( td);						aControl = HUI_Control_Get( d->panel, dummyParam.layer,				dummyParam.cellx, dummyParam.celly, kDP_Inverse_Speed_ID);			if ( aControl != nil)			{				SetControlTextItemSmallFixed( aControl, weaponMaxVelocity);				Draw1Control( aControl);			}		}			result = true;			break;					case kDP_Calc_Range_Now_ID:		{			long			life = 0, range;			smallFixedType	weaponMaxVelocity = 								GetWeaponMaxVelocity( d, &life), tf;			huiPlainControlParamType	dummyParam;						HU_HeweyParam_SetFromHC( d->huiCoordData, kDP_Inverse_Speed_ID,				&dummyParam);						if ( weaponMaxVelocity == 0) weaponMaxVelocity = mLongToFixed( 1);			tf = mLongToFixed( life);			tf = mMultiplyFixed( tf, weaponMaxVelocity);			range = mFixedToLong( tf);			range *= range; 						aControl = HUI_Control_Get( d->panel, dummyParam.layer,				dummyParam.cellx, dummyParam.celly, kDP_Range_ID);			if ( aControl != nil)			{				SetControlTextItemLong( aControl, range);				Draw1Control( aControl);			}		}			result = true;			break;					default:			break;	}	return result;}static void Update_List_Entry( objectWindowType *d, long index){	Str255						classString, raceString, nameString,								idString;	huiPlainControlParamType	dummyParam;	Ptr							data = nil;	long						dataLength = 0, id, l;	ControlHandle				aControl = nil;	ListHandle					list = nil;	Boolean						changed = false, resort = false;		if ( d == nil) return;	if ( index < 0) return;		list = HUI_List_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( list == nil) return;	if ( (**list).dataBounds.bottom <= 0)	{		return;	}		id = PsuedoColumn_List_GetIndex( list, index);	NumToString( id,		idString);		// get the new name	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_LongName_ID,		&dummyParam);		aControl = HUI_Control_Get( d->panel, dummyParam.layer,		dummyParam.cellx, dummyParam.celly, kBS_LongName_ID);	if ( aControl == nil) return;		GetControlTextItemString( aControl, nameString);		BPMOWritePString( nameString);	BPMOWritePString("\p\t");	BPMOWritePString( d->longName);	BPMOWritePString("\p\t");	BPMOWriteLong( pstrcmp( nameString, d->longName));	BPMOWritePString("\p\r");		if ( pstrcmp( nameString, d->longName) != 0)	{		changed = true;		if ( d->sortBy == kSortByName) resort = true;		pstrcpy( d->longName, nameString);	}		// get the new class	HU_HeweyParam_SetFromHC( d->huiCoordData, kAP_Class_ID,		&dummyParam);		aControl = HUI_Control_Get( d->panel, dummyParam.layer,		dummyParam.cellx, dummyParam.celly, kAP_Class_ID);	if ( aControl == nil) return;		l = GetControlTextItemLong( aControl);	if ( l != d->object.baseClass)	{		changed = true;		if ( d->sortBy == kSortByClass) resort = true;		d->object.baseClass = l;	}		// get the new race	HU_HeweyParam_SetFromHC( d->huiCoordData, kAP_Race_ID,		&dummyParam);		aControl = HUI_Control_Get( d->panel, dummyParam.layer,		dummyParam.cellx, dummyParam.celly, kAP_Race_ID);	if ( aControl == nil) return;		l = GetControlTextItemLong( aControl);	if ( l != d->object.baseRace)	{		changed = true;		if ( d->sortBy == kSortByRace) resort = true;		d->object.baseRace = l;	}		if ( !changed) return;		NumToString( d->object.baseClass, classString);	NumToString( d->object.baseRace, raceString);	data = PsuedoColumn_Data_Make( &dataLength,		id,		idString, "\p\t", classString, "\p\t", raceString,		"\p\t", nameString, "\p");		if ( data != nil)	{		HUI_Control_SetListCell( 			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 0, index,			data, dataLength);				DisposePtr( data);	}		/*	aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);		if ( aControl == nil) return;	Draw1Control( aControl);*/	SortObjectList( d, true);}static long Insert_Object( CWindowPtr whichWindow, objectWindowType *d,	long where, Handle discreteObjectSource, heraScenarioFileType *sourceFile){	Ptr							data = nil;	baseObjectType				*oldObject, *newObject;	heraBaseObjectStringsType	*oldStrings, *newStrings;	Handle						newObjectData = nil,								newStringData = nil;	Str255						classString, raceString, nameString,								idString;	long						dataLength, newID = -1, newRow, value;	ControlHandle				aControl;				d->anyChanges = true;	d->heraFile->changed = true;		if (( discreteObjectSource == nil) || ( newRow < 0))		newRow = 0;	else		newRow = where;	newID = HD_Get_NextID_From_Type( d->heraFile,		kHera_Object_Type);	if (( discreteObjectSource == nil) || ( sourceFile == nil))	{		discreteObjectSource = d->discreteObjectData;		sourceFile = d->heraFile;	}		newObjectData = HD_Create_Discrete_Data( d->heraFile,		nil, 0, 1, newID, kHera_Object_Type);	if ( newObjectData != nil)	{		newID = ((heraDataHeaderType *)*newObjectData)->id;	}	newStringData = HD_Create_Discrete_Data( d->heraFile,						nil, 0, 1, newID,						kHera_ObjectStrings_Type);							if (( newObjectData != nil) && ( newStringData != nil))	{		Window_SaveData_FromObjectIndex( d,			whichWindow, d->whichObject);				if ( discreteObjectSource != nil)		{			oldObject = (baseObjectType *)HD_DiscreteData_GetNthElement(				discreteObjectSource, kHera_Object_Type, 0);		} else oldObject = nil;				newObject = (baseObjectType *)HD_DiscreteData_GetNthElement(			newObjectData, kHera_Object_Type, 0);		mAssert( newObject != nil);				if ( oldObject != nil)		{			BlockMove( (Ptr)oldObject, newObject, sizeof( baseObjectType));		} else		{			BaseObject_Clear( newObject);		}		if ( d->discreteObjectStringData != nil)		{			oldStrings = (heraBaseObjectStringsType *)HD_DiscreteData_GetNthElement(				d->discreteObjectStringData, kHera_ObjectStrings_Type, 0);		} else oldStrings = nil;		newStrings = (heraBaseObjectStringsType *)HD_DiscreteData_GetNthElement(			newStringData, kHera_ObjectStrings_Type, 0);		mAssert( newStrings != nil);				if ( oldStrings != nil)		{			BlockMove( (Ptr)oldStrings, newStrings,									sizeof( heraBaseObjectStringsType));		} else		{			pstrcpy( newStrings->shortName, "\pUNTITLED");			pstrcpy( newStrings->longName,"\pUntitled Object");			pstrcpy( newStrings->devNote, "\pNotes for untitled object");		}		NumToString( d->object.baseClass, classString);		NumToString( d->object.baseRace, raceString);		NumToString( newID, idString);				if ( discreteObjectSource != nil)		{			GetObjectNameFromDiscreteObject( sourceFile,				discreteObjectSource,				nameString, 1);		} else		{			nameString[0] = 0;		}				if ( nameString[0] == 0) pstrcpy( nameString, "\puntitled");		data = PsuedoColumn_Data_Make( &dataLength,			newID,			idString, "\p\t", classString, "\p\t", raceString,			"\p\t", nameString, "\p");				value = HUI_Control_GetListLength(				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID);		if ( newRow > value) newRow = value;				if ( data != nil)		{			HUI_Control_InsertListRows(				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, 1, newRow);			HUI_Control_SetListCell( 				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, 0, newRow,				data, dataLength);						DisposePtr( data);						d->whichObject = 				HUI_Control_SetListValue(					d->master, 0, kList_Cell_X, kList_Cell_Y,					kList_ID, newRow);			aControl = HUI_Control_Get( 				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID);			if ( aControl != nil)				Draw1Control( aControl);		}				if ( d->discreteObjectData == nil)		{			d->discreteObjectData = newObjectData;			d->discreteObjectStringData = newStringData;						Enable_Editing( d, true);						Window_SetControls_FromObjectIndex( d, whichWindow,				d->whichObject);		} else		{			d->discreteObjectData = newObjectData;			d->discreteObjectStringData = newStringData;			Window_SetControls_FromObjectIndex( d, whichWindow,				d->whichObject);		}					} else BP_UserError_Literal("Object Editor", "CouldnÕt "		"allocate space for the new object.");	return newID;}static void Window_SetControls_FromObjectIndex( objectWindowType *d,	CWindowPtr window, long index){	baseObjectType			*objectp;	GrafPtr					oldPort;	long					huiCoordNum = GetHandleSize( d->huiCoordData) / sizeof( huiCoordDataType),							i, id;	huiCoordDataType		*huiCoord = nil;	ListHandle				list = nil;	heraBaseObjectStringsType	*objectStrings;	//	objectDataState = HGetState( d->objectData);//	stringDataState = HGetState( d->objectNameStrings);//	HLock( d->objectNameStrings);//	HLock( d->objectData);//	objectp = ((baseObjectType *)*d->objectData) + index;	list = HUI_List_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( list == nil) return;	if ( (**list).dataBounds.bottom <= 0)	{		if ( d->discreteObjectData != nil)			Enable_Editing( d, false);		return;	} if ( d->discreteObjectData == nil) Enable_Editing( d, true);		d->currentObjectID = id = PsuedoColumn_List_GetIndex( list, index);		d->discreteObjectData = HD_Find_Discrete_Data( d->heraFile,		id, 1, nil, kHera_Object_Type);	mAssert( d->discreteObjectData != nil);	objectp = (baseObjectType *)HD_DiscreteData_GetNthElement( d->discreteObjectData,		kHera_Object_Type, 0);		BlockMoveData( objectp, &d->object, sizeof( baseObjectType));		d->discreteObjectStringData = HD_Find_Discrete_Data( d->heraFile,		id, 1, nil,		kHera_ObjectStrings_Type);	mAssert( d->discreteObjectStringData != nil);		objectStrings = (heraBaseObjectStringsType *)HD_DiscreteData_GetNthElement(		d->discreteObjectStringData, kHera_ObjectStrings_Type, 0);	if ( objectStrings != nil)	{		pstrcpy( d->shortName, objectStrings->shortName);		pstrcpy( d->longName, objectStrings->longName);		pstrcpy( d->devNotes, objectStrings->devNote);	}		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);		for ( i = 0; i < huiCoordNum; i++)	{		huiCoord = ((huiCoordDataType *)*d->huiCoordData) + i;		SetObjectField( d, &d->object, huiCoord->id, true);	}//	HSetState( d->objectData, objectDataState);//	HSetState( d->objectNameStrings, stringDataState);	SetPort( oldPort);}static void Window_SaveData_FromObjectIndex( objectWindowType *d, CWindowPtr window,	long index){	huiCoordDataType			*huiCoord = nil;	GrafPtr						oldPort;	baseObjectType				*objectp;	heraBaseObjectStringsType	*objectStrings;	long						huiCoordNum = GetHandleSize( d->huiCoordData) / sizeof( huiCoordDataType),								i;#pragma unused(  index)			GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)window);	if ( d->discreteObjectData == nil) return;	if ( d->chooseOnly) return;		Update_List_Entry( d, index);		for ( i = 0; i < huiCoordNum; i++)	{		huiCoord = ((huiCoordDataType *)*d->huiCoordData) + i;		GetObjectField( d, &d->object, huiCoord->id);	}	objectp = (baseObjectType *)HD_DiscreteData_GetNthElement( d->discreteObjectData,		kHera_Object_Type, 0);			if ( !HU_Data_Is_Identical( (Ptr)objectp, (Ptr)&d->object,		sizeof( baseObjectType)))		d->heraFile->changed = true;			BlockMoveData( &d->object, objectp, sizeof( baseObjectType));	objectStrings = (heraBaseObjectStringsType *)HD_DiscreteData_GetNthElement(		d->discreteObjectStringData, kHera_ObjectStrings_Type, 0);		if ( d->shortName[0] > kObjectShortNameLength)		d->shortName[0] = kObjectShortNameLength;	if ( d->longName[0] > kObjectNameLength)		d->longName[0] = kObjectNameLength;	if ( objectStrings != nil)	{		if ( pstrcmp( d->shortName, objectStrings->shortName) != 0)			d->heraFile->changed = true;		if ( pstrcmp( d->longName, objectStrings->longName) != 0)			d->heraFile->changed = true;		if ( pstrcmp( d->devNotes, objectStrings->devNote) != 0)			d->heraFile->changed = true;		pstrcpy( objectStrings->shortName, d->shortName);		pstrcpy( objectStrings->longName, d->longName);		pstrcpy( objectStrings->devNote, d->devNotes);	}	SetPort( oldPort);}static Boolean Save_From_WindowID( CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	objectWindowType				*d;	Boolean							result = false;		if ( data == nil) return true;		dataState = HGetState( data);	HLock( data);	d = (objectWindowType *)*data;	if ( d->isModal)	{		if ( Button_Window_Modal( "\pUse this selected object?",								"\pBefore saving, the Object Selector "								"must be closed. Click Cancel to "								"abort the save.", nil, nil))		{			Window_SaveData_FromObjectIndex( d, whichWindow, d->whichObject);			OKButton( d, whichWindow);			result =  true;		} else result = false;	} else	{		Window_SaveData_FromObjectIndex( d, whichWindow, d->whichObject);		OKButton( d, whichWindow);		result = true;	}	// data has been deleted; window is closed	return result;}static void CancelButton_From_WindowID( CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	objectWindowType				*d;	if ( data == nil) return;		dataState = HGetState( data);	HLock( data);	d = (objectWindowType *)*data;//	CancelButton( d, whichWindow);		Window_SaveData_FromObjectIndex( d, whichWindow, d->whichObject);		OKButton( d, whichWindow);	// d is now deleted}static void OKButton( objectWindowType *d, CWindowPtr window){	short	oldResFile = CurResFile();		Window_SaveData_FromObjectIndex( d, window, d->whichObject);	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);//	Resource_Replace('bsob', 500, d->objectData, "\pobject data");//	Resource_Replace('STR#', kObjectNameLongStrResID, d->objectNameStrings, "\pobject strings");//	UpdateResFile( d->resRefNum);	UseResFile( oldResFile);		if ( d->isModal) gHera->modalMode--;	if ( !d->chooseOnly)	{		((scenarioInfoType *)*(d->heraFile->scenarioInfo))->warpInFlareID =			d->warpInFlareID;		((scenarioInfoType *)*(d->heraFile->scenarioInfo))->warpOutFlareID =			d->warpOutFlareID;		((scenarioInfoType *)*(d->heraFile->scenarioInfo))->playerBodyID =			d->playerBodyID;		((scenarioInfoType *)*(d->heraFile->scenarioInfo))->energyBlobID =			d->energyBlobID;	}	if ( d->callBack != nil)		d->callBack( d->callerID, d->currentObjectID);//	if ( d->huiCoordData != nil) ReleaseResource( d->huiCoordData);	HUI_MasterControl_Delete( d->master);	CloseDispatchWindow( d->windowID); // d and data no longer valid}static void CancelButton( objectWindowType *d, CWindowPtr window){#pragma unused ( window)	if ( d->callBack != nil)		d->callBack( d->callerID, -1);	HUI_MasterControl_Delete( d->master);	CloseDispatchWindow( d->windowID); // d and data no longer valid//	if ( d->huiCoordData != nil) ReleaseResource( d->huiCoordData);	if ( d->isModal) gHera->modalMode--;}static void RevertButton( objectWindowType *d, CWindowPtr window){#pragma unused ( window)//	Button_Window_NewWindow( "\pRevert Object", true, true,//		-1, -1, Revert_Window_Callback, d->windowID);	if ( !Button_Window_Modal( "\pRevert this object?",							"\pClick Revert to restore this object to its "							"previous values. Click Cancel to "							"keep it as it is.", "\pRevert", nil))	{		return;	}		Revert_Window_Callback( 3, d->windowID);}static void Revert_Window_Callback( long whichButton, long windowID){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	objectWindowType					*d;	if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (objectWindowType *)*data;	if ( whichButton == 2)	{		short	oldRefNum = CurResFile();		Handle	originalStrings = nil;		//		HU_Handle_CopyDataFromResource( d->whichObject, 1, d->objectData, 'bsob', 500,//			d->resRefNum, sizeof( baseObjectType));				if ( d->heraFile->fileRefNum > 0)			UseResFile( d->heraFile->fileRefNum);		else			UseResFile( gHera->default_scenarioFile_refNum);/*		originalStrings = GetStringList( kObjectNameLongStrResID);		if ( originalStrings != nil)		{			Str255	s;						StringListRemove( d->objectNameStrings, (d->whichObject ) + 1);			StringListInstall( d->objectNameStrings, (d->whichObject ) + 1,				StringListElt( originalStrings, (d->whichObject ) + 1));			RetrieveIndString( originalStrings, (d->whichObject ) + 1, s);						HUI_Control_SetListCell( 				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, 0, d->whichObject,				(Ptr)&s[1], s[0]);			StringListRemove( d->objectShortStrings, (d->whichObject ) + 1);			StringListInstall( d->objectShortStrings, (d->whichObject ) + 1,				StringListElt( originalStrings, (d->whichObject ) + 1));			StringListRemove( d->objectNoteStrings, (d->whichObject ) + 1);			StringListInstall( d->objectNoteStrings, (d->whichObject ) + 1,				StringListElt( originalStrings, (d->whichObject ) + 1));			ReleaseResource( originalStrings);		}*/		UseResFile( oldRefNum);		Window_SetControls_FromObjectIndex( d,			GetWindowPtrFromDispatchWindowID( windowID), d->whichObject);	} else if ( whichButton == 3)	{//		DisposeHandle( d->objectData);//		DisposeHandle( d->objectNameStrings);		GetAllData( d);		d->anyChanges = false;	}	HSetState( data, dataState);}static void GetAllData( objectWindowType *d){	short						oldResRefNum = 0;	ControlHandle				aControl;	ListHandle					list;	long						objectNum = 0;	Handle						discreteObjectData;			if ( d == nil) return;	oldResRefNum = CurResFile();	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else		UseResFile( gHera->default_scenarioFile_refNum);		aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);	if ( aControl != nil)	{		Cell		cell;		//		objectNum = GetHandleSize( d->objectData) / sizeof( baseObjectType);		GetListBoxListHandle( aControl, &list);			if ( list != nil)		{			short			i = 1;			Str255			idString, classString, raceString, nameString;			baseObjectType	*o;			Ptr				data = nil;			long			dataLength, objectKind;						LDelRow( 0, 0, list);	// delete all rows			(*list)->selFlags = lOnlyOne;						objectNum = 0;			discreteObjectData = nil;			cell.h = 0;			do			{//				GetIndString( s, 4201, i);//				MakeObjectName( d->objectData, d->objectNameStrings, i, s);				discreteObjectData = HD_DiscreteData_GetNextOfType(					d->heraFile, discreteObjectData, kHera_Object_Type);								if ( discreteObjectData != nil)				{					NumToString( ((heraDataHeaderType *)*discreteObjectData)->id,						idString);//					pstrcat(s, "\p\t");										o = (baseObjectType *)HD_DiscreteData_GetNthElement(						discreteObjectData, kHera_Object_Type, 0);						//					o = (baseObjectType *)*d->objectData + ( i - 1);										objectKind =  GetObjectKind( o);										if ((( objectKind == kDeviceKind) && ( d->includeDevices)) ||						(( objectKind != kDeviceKind) && ( d->includePhysicalObjects)))					{						NumToString( o->baseClass, classString);	//					pstrcat( s, s2);	//					pstrcat(s, "\p\t");						NumToString( o->baseRace, raceString);	//					pstrcat( s, s2);	//					pstrcat(s, "\p\t");						o = nil; // about to become invalid						GetObjectNameFromDiscreteObject( d->heraFile,							discreteObjectData, nameString, 1);												if ( nameString[0] == 0) pstrcpy( nameString, "\puntitled");						data = PsuedoColumn_Data_Make( &dataLength,							((heraDataHeaderType *)*discreteObjectData)->id,							idString, "\p\t", classString, "\p\t", raceString,							"\p\t", nameString, "\p");	//					s2[0] = 0;						//					RetrieveIndString( d->objectNameStrings, i, s2);							//					if ( s2[0] == 0) pstrcpy( s2, "\puntitled");	//					pstrcat( s, s2);						if ( data != nil)						{							LAddRow( 1, (**list).dataBounds.bottom, list );							cell.v = (**list).dataBounds.bottom - 1;							LSetCell( data, dataLength, cell, list );							DisposePtr( data);							objectNum++;						}						i ++;					}				}			} while ( discreteObjectData != nil);		}	}//	objectNum = GetHandleSize( d->objectData) / sizeof( baseObjectType);	if ( objectNum > 0)		if ( d->whichObject >= objectNum) d->whichObject = objectNum - 1;	else		d->whichObject = 0;	GetAllData_error:		UseResFile( oldResRefNum);				SortObjectList( d, false);	d->whichObject = HUI_Control_SetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, d->whichObject);	Window_SetControls_FromObjectIndex( d,		GetWindowPtrFromDispatchWindowID( d->windowID), d->whichObject);}static void SetObjectField( objectWindowType *d, baseObjectType *o, long id,	Boolean draw){	huiPlainControlParamType	dummyParam;	ControlHandle				aControl;	Str255						s, s2;		if ( o == nil) return;	if ( id <= 0) return;		HU_HeweyParam_SetFromHC( d->huiCoordData, id, &dummyParam);	aControl = HUI_Control_Get( d->panel, dummyParam.layer, dummyParam.cellx, dummyParam.celly,		id);	if ( aControl == nil) return;		switch ( id)	{// AP = attributes panel:		case kAP_Class_ID:			SetControlTextItemLong( aControl, o->baseClass);			break;					case kAP_Race_ID:			SetControlTextItemLong( aControl, o->baseRace);			break;					case kAP_Offensive_Value_ID:			SetControlTextItemSmallFixed( aControl, o->offenseValue);			break;					case kAP_Target_Class_ID:			SetControlTextItemLong( aControl, o->destinationClass);			break;					case kAP_Max_Velocity_ID:			SetControlTextItemSmallFixed( aControl, o->maxVelocity);			break;					case kAP_Warp_Speed_ID:			SetControlTextItemLong( aControl, o->warpSpeed);			break;					case kAP_Warp_Out_Distance_ID:			SetControlTextItemLong( aControl, o->warpOutDistance);			break;					case kAP_Calc_Warpout_Now_ID:						break;					case kAP_Initial_Velocity_ID:			SetControlTextItemSmallFixed( aControl, o->initialVelocity);			break;					case kAP_Velocity_Range_ID:			SetControlTextItemSmallFixed( aControl, o->initialVelocityRange);			break;					case kAP_Mass_ID:			SetControlTextItemSmallFixed( aControl, o->mass);			break;					case kAP_Maximum_Thrust_ID:			SetControlTextItemSmallFixed( aControl, o->maxThrust);			break;					case kAP_Health_ID:			SetControlTextItemLong( aControl, o->health);			break;					case kAP_Damage_Caused_ID:			SetControlTextItemLong( aControl, o->damage);			break;					case kAP_Energy_ID:			SetControlTextItemLong( aControl, o->energy);			break;					case kAP_Initial_Age_ID:			SetControlTextItemLong( aControl, o->initialAge);			break;					case kAP_Initial_Age_Range_ID:			SetControlTextItemLong( aControl, o->initialAgeRange);			break;					case kAP_Natural_Scale_ID:			SetControlTextItemLong( aControl, o->naturalScale);			break;					case kAP_Sprite_Layer_ID://			SetControlTextItemLong( aControl, o->pixLayer);			SetControlValue( aControl, o->pixLayer + 1);			break;					case kAP_Long_Range_Size_ID:			BPMOWritePString("\ptiny size:\t");			BPMOWriteLong( o->tinySize);			BPMOWritePString("\p\r");						SetControlTextItemLong( aControl, o->tinySize & kBlipSizeMask);			break;				case kAP_Long_Range_Kind_ID:			SetControlValue( aControl,				((o->tinySize & kBlipTypeMask) >> kBlipTypeShift) + 1);			break;					case kAP_Shield_Color_ID://			SetControlTextItemLong( aControl, o->shieldColor);			if ( o->shieldColor != kNoTinyColor)				SetControlValue( aControl, o->shieldColor + 2);			else				SetControlValue( aControl, -1);			break;					case kAP_Initial_Direction_ID:			SetControlTextItemLong( aControl, o->initialDirection);			break;					case kAP_Direction_Range_ID:			SetControlTextItemLong( aControl, o->initialDirectionRange);			break;					case kAP_Friendly_Needs_ID:			SetControlTextItemSmallFixed( aControl, o->friendDefecit);			break;					case kAP_Danger_Threshold_ID:			SetControlTextItemSmallFixed( aControl, o->dangerThreshold);			break;				case kAP_Price_ID:			SetControlTextItemLong( aControl, o->price);			break;		case kAP_Skill_Numerator_ID:			SetControlTextItemLong( aControl, o->skillNum);			break;				case kAP_Skill_Denominator_ID:			SetControlTextItemLong( aControl, o->skillDen);			break;				case kAP_Build_Ratio_ID:			SetControlTextItemSmallFixed( aControl, o->buildRatio);			break;				case kAP_Build_Time_ID:			SetControlTextItemLong( aControl, o->buildTime);			break;				case kAP_Attribute_Flags_Menu_ID:			HU_Menu_SetCheckFromBits( aControl, o->attributes, 0, 31);			break;					case kAP_Build_Flags_Menu_ID:			HU_Menu_SetCheckFromBits( aControl, o->buildFlags, 0, 31);			break;					case kAP_Order_Flags_Menu_ID:			HU_Menu_SetCheckFromBits( aControl, o->orderFlags, 0, 31);			break;			// WP = weapon panel		case kWP_Pulse_Weapon_CheckBox_ID:			if ( o->pulse >= 0) SetControlValue( aControl, 1);			else SetControlValue( aControl, 0);			break;					case kWP_Pulse_Weapon_ID://			SetControlTextItemLong( aControl, o->pulse);			if ( o->pulse >= 0) GetObjectName_WithID_FromDiscreteObjectID(				d->heraFile, o->pulse, s, 0);			else				pstrcpy( s, "\p-");			SetControlTextItemString( aControl, s);			break;					case kWP_Pulse_Position_Num_ID:			SetControlTextItemLong( aControl, o->pulsePositionNum);			break;					case kWP_Pulse_X_1_ID:			SetControlTextItemSmallFixed( aControl, o->pulsePosition[0].h);			break;					case kWP_Pulse_Y_1_ID:			SetControlTextItemSmallFixed( aControl, o->pulsePosition[0].v);			break;					case kWP_Pulse_X_2_ID:			SetControlTextItemSmallFixed( aControl, o->pulsePosition[1].h);			break;					case kWP_Pulse_Y_2_ID:			SetControlTextItemSmallFixed( aControl, o->pulsePosition[1].v);			break;					case kWP_Pulse_X_3_ID:			SetControlTextItemSmallFixed( aControl, o->pulsePosition[2].h);			break;					case kWP_Pulse_Y_3_ID:			SetControlTextItemSmallFixed( aControl, o->pulsePosition[2].v);			break;					case kWP_Beam_Weapon_CheckBox_ID:			if ( o->beam >= 0) SetControlValue( aControl, 1);			else SetControlValue( aControl, 0);			break;					case kWP_Beam_Weapon_ID://			SetControlTextItemLong( aControl, o->beam);			if ( o->beam >= 0) GetObjectName_WithID_FromDiscreteObjectID(				d->heraFile, o->beam, s, 0);			else				pstrcpy( s, "\p-");			SetControlTextItemString( aControl, s);			break;					case kWP_Beam_Position_Num_ID:			SetControlTextItemLong( aControl, o->beamPositionNum);			break;					case kWP_Beam_X_1_ID:			SetControlTextItemSmallFixed( aControl, o->beamPosition[0].h);			break;					case kWP_Beam_Y_1_ID:			SetControlTextItemSmallFixed( aControl, o->beamPosition[0].v);			break;					case kWP_Beam_X_2_ID:			SetControlTextItemSmallFixed( aControl, o->beamPosition[1].h);			break;					case kWP_Beam_Y_2_ID:			SetControlTextItemSmallFixed( aControl, o->beamPosition[1].v);			break;					case kWP_Beam_X_3_ID:			SetControlTextItemSmallFixed( aControl, o->beamPosition[2].h);			break;					case kWP_Beam_Y_3_ID:			SetControlTextItemSmallFixed( aControl, o->beamPosition[2].v);			break;					case kWP_Special_Weapon_CheckBox_ID:			if ( o->special >= 0) SetControlValue( aControl, 1);			else SetControlValue( aControl, 0);			break;					case kWP_Special_Weapon_ID://			SetControlTextItemLong( aControl, o->special);			if ( o->special >= 0) GetObjectName_WithID_FromDiscreteObjectID(				 d->heraFile, o->special, s, 0);			else				pstrcpy( s, "\p-");			SetControlTextItemString( aControl, s);			break;					case kWP_Special_Position_Num_ID:			SetControlTextItemLong( aControl, o->specialPositionNum);			break;					case kWP_Special_X_1_ID:			SetControlTextItemSmallFixed( aControl, o->specialPosition[0].h);			break;					case kWP_Special_Y_1_ID:			SetControlTextItemSmallFixed( aControl, o->specialPosition[0].v);			break;					case kWP_Special_X_2_ID:			SetControlTextItemSmallFixed( aControl, o->specialPosition[1].h);			break;					case kWP_Special_Y_2_ID:			SetControlTextItemSmallFixed( aControl, o->specialPosition[1].v);			break;					case kWP_Special_X_3_ID:			SetControlTextItemSmallFixed( aControl, o->specialPosition[2].h);			break;					case kWP_Special_Y_3_ID:			SetControlTextItemSmallFixed( aControl, o->specialPosition[2].v);			break;			// CP = action panel		case kCP_Destroy_Action_Index_ID - 1:			SetControlValue( aControl, (o->destroyAction >= 0) ? (1):(0));			break;					case kCP_Destroy_Action_Index_ID://			SetControlTextItemLong( aControl, o->destroyAction);			SetControlTextItemString( aControl, GetActionNameFromDiscreteActionID(				d->heraFile,  o->destroyAction, s, true));			break;					case kCP_Destroy_Action_Num_ID://			SetControlTextItemLong( aControl, o->destroyActionNum & kDestroyActionNotMask);			break;					case kCP_Expire_Action_Index_ID - 1:			SetControlValue( aControl, (o->expireAction >= 0) ? (1):(0));			break;					case kCP_Expire_Action_Index_ID://			SetControlTextItemLong( aControl, o->expireAction);			SetControlTextItemString( aControl, GetActionNameFromDiscreteActionID(				d->heraFile, o->expireAction, s, true));			break;					case kCP_Expire_Action_Num_ID://			SetControlTextItemLong( aControl, o->expireActionNum);			break;					case kCP_Create_Action_Index_ID - 1:			SetControlValue( aControl, (o->createAction >= 0) ? (1):(0));			break;					case kCP_Create_Action_Index_ID://			SetControlTextItemLong( aControl, o->createAction);			SetControlTextItemString( aControl, GetActionNameFromDiscreteActionID(				d->heraFile, o->createAction, s, true));			break;					case kCP_Create_Action_Num_ID://			SetControlTextItemLong( aControl, o->createActionNum);			break;					case kCP_Collide_Action_Index_ID - 1:			SetControlValue( aControl, (o->collideAction >= 0) ? (1):(0));			break;					case kCP_Collide_Action_Index_ID://			SetControlTextItemLong( aControl, o->collideAction);			SetControlTextItemString( aControl, GetActionNameFromDiscreteActionID(				d->heraFile, o->collideAction, s, true));			break;					case kCP_Collide_Action_Num_ID://			SetControlTextItemLong( aControl, o->collideActionNum);			break;					case kCP_Activate_Action_Index_ID - 1:			SetControlValue( aControl, (o->activateAction >= 0) ? (1):(0));			break;					case kCP_Activate_Action_Index_ID://			SetControlTextItemLong( aControl, o->activateAction);			SetControlTextItemString( aControl, GetActionNameFromDiscreteActionID(				d->heraFile, o->activateAction, s, true));			break;					case kCP_Activate_Action_Num_ID://			SetControlTextItemLong( aControl, o->activateActionNum & kPeriodicActionNotMask);			break;					case kCP_Arrive_Action_Index_ID - 1:			SetControlValue( aControl, (o->arriveAction >= 0) ? (1):(0));			break;					case kCP_Arrive_Action_Index_ID://			SetControlTextItemLong( aControl, o->arriveAction);			SetControlTextItemString( aControl, GetActionNameFromDiscreteActionID(				d->heraFile, o->arriveAction, s, true));			break;					case kCP_Arrive_Action_Num_ID://			SetControlTextItemLong( aControl, o->arriveActionNum);			break;				case kCP_Destroy_Action_DontDieFlag_ID:			SetControlValue( aControl, (o->destroyActionNum & kDestroyActionDontDieFlag)?				1:0);			break;				case kCP_Arrive_Action_Distance_ID:			SetControlTextItemLong( aControl, o->arriveActionDistance);			break;					case kCP_Periodic_Time_ID:			SetControlTextItemLong( aControl, (o->activateActionNum & kPeriodicActionTimeMask)				>> kPeriodicActionTimeShift);			break;					case kCP_Periodic_Time_Range_ID:			SetControlTextItemLong( aControl, (o->activateActionNum & kPeriodicActionRangeMask)				>> kPeriodicActionRangeShift);			break;// BS = basic panel		case kBS_ShortName_ID:			SetControlTextItemString( aControl, d->shortName);			break;				case kBS_ShortName_Len_ID:			pstrcpy( s, "\p(");			NumToString( d->shortName[0], s2);			pstrcat( s, s2);			pstrcat( s, "\p/");			NumToString( kObjectShortNameLength, s2);			pstrcat( s, s2);			pstrcat( s, "\p)");			SetControlTextItemString( aControl, s);			break;					case kBS_LongName_ID:			SetControlTextItemString( aControl, d->longName);			break;				case kBS_LongName_Len_ID:			pstrcpy( s, "\p(");			NumToString( d->longName[0], s2);			pstrcat( s, s2);			pstrcat( s, "\p/");			NumToString( kObjectNameLength, s2);			pstrcat( s, s2);			pstrcat( s, "\p)");			SetControlTextItemString( aControl, s);			break;					case kBS_DevNote_ID:			SetControlTextItemString( aControl, d->devNotes);			break;				case kBS_DevNote_Len_ID:			pstrcpy( s, "\p(");			NumToString( d->devNotes[0], s2);			pstrcat( s, s2);			pstrcat( s, "\p/");			NumToString( 255, s2);			pstrcat( s, s2);			pstrcat( s, "\p)");			SetControlTextItemString( aControl, s);			break;					case kBS_PictureResID_ID:			SetControlTextItemLong( aControl, o->pictPortraitResID);			break;				case kBS_Blessings_Group_ID:			if ( d->currentObjectID == d->warpInFlareID)			{				SetControlValue( aControl, 2);			} else if ( d->currentObjectID == d->warpOutFlareID)			{				SetControlValue( aControl, 3);			} else if ( d->currentObjectID == d->playerBodyID)			{				SetControlValue( aControl, 4);			} else if ( d->currentObjectID == d->energyBlobID)			{				SetControlValue( aControl, 5);			} else			{				SetControlValue( aControl, 1);			}			break;			// RP = rotating sprite panel		case kRP_Shape_Offset_ID:			if ( GetObjectKind( o) == kRotateSpriteKind)			{				SetControlTextItemLong( aControl, o->frame.rotation.shapeOffset);			}			break;					case kRP_Rot_Res_ID:			if ( GetObjectKind( o) == kRotateSpriteKind)			{				SetControlTextItemLong( aControl, o->frame.rotation.rotRes);			}			break;					case kRP_Max_Turn_Rate_ID:			if ( GetObjectKind( o) == kRotateSpriteKind)			{				SetControlTextItemSmallFixed( aControl, o->frame.rotation.maxTurnRate);			}			break;					case kRP_Turn_Acceleration_ID:			if ( GetObjectKind( o) == kRotateSpriteKind)			{				SetControlTextItemSmallFixed( aControl, o->frame.rotation.turnAcceleration);			}			break;					case kRP_Shape_Field_ID:			if ( GetObjectKind( o) == kRotateSpriteKind)			{				short	oldResFile = CurResFile();				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_spriteFile_refNum);				SetControlTextItemString( aControl, HNM_Resource_Name_Make(					d->heraFile, 'SMIV', o->pixResID, s));								UseResFile( oldResFile);			}			break;				case kMP_Shape_Field:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				short	oldResFile = CurResFile();				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_spriteFile_refNum);				SetControlTextItemString( aControl, HNM_Resource_Name_Make(					d->heraFile, 'SMIV', o->pixResID, s));								UseResFile( oldResFile);			}			break;// MP = animation panel		case kMP_First_Shape_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				SetControlTextItemLong( aControl, o->frame.animation.firstShape);			}			break;					case kMP_Last_Shape_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				SetControlTextItemLong( aControl, o->frame.animation.lastShape);			}			break;					case kMP_Frame_Direction_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				SetControlTextItemLong( aControl, o->frame.animation.frameDirection);			}			break;					case kMP_Frame_Direction_Range_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				SetControlTextItemLong( aControl, o->frame.animation.frameDirectionRange);			}			break;					case kMP_Frame_Speed_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				SetControlTextItemLong( aControl, o->frame.animation.frameSpeed);			}			break;					case kMP_Frame_Speed_Range_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				SetControlTextItemLong( aControl, o->frame.animation.frameSpeedRange);			}			break;					case kMP_Frame_Shape_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				SetControlTextItemLong( aControl, o->frame.animation.frameShape);			}			break;					case kMP_Frame_Shape_Range_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				SetControlTextItemLong( aControl, o->frame.animation.frameShapeRange);			}			break;			// BP = beam panel		case kBP_Color_ID:			if ( GetObjectKind( o) == kBeamKind)			{				if ( o->frame.beam.color <= 16)					SetControlValue( aControl, 1);				else				{					SetControlValue( aControl, (o->frame.beam.color / 16) + 1);					BPMOWritePString("\p\rbrighntess: ");					BPMOWriteLong( o->frame.beam.color % 16);					BPMOWritePString("\p\r");				}			}			break;					case kBP_Kind_ID:			if ( GetObjectKind( o) == kBeamKind)			{				SetControlValue( aControl, o->frame.beam.kind + 1);			}			break;					case kBP_Accuracy_ID:			if ( GetObjectKind( o) == kBeamKind)			{				SetControlTextItemLong( aControl, o->frame.beam.accuracy);			}			break;					case kBP_Range_ID:			if ( GetObjectKind( o) == kBeamKind)			{				SetControlTextItemLong( aControl, o->frame.beam.range);			}			break;			// DP = device panel		case kDP_Energy_Cost_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				SetControlTextItemLong( aControl, o->frame.weapon.energyCost);			}			break;					case kDP_Fire_Time_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				SetControlTextItemLong( aControl, o->frame.weapon.fireTime);			}			break;					case kDP_Ammo_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				SetControlTextItemLong( aControl, o->frame.weapon.ammo);			}			break;					case kDP_Range_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				SetControlTextItemLong( aControl, o->frame.weapon.range);			}			break;					case kDP_Inverse_Speed_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				SetControlTextItemSmallFixed( aControl, o->frame.weapon.inverseSpeed);			}			break;					case kDP_Calc_Inverse_Speed_Now_ID:			// button; do nothing			break;					case kDP_Restock_Cost_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				SetControlTextItemLong( aControl, o->frame.weapon.restockCost);			}			break;		case kDP_Usage_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				HU_Menu_SetCheckFromBits( aControl, o->frame.weapon.usage, 0, 2);			}			break;				}	if ( draw) Draw1Control( aControl);}static void GetObjectField( objectWindowType *d, baseObjectType *o, long id){	huiPlainControlParamType	dummyParam;	ControlHandle				aControl;		if ( o == nil) return;	if ( id <= 0) return;		HU_HeweyParam_SetFromHC( d->huiCoordData, id, &dummyParam);	aControl = HUI_Control_Get( d->panel, dummyParam.layer, dummyParam.cellx, dummyParam.celly,		id);	if ( aControl == nil) return;		switch ( id)	{// AP = attributes panel:		case kAP_Class_ID:			 o->baseClass= GetControlTextItemLong( aControl);			break;					case kAP_Race_ID:			o->baseRace= GetControlTextItemLong( aControl);			break;					case kAP_Offensive_Value_ID:			o->offenseValue = GetControlTextItemSmallFixed( aControl);			break;					case kAP_Target_Class_ID:			o->destinationClass = GetControlTextItemLong( aControl);			break;					case kAP_Max_Velocity_ID:			o->maxVelocity = GetControlTextItemSmallFixed( aControl);			break;					case kAP_Warp_Speed_ID:			o->warpSpeed = GetControlTextItemLong( aControl);			break;					case kAP_Warp_Out_Distance_ID:			o->warpOutDistance = GetControlTextItemLong( aControl);			break;					case kAP_Calc_Warpout_Now_ID:						break;					case kAP_Initial_Velocity_ID:			o->initialVelocity = GetControlTextItemSmallFixed( aControl);			break;					case kAP_Velocity_Range_ID:			o->initialVelocityRange = GetControlTextItemSmallFixed( aControl);			break;					case kAP_Mass_ID:			o->mass = GetControlTextItemSmallFixed( aControl);			break;					case kAP_Maximum_Thrust_ID:			o->maxThrust = GetControlTextItemSmallFixed( aControl);			break;					case kAP_Health_ID:			o->health = GetControlTextItemLong( aControl);			break;					case kAP_Damage_Caused_ID:			o->damage = GetControlTextItemLong( aControl);			break;					case kAP_Energy_ID:			o->energy = GetControlTextItemLong( aControl);			break;					case kAP_Initial_Age_ID:			o->initialAge = GetControlTextItemLong( aControl);			break;					case kAP_Initial_Age_Range_ID:			o->initialAgeRange = GetControlTextItemLong( aControl);			break;					case kAP_Natural_Scale_ID:			o->naturalScale = GetControlTextItemLong( aControl);			break;					case kAP_Sprite_Layer_ID://			o-> = GetControlTextItemLong( aControl, o->pixLayer);			o->pixLayer = GetControlValue( aControl) - 1;			break;					case kAP_Long_Range_Size_ID:			o->tinySize = (o->tinySize & ~kBlipSizeMask) |				(GetControlTextItemLong( aControl) & kBlipSizeMask);			break;				case kAP_Long_Range_Kind_ID:			o->tinySize = (o->tinySize & ~kBlipTypeMask) |				(((GetControlValue( aControl) - 1) << kBlipTypeShift)				& kBlipTypeMask);			break;					case kAP_Shield_Color_ID:			o->shieldColor = GetControlValue( aControl);//GetControlTextItemLong( aControl);			if ( o->shieldColor != kNoTinyColor)				o->shieldColor -= 2;			break;					case kAP_Initial_Direction_ID:			o->initialDirection = GetControlTextItemLong( aControl);			break;					case kAP_Direction_Range_ID:			o->initialDirectionRange = GetControlTextItemLong( aControl);			break;					case kAP_Friendly_Needs_ID:			o->friendDefecit = GetControlTextItemSmallFixed( aControl);			break;					case kAP_Danger_Threshold_ID:			o->dangerThreshold = GetControlTextItemSmallFixed( aControl);			break;				case kAP_Price_ID:			o->price = GetControlTextItemLong( aControl);			break;		case kAP_Skill_Numerator_ID:			o->skillNum = GetControlTextItemLong( aControl);			break;				case kAP_Skill_Denominator_ID:			o->skillDen = GetControlTextItemLong( aControl);			break;				case kAP_Build_Ratio_ID:			o->buildRatio = GetControlTextItemSmallFixed( aControl);			break;				case kAP_Build_Time_ID:			o->buildTime = GetControlTextItemLong( aControl);			break;				case kAP_Attribute_Flags_Menu_ID:			// set when menu events handled			break;					case kAP_Build_Flags_Menu_ID:			// set when menu events handled			break;					case kAP_Order_Flags_Menu_ID:			// set when menu events handled			break;			// WP = weapon panel		case kWP_Pulse_Weapon_ID://			o->pulse = GetControlTextItemLong( aControl);			break;					case kWP_Pulse_Position_Num_ID:			o->pulsePositionNum = GetControlTextItemLong( aControl);			break;					case kWP_Pulse_X_1_ID:			o->pulsePosition[0].h = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Pulse_Y_1_ID:			o->pulsePosition[0].v = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Pulse_X_2_ID:			o->pulsePosition[1].h = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Pulse_Y_2_ID:			o->pulsePosition[1].v = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Pulse_X_3_ID:			o->pulsePosition[2].h = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Pulse_Y_3_ID:			o->pulsePosition[2].v = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Beam_Weapon_ID://			o->beam = GetControlTextItemLong( aControl);			break;					case kWP_Beam_Position_Num_ID:			o->beamPositionNum = GetControlTextItemLong( aControl);			break;					case kWP_Beam_X_1_ID:			o->beamPosition[0].h = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Beam_Y_1_ID:			o->beamPosition[0].v = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Beam_X_2_ID:			o->beamPosition[1].h = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Beam_Y_2_ID:			o->beamPosition[1].v = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Beam_X_3_ID:			o->beamPosition[2].h = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Beam_Y_3_ID:			o->beamPosition[2].v = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Special_Weapon_ID://			o->special = GetControlTextItemLong( aControl);			break;					case kWP_Special_Position_Num_ID:			o->specialPositionNum = GetControlTextItemLong( aControl);			break;					case kWP_Special_X_1_ID:			o->specialPosition[0].h = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Special_Y_1_ID:			o->specialPosition[0].v = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Special_X_2_ID:			o->specialPosition[1].h = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Special_Y_2_ID:			o->specialPosition[1].v = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Special_X_3_ID:			o->specialPosition[2].h = GetControlTextItemSmallFixed( aControl);			break;					case kWP_Special_Y_3_ID:			o->specialPosition[2].v = GetControlTextItemSmallFixed( aControl);			break;			// CP = action panel		case kCP_Destroy_Action_Index_ID://			o->destroyAction = GetControlTextItemLong( aControl);			break;					case kCP_Destroy_Action_Num_ID://			o->destroyActionNum = (o->destroyActionNum & ~kDestroyActionNotMask) |//				(GetControlTextItemLong( aControl) & kDestroyActionNotMask);			break;					case kCP_Expire_Action_Index_ID://			o->expireAction = GetControlTextItemLong( aControl);			break;					case kCP_Expire_Action_Num_ID://			o->expireActionNum = GetControlTextItemLong( aControl);			break;					case kCP_Create_Action_Index_ID://			o->createAction = GetControlTextItemLong( aControl);			break;					case kCP_Create_Action_Num_ID://			o->createActionNum = GetControlTextItemLong( aControl);			break;					case kCP_Collide_Action_Index_ID://			o->collideAction = GetControlTextItemLong( aControl);			break;					case kCP_Collide_Action_Num_ID://			o->collideActionNum = GetControlTextItemLong( aControl);			break;					case kCP_Activate_Action_Index_ID://			o->activateAction = GetControlTextItemLong( aControl);			break;					case kCP_Activate_Action_Num_ID://			o->activateActionNum = (o->activateActionNum & ~kPeriodicActionNotMask) |//				 (GetControlTextItemLong( aControl) & kPeriodicActionNotMask); 			break;					case kCP_Arrive_Action_Index_ID://			o->arriveAction = GetControlTextItemLong( aControl);			break;					case kCP_Arrive_Action_Num_ID://			o->arriveActionNum = GetControlTextItemLong( aControl);			break;				case kCP_Destroy_Action_DontDieFlag_ID:			o->destroyActionNum = (o->destroyActionNum & ~kDestroyActionDontDieFlag)									| ((GetControlValue( aControl))										? (kDestroyActionDontDieFlag) : (0));													break;				case kCP_Arrive_Action_Distance_ID:			o->arriveActionDistance = GetControlTextItemLong( aControl);			break;					case kCP_Periodic_Time_ID:			o->activateActionNum = (o->activateActionNum & ~kPeriodicActionTimeMask)				| ((GetControlTextItemLong( aControl) << kPeriodicActionTimeShift)					& kPeriodicActionTimeMask);			break;					case kCP_Periodic_Time_Range_ID:			o->activateActionNum = (o->activateActionNum & ~kPeriodicActionRangeMask)				| ((GetControlTextItemLong( aControl) << kPeriodicActionRangeShift)					& kPeriodicActionRangeMask);			break;// BS = basic panel		case kBS_ShortName_ID:			GetControlTextItemString( aControl, d->shortName);			break;				case kBS_ShortName_Len_ID:			break;					case kBS_LongName_ID:			GetControlTextItemString( aControl, d->longName);			break;				case kBS_LongName_Len_ID:			break;					case kBS_DevNote_ID:			GetControlTextItemString( aControl, d->devNotes);			break;				case kBS_DevNote_Len_ID:			break;					case kBS_PictureResID_ID:			o->pictPortraitResID = GetControlTextItemLong( aControl);			break;					case kBS_Blessings_Group_ID:			switch( GetControlValue( aControl))			{				case 1:					break;								case 2:					d->warpInFlareID = d->currentObjectID;					break;				case 3:					d->warpOutFlareID = d->currentObjectID;					break;								case 4:					d->playerBodyID = d->currentObjectID;					break;								case 5:					d->energyBlobID = d->currentObjectID;					break;							}			break;			// RP = rotating sprite panel		case kRP_Shape_Offset_ID:			if ( GetObjectKind( o) == kRotateSpriteKind)			{				o->frame.rotation.shapeOffset = GetControlTextItemLong( aControl);			}			break;					case kRP_Rot_Res_ID:			if ( GetObjectKind( o) == kRotateSpriteKind)			{				o->frame.rotation.rotRes = GetControlTextItemLong( aControl);			}			break;					case kRP_Max_Turn_Rate_ID:			if ( GetObjectKind( o) == kRotateSpriteKind)			{				o->frame.rotation.maxTurnRate = GetControlTextItemSmallFixed( aControl);			}			break;					case kRP_Turn_Acceleration_ID:			if ( GetObjectKind( o) == kRotateSpriteKind)			{				o->frame.rotation.turnAcceleration = GetControlTextItemSmallFixed( aControl);			}			break;			// MP = animation panel		case kMP_First_Shape_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				o->frame.animation.firstShape = GetControlTextItemLong( aControl);			}			break;					case kMP_Last_Shape_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				o->frame.animation.lastShape = GetControlTextItemLong( aControl);			}			break;					case kMP_Frame_Direction_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				o->frame.animation.frameDirection = GetControlTextItemLong( aControl);			}			break;					case kMP_Frame_Direction_Range_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				o->frame.animation.frameDirectionRange = GetControlTextItemLong( aControl);			}			break;					case kMP_Frame_Speed_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				o->frame.animation.frameSpeed = GetControlTextItemLong( aControl);			}			break;					case kMP_Frame_Speed_Range_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				o->frame.animation.frameSpeedRange = GetControlTextItemLong( aControl);			}			break;					case kMP_Frame_Shape_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				o->frame.animation.frameShape = GetControlTextItemLong( aControl);			}			break;					case kMP_Frame_Shape_Range_ID:			if ( GetObjectKind( o) == kAnimatedSpriteKind)			{				o->frame.animation.frameShapeRange = GetControlTextItemLong( aControl);			}			break;			// BP = beam panel		case kBP_Color_ID:			if ( GetObjectKind( o) == kBeamKind)			{				short	v = GetControlValue( aControl) - 1;								if ( v == 0)					o->frame.beam.color = 0;				else					o->frame.beam.color = (v * 16) + 1;			}			break;					case kBP_Kind_ID:			if ( GetObjectKind( o) == kBeamKind)			{				o->frame.beam.kind = (beamKindType)(GetControlValue( aControl) - 1);			}			break;					case kBP_Accuracy_ID:			if ( GetObjectKind( o) == kBeamKind)			{				o->frame.beam.accuracy = GetControlTextItemLong( aControl);			}			break;					case kBP_Range_ID:			if ( GetObjectKind( o) == kBeamKind)			{				o->frame.beam.range = GetControlTextItemLong( aControl);			}			break;			// DP = device panel		case kDP_Energy_Cost_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				o->frame.weapon.energyCost = GetControlTextItemLong( aControl);			}			break;					case kDP_Fire_Time_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				o->frame.weapon.fireTime = GetControlTextItemLong( aControl);			}			break;					case kDP_Ammo_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				o->frame.weapon.ammo = GetControlTextItemLong( aControl);			}			break;					case kDP_Range_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				o->frame.weapon.range = GetControlTextItemLong( aControl);			}			break;					case kDP_Inverse_Speed_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				o->frame.weapon.inverseSpeed = GetControlTextItemSmallFixed( aControl);			}			break;					case kDP_Calc_Inverse_Speed_Now_ID:			// button; do nothing			break;					case kDP_Restock_Cost_ID:			if ( GetObjectKind( o) == kDeviceKind)			{				o->frame.weapon.restockCost = GetControlTextItemLong( aControl);			}			break;		case kDP_Usage_ID:			break;				}}static long GetObjectKind( baseObjectType *o){	if ( o->attributes & kShapeFromDirection)	{		return( kRotateSpriteKind);	} else if ( o->attributes & kIsSelfAnimated)	{		return ( kAnimatedSpriteKind);	} else if ( o->attributes & kIsBeam)	{		return ( kBeamKind);	} else return ( kDeviceKind);}static long CorrectPanelNumber( long panelNumber, baseObjectType *o){	if ( panelNumber <= kCP_Panel_Index) return panelNumber;	return kCP_Panel_Index + 1 + GetObjectKind( o);}static void ChangePanelNumber( objectWindowType *d, long newPanelNumber){	OSErr			err;	long			gestaltInfo;	ControlHandle	aControl;	Rect			controlBounds;	WindowPtr		theWindow;			long oldPanel = d->currentPanel;		d->currentPanel = CorrectPanelNumber( newPanelNumber, &d->object);		if ( d->currentPanel != oldPanel)		{			HUI_Master_HideLayer( d->panel, oldPanel);			HUI_Master_ShowLayer( d->panel, d->currentPanel);		}	HU_AutoDefocus( GetWindowPtrFromDispatchWindowID( d->windowID));	err = Gestalt( gestaltAppearanceVersion, &gestaltInfo);	if ( err != noErr)	{		return;	}		if ( gestaltInfo > 0x101) return;		aControl = HUI_Control_Get( d->master, 0, kMain_Cell_X,					kMain_Cell_Y, kTab_ID);					if ( aControl == nil) return;	theWindow = GetWindowPtrFromDispatchWindowID( d->windowID);	if ( theWindow != nil)	{		CU_GetControlBounds( aControl, &controlBounds);		InvalWindowRect( theWindow, &controlBounds);	}	}static void UpdateLengthField( objectWindowType *d, long lengthFieldID,	Boolean draw){	huiPlainControlParamType	dummyParam;	ControlHandle				aControl;	long						id, length;	Str255						name, s, s2;		switch( lengthFieldID)	{		case kBS_ShortName_Len_ID:			id = kBS_ShortName_ID;			length = kObjectShortNameLength;			break;		case kBS_LongName_Len_ID:			id = kBS_LongName_ID;			length = kObjectNameLength;			break;		case kBS_DevNote_Len_ID:			id = kBS_DevNote_ID;			length = 255;			break;				default:			return;			break;	}		HU_HeweyParam_SetFromHC( d->huiCoordData, id, &dummyParam);	aControl = HUI_Control_Get( d->panel, dummyParam.layer, dummyParam.cellx, dummyParam.celly,		id);	if ( aControl == nil) return;/*		switch( lengthFieldID)	{		case kBS_ShortName_Len_ID:			GetControlTextItemString( aControl, d->shortName);			break;		case kBS_LongName_Len_ID:			GetControlTextItemString( aControl, d->longName);			break;		case kBS_DevNote_Len_ID:			GetControlTextItemString( aControl, d->devNotes);			break;	}*/	GetControlTextItemString( aControl, name);	pstrcpy( s, "\p(");	NumToString(name[0], s2);	pstrcat( s, s2);	pstrcat( s, "\p/");	NumToString( length, s2);	pstrcat( s, s2);	pstrcat( s, "\p)");	HU_HeweyParam_SetFromHC( d->huiCoordData, lengthFieldID, &dummyParam);	aControl = HUI_Control_Get( d->panel, dummyParam.layer, dummyParam.cellx, dummyParam.celly,		lengthFieldID);	if ( aControl == nil) return;	SetControlTextItemString( aControl, s);		if ( draw)		Draw1Control( aControl);	//	SetObjectField( d, &d->object, lengthFieldID, draw);}static void SetAttributeBits( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	objectWindowType					*d;	huiPlainControlParamType		dummyParam;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (objectWindowType *)*data;	HU_HeweyParam_SetFromHC( d->huiCoordData, kAP_Attribute_Flags_Menu_ID, &dummyParam);		d->object.attributes = bits;	HU_HUIMenu_SetCheckFromBits( d->panel, dummyParam.layer, dummyParam.cellx, dummyParam.celly,		kAP_Attribute_Flags_Menu_ID, bits, 0, 31);		HSetState( data, dataState);}static void SetOrderBits( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	objectWindowType					*d;	huiPlainControlParamType		dummyParam;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (objectWindowType *)*data;	HU_HeweyParam_SetFromHC( d->huiCoordData, kAP_Order_Flags_Menu_ID, &dummyParam);		d->object.orderFlags = bits;	HU_HUIMenu_SetCheckFromBits( d->panel, dummyParam.layer, dummyParam.cellx, dummyParam.celly,		kAP_Order_Flags_Menu_ID, bits, 0, 31);		HSetState( data, dataState);}static void SetBuildBits( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	objectWindowType					*d;	huiPlainControlParamType		dummyParam;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (objectWindowType *)*data;	HU_HeweyParam_SetFromHC( d->huiCoordData, kAP_Build_Flags_Menu_ID, &dummyParam);		d->object.buildFlags = bits;	HU_HUIMenu_SetCheckFromBits( d->panel, dummyParam.layer, dummyParam.cellx, dummyParam.celly,		kAP_Build_Flags_Menu_ID, bits, 0, 31);		HSetState( data, dataState);}static void SetUsageBits( long windowID, unsigned long bits){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	objectWindowType					*d;	huiPlainControlParamType		dummyParam;		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (objectWindowType *)*data;	HU_HeweyParam_SetFromHC( d->huiCoordData, kDP_Usage_ID, &dummyParam);		d->object.frame.weapon.usage = bits;	HU_HUIMenu_SetCheckFromBits( d->panel, dummyParam.layer, dummyParam.cellx, dummyParam.celly,		kDP_Usage_ID, bits, 0, 2);		HSetState( data, dataState);}static short CompareCellsByName( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	race_string_a, race_string_b, class_string_a, class_string_b, name_string_a, name_string_b;	long	race_a, race_b, class_a, class_b, result = 0;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, nil, class_string_a,		race_string_a, name_string_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, nil, class_string_b,		race_string_b, name_string_b, -1);	StringToNum( race_string_a, &race_a);	StringToNum( race_string_b, &race_b);	StringToNum( class_string_a, &class_a);	StringToNum( class_string_b, &class_b);	result =  -pstrcmp_nocase( name_string_a, name_string_b);	if ( result != 0)	{		return result;	} else	{		if ( race_a < race_b)		{			return 1;		} else if ( race_a > race_b)		{			return -1;		} else		{			if ( class_a < class_b)			{				return 1;			} else if ( class_a > class_b)			{				return -1;			} else			{				return 0;			}		}	}}static short CompareCellsByID( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	id_string_a, id_string_b;	long	id_a, id_b;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, id_string_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, id_string_b, -1);	StringToNum( id_string_a, &id_a);	StringToNum( id_string_b, &id_b);	if ( id_a < id_b)	{		return 1;	} else if ( id_a > id_b)	{		return -1;	} else	{		return 0;	}}static short CompareCellsByClass( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	race_string_a, race_string_b, class_string_a, class_string_b, name_string_a, name_string_b;	long	race_a, race_b, class_a, class_b;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, nil, class_string_a,		race_string_a, name_string_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, nil, class_string_b,		race_string_b, name_string_b, -1);	StringToNum( race_string_a, &race_a);	StringToNum( race_string_b, &race_b);	StringToNum( class_string_a, &class_a);	StringToNum( class_string_b, &class_b);	if ( class_a < class_b)	{		return 1;	} else if ( class_a > class_b)	{		return -1;	} else	{		if ( race_a < race_b)		{			return 1;		} else if ( race_a > race_b)		{			return -1;		} else		{			return -pstrcmp_nocase( name_string_a, name_string_b);		}	}}static short CompareCellsByRace( Ptr cell_a, long length_a, Ptr cell_b, long length_b){	Str255	race_string_a, race_string_b, class_string_a, class_string_b, name_string_a, name_string_b;	long	race_a, race_b, class_a, class_b;		PsuedoColumn_String_GetAll( cell_a, length_a, nil, nil, class_string_a,		race_string_a, name_string_a, -1);	PsuedoColumn_String_GetAll( cell_b, length_b, nil, nil, class_string_b,		race_string_b, name_string_b, -1);	StringToNum( race_string_a, &race_a);	StringToNum( race_string_b, &race_b);	StringToNum( class_string_a, &class_a);	StringToNum( class_string_b, &class_b);	if ( race_a < race_b)	{		return 1;	} else if ( race_a > race_b)	{		return -1;	} else	{		if ( class_a < class_b)		{			return 1;		} else if ( class_a > class_b)		{			return -1;		} else		{			return -pstrcmp_nocase( name_string_a, name_string_b);		}	}}static OSErr SortObjectList( objectWindowType *d, Boolean draw){	short			currentSelectionIndex = 0, dataLength = 0;	long			currentSelectionReference = 0, i = 0, thisReference;	Ptr				data = nil;	OSErr			err = noErr;	ControlHandle	aControl = nil;	ListHandle		list = nil;	Boolean 		done, found;		// in order to preserve the selection,	// we have to get it's arbitrary reference #		currentSelectionIndex =  HUI_Control_GetListValue(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, d->whichObject);		aControl = HUI_Control_Get( 		d->master, 0, kList_Cell_X, kList_Cell_Y,		kList_ID);			if ( aControl == nil) return paramErr;	GetListBoxListHandle( aControl, &list);		if ( list == nil) return paramErr;		data = List_Utilities_GetCell(list, (Point){currentSelectionIndex, 0},		&dataLength);		if ( data == nil) return memFullErr;		PsuedoColumn_String_GetAll( data, dataLength,		&currentSelectionReference, (StringPtr)-1);	DisposePtr( data);	if ( d->currentObjectID >= 0) currentSelectionReference = d->currentObjectID;	switch( d->sortBy)	{			case kSortByName:			err = List_Utilities_QSort( list, (Point){0, 0},				(Point){(**list).dataBounds.bottom - 1, 0},				CompareCellsByName);			break;				case kSortByID:			err = List_Utilities_QSort( list, (Point){0, 0},				(Point){(**list).dataBounds.bottom - 1, 0},				CompareCellsByID);			break;			case kSortByClass:			err = List_Utilities_QSort( list, (Point){0, 0},				(Point){(**list).dataBounds.bottom - 1, 0},				CompareCellsByClass);			break;			case kSortByRace:			err = List_Utilities_QSort( list, (Point){0, 0},				(Point){(**list).dataBounds.bottom - 1, 0},				CompareCellsByRace);			break;	}		// now we have to find our selection; we may as well start with its original	// position		done = found = false;	i = 0;		while (( !done) && ( !found))	{		if ( (currentSelectionIndex + i) < (**list).dataBounds.bottom)		{			data = List_Utilities_GetCell(list, (Point){currentSelectionIndex + i, 0},				&dataLength);			if ( data != nil)			{				PsuedoColumn_String_GetAll( data, dataLength,					&thisReference, (StringPtr)-1);								if ( thisReference == currentSelectionReference)				{					found = true;					currentSelectionIndex = currentSelectionIndex + i;				}				DisposePtr( data);			}		} else done = true;		if ( (currentSelectionIndex - i) >= 0)		{			data = List_Utilities_GetCell(list, (Point){currentSelectionIndex - i, 0},				&dataLength);			if ( data != nil)			{				PsuedoColumn_String_GetAll( data, dataLength,					&thisReference, (StringPtr)-1);								if ( thisReference == currentSelectionReference)				{					found = true;					currentSelectionIndex = currentSelectionIndex - i;				}				DisposePtr( data);			}			done = false;		} else		{			// do nothing; if done was previously true, keep it true			// if it was false, keep it false		}		i++;	}	d->whichObject = HUI_Control_SetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, currentSelectionIndex);	LAutoScroll( list);	if ( draw) Draw1Control( aControl);		return err;}static void Pulse_Choose_Callback( long dispatchID, long objectChoiceID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	objectWindowType				*d = nil;	huiPlainControlParamType		dummyParam;	if (( objectChoiceID < 0) && ( objectChoiceID != -999)) return;	if ( objectChoiceID < 0) objectChoiceID = -1;		if ( data == nil) return;			d = (objectWindowType *)*data;	d->object.pulse = objectChoiceID;		HU_HeweyParam_SetFromHC( d->huiCoordData, kWP_Pulse_Weapon_ID, &dummyParam);		SetObjectField( d, &d->object, kWP_Pulse_Weapon_ID, true);	HU_HeweyParam_SetFromHC( d->huiCoordData, kWP_Pulse_Weapon_CheckBox_ID, &dummyParam);		SetObjectField( d, &d->object, kWP_Pulse_Weapon_CheckBox_ID, true);}static void Beam_Choose_Callback( long dispatchID, long objectChoiceID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	objectWindowType				*d = nil;	huiPlainControlParamType		dummyParam;	if (( objectChoiceID < 0) && ( objectChoiceID != -999)) return;	if ( objectChoiceID < 0) objectChoiceID = -1;		if ( data == nil) return;			d = (objectWindowType *)*data;	d->object.beam = objectChoiceID;		HU_HeweyParam_SetFromHC( d->huiCoordData, kWP_Beam_Weapon_ID, &dummyParam);		SetObjectField( d, &d->object, kWP_Beam_Weapon_ID, true);	HU_HeweyParam_SetFromHC( d->huiCoordData, kWP_Beam_Weapon_CheckBox_ID, &dummyParam);		SetObjectField( d, &d->object, kWP_Beam_Weapon_CheckBox_ID, true);}static void Special_Choose_Callback( long dispatchID, long objectChoiceID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	objectWindowType				*d = nil;	huiPlainControlParamType		dummyParam;	if (( objectChoiceID < 0) && ( objectChoiceID != -999)) return;	if ( objectChoiceID < 0) objectChoiceID = -1;		if ( data == nil) return;			d = (objectWindowType *)*data;	d->object.special = objectChoiceID;		HU_HeweyParam_SetFromHC( d->huiCoordData, kWP_Special_Weapon_ID,		&dummyParam);		SetObjectField( d, &d->object, kWP_Special_Weapon_ID, true);	HU_HeweyParam_SetFromHC( d->huiCoordData, kWP_Special_Weapon_CheckBox_ID,		&dummyParam);		SetObjectField( d, &d->object, kWP_Special_Weapon_CheckBox_ID, true);}static void Action_Window_Create( objectWindowType *d, CWindowPtr window,	long dispatchID, long whichObjectAction, Boolean flipOff){	baseObjectType *o;	Str255			s;// if flipOff is true, then don't open action window for existing action// selection; just toggle off instead	if ( d->discreteObjectData == nil) return;		o = (baseObjectType *)HD_DiscreteData_GetNthElement(						d->discreteObjectData, kHera_Object_Type, 0);	mAssert( o != nil);	Window_SaveData_FromObjectIndex( d,		window, d->whichObject);	switch( whichObjectAction)	{		case kObject_Editor_DestroyAction:											if (( o->destroyAction >= 0) && ( flipOff))			{				DestroyAction_Choose_Callback( dispatchID, -1, -1);			} else			{				Action_Editor_NewWindow( d->heraFile,					MakeActionWindowNameFromDiscreteObject(						d->heraFile, d->discreteObjectData,						s, "\pDestroy"), d->resRefNum,					o->destroyAction, o->destroyActionNum,					o->destroyAction, false, dispatchID,					DestroyAction_Choose_Callback);			}			break;					case kObject_Editor_ExpireAction:			if (( o->expireAction >= 0) && ( flipOff))			{				ExpireAction_Choose_Callback( dispatchID, -1, -1);			} else			{				Action_Editor_NewWindow( d->heraFile,					MakeActionWindowNameFromDiscreteObject(						d->heraFile, d->discreteObjectData,						s, "\pExpire"), d->resRefNum,					o->expireAction, o->expireActionNum,					o->expireAction, false, dispatchID,					ExpireAction_Choose_Callback);			}			break;					case kObject_Editor_CreateAction:			if (( o->createAction >= 0) && ( flipOff))			{				CreateAction_Choose_Callback( dispatchID, -1, -1);			} else			{				Action_Editor_NewWindow( d->heraFile,					MakeActionWindowNameFromDiscreteObject( d->heraFile,						d->discreteObjectData,						s, "\pCreate"), d->resRefNum,					o->createAction, o->createActionNum,					o->createAction, false, dispatchID,					CreateAction_Choose_Callback);			}			break;		case kObject_Editor_CollideAction:			if (( o->collideAction >= 0) && ( flipOff))			{				CollideAction_Choose_Callback( dispatchID, -1, -1);			} else			{				Action_Editor_NewWindow( d->heraFile,					MakeActionWindowNameFromDiscreteObject( d->heraFile,						d->discreteObjectData,						s, "\pCollide"), d->resRefNum,					o->collideAction, o->collideActionNum,					o->collideAction, false, dispatchID,					CollideAction_Choose_Callback);			}			break;		case kObject_Editor_ActivateAction:			if (( o->activateAction >= 0) && ( flipOff))			{				ActivateAction_Choose_Callback( dispatchID, -1, -1);			} else			{				Action_Editor_NewWindow( d->heraFile,					MakeActionWindowNameFromDiscreteObject( d->heraFile,						d->discreteObjectData,						s, "\pActivate"), d->resRefNum,					o->activateAction, o->activateActionNum,					o->activateAction, false, dispatchID,					ActivateAction_Choose_Callback);			}			break;		case kObject_Editor_ArriveAction:			if (( o->arriveAction >= 0) && ( flipOff))			{				ArriveAction_Choose_Callback( dispatchID, -1, -1);			} else			{				Action_Editor_NewWindow( d->heraFile,					MakeActionWindowNameFromDiscreteObject( d->heraFile,						d->discreteObjectData,						s, "\pArrive"), d->resRefNum,						o->arriveAction, o->arriveActionNum,						o->arriveAction, false, dispatchID,					ArriveAction_Choose_Callback);			}			break;	}}static void DestroyAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	objectWindowType				*d = nil;	huiPlainControlParamType		dummyParam;	if ( data == nil) return;		if ( actionChoiceNumber < 0) actionChoiceNumber = 0;		d = (objectWindowType *)*data;	d->object.destroyAction = actionChoiceID;	mHD_SetActionNum( d->object.destroyActionNum, actionChoiceNumber,		kHera_DestroyActionMask);		HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Destroy_Action_Index_ID,		&dummyParam);		SetObjectField( d, &d->object, kCP_Destroy_Action_Index_ID, true);	HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Destroy_Action_Index_ID -1,		&dummyParam);		SetObjectField( d, &d->object, kCP_Destroy_Action_Index_ID -1, true);}static void ExpireAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	objectWindowType				*d = nil;	huiPlainControlParamType		dummyParam;	if ( data == nil) return;			if ( actionChoiceNumber < 0) actionChoiceNumber = 0;		d = (objectWindowType *)*data;	d->object.expireAction = actionChoiceID;	mHD_SetActionNum( d->object.expireActionNum, actionChoiceNumber,		kHera_ExpireActionMask);		HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Expire_Action_Index_ID,		&dummyParam);		SetObjectField( d, &d->object, kCP_Expire_Action_Index_ID, true);	HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Expire_Action_Index_ID -1,		&dummyParam);		SetObjectField( d, &d->object, kCP_Expire_Action_Index_ID -1, true);}static void CreateAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	objectWindowType				*d = nil;	huiPlainControlParamType		dummyParam;	if ( data == nil) return;			if ( actionChoiceNumber < 0) actionChoiceNumber = 0;		d = (objectWindowType *)*data;	d->object.createAction = actionChoiceID;	mHD_SetActionNum( d->object.createActionNum, actionChoiceNumber,		kHera_CreateActionMask);		HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Create_Action_Index_ID,		&dummyParam);		SetObjectField( d, &d->object, kCP_Create_Action_Index_ID, true);	HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Create_Action_Index_ID -1,		&dummyParam);		SetObjectField( d, &d->object, kCP_Create_Action_Index_ID -1, true);}static void CollideAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	objectWindowType				*d = nil;	huiPlainControlParamType		dummyParam;	if ( data == nil) return;			if ( actionChoiceNumber < 0) actionChoiceNumber = 0;		d = (objectWindowType *)*data;	d->object.collideAction = actionChoiceID;	mHD_SetActionNum( d->object.collideActionNum, actionChoiceNumber,		kHera_CollideActionMask);		HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Collide_Action_Index_ID,		&dummyParam);		SetObjectField( d, &d->object, kCP_Collide_Action_Index_ID, true);	HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Collide_Action_Index_ID -1,		&dummyParam);		SetObjectField( d, &d->object, kCP_Collide_Action_Index_ID -1, true);}static void ActivateAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	objectWindowType				*d = nil;	huiPlainControlParamType		dummyParam;	if ( data == nil) return;			if ( actionChoiceNumber < 0) actionChoiceNumber = 0;		d = (objectWindowType *)*data;	d->object.activateAction = actionChoiceID;	mHD_SetActionNum( d->object.activateActionNum, actionChoiceNumber,		kHera_ActivateActionMask);		HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Activate_Action_Index_ID,		&dummyParam);		SetObjectField( d, &d->object, kCP_Activate_Action_Index_ID, true);	HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Activate_Action_Index_ID -1,		&dummyParam);		SetObjectField( d, &d->object, kCP_Activate_Action_Index_ID -1, true);}static void ArriveAction_Choose_Callback( long dispatchID, long actionChoiceID,	long actionChoiceNumber){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	objectWindowType				*d = nil;	huiPlainControlParamType		dummyParam;	if ( data == nil) return;			if ( actionChoiceNumber < 0) actionChoiceNumber = 0;		d = (objectWindowType *)*data;	d->object.arriveAction = actionChoiceID;	mHD_SetActionNum( d->object.arriveActionNum, actionChoiceNumber,		kHera_ArriveActionMask);		HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Arrive_Action_Index_ID,		&dummyParam);		SetObjectField( d, &d->object, kCP_Arrive_Action_Index_ID, true);	HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Arrive_Action_Index_ID -1,		&dummyParam);		SetObjectField( d, &d->object, kCP_Arrive_Action_Index_ID -1, true);}static void Sprite_Choose_CallBack( long windowID, long resID){	Handle						windowData =									GetDispatchWindowDataHandle( windowID);	SignedByte					dataState;	objectWindowType	*d;	huiPlainControlParamType	dummyParam;	if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);	d = (objectWindowType *)*windowData;		d->object.pixResID = resID;		HU_HeweyParam_SetFromHC( d->huiCoordData, kRP_Shape_Field_ID,		&dummyParam);	SetObjectField( d, &d->object, kRP_Shape_Field_ID, true);	HSetState( windowData, dataState);}static void Sprite_Animation_Choose_CallBack( long windowID, long resID){	Handle						windowData =									GetDispatchWindowDataHandle( windowID);	SignedByte					dataState;	objectWindowType	*d;	huiPlainControlParamType	dummyParam;	if ( windowData == nil) return;	dataState = HGetState( windowData);	HLock( windowData);	d = (objectWindowType *)*windowData;		d->object.pixResID = resID;		HU_HeweyParam_SetFromHC( d->huiCoordData, kMP_Shape_Field,		&dummyParam);	SetObjectField( d, &d->object, kMP_Shape_Field, true);	HSetState( windowData, dataState);}static void BaseObject_Clear( baseObjectType *aBase){	long		c2;		aBase->attributes = 0;	aBase->baseClass = kNoClass;	aBase->baseRace = kNoRace;	aBase->price = 0;		aBase->offenseValue = mFloatToFixed( -1);	aBase->destinationClass = 0;	aBase->maxVelocity = 0;	aBase->warpSpeed =0;	aBase->warpOutDistance = 0;		aBase->initialVelocity = 0;	aBase->initialVelocityRange = 0;		aBase->mass = 0;	aBase->maxThrust = 0;		aBase->health = 0;	aBase->damage = 0;	aBase->energy = 0;	aBase->initialAge = kNoAge;	aBase->initialAgeRange = 0;	aBase->naturalScale = SCALE_SCALE;		aBase->pixLayer = 0;	aBase->pixResID = kNoSpriteTable;	aBase->tinySize = 1;	aBase->shieldColor = kNoTinyColor;		aBase->initialDirection = 0;	aBase->initialDirectionRange = 0;		aBase->pulse = kNoWeapon;	aBase->beam = kNoWeapon;	aBase->special = kNoWeapon;		aBase->pulsePositionNum = 0;	aBase->beamPositionNum = 0;	aBase->specialPositionNum = 0;		for( c2 = 0; c2 < kMaxWeaponPosition; c2++)	{		aBase->pulsePosition[c2].h = aBase->pulsePosition[c2].v = 0;		aBase->beamPosition[c2].h = aBase->beamPosition[c2].v = 0;		aBase->specialPosition[c2].h = aBase->specialPosition[c2].v = 0;	}		aBase->friendDefecit = 0;	aBase->dangerThreshold = 0;	aBase->specialDirection = 0;		aBase->arriveActionDistance = kDestinationMargin;		aBase->destroyAction = -1;	aBase->destroyActionNum = 0;	aBase->expireAction = -1;	aBase->expireActionNum = 0;	aBase->createAction = -1;	aBase->createActionNum = 0;	aBase->collideAction = -1;	aBase->collideActionNum = 0;	aBase->activateAction = -1;	aBase->activateActionNum = 0;	aBase->arriveAction = -1;	aBase->arriveActionNum = 0;		aBase->frame.animation.firstShape = 0;	aBase->frame.animation.lastShape = 0;	aBase->frame.animation.frameDirection = 0;	aBase->frame.animation.frameDirectionRange = 0;	aBase->frame.animation.frameSpeed = 0;	aBase->frame.animation.frameSpeedRange = 0;	aBase->frame.animation.frameShape = 0;	aBase->frame.animation.frameShapeRange = 0;		aBase->buildFlags = 0;	aBase->orderFlags = 0;	aBase->buildRatio = 0;	aBase->buildTime = 0;	aBase->skillNum = aBase->skillNumAdj = aBase->skillDen = aBase->skillDenAdj = 0;	aBase->reserved2 = 0;	aBase->reserved3 = 0;	aBase->internalFlags = 0;	aBase->pictPortraitResID = 0;	}static void Enable_Editing( objectWindowType *d, Boolean enable){	HUI_Cell_Set_Enabled( d->master, 0, kMain_Cell_X, kMain_Cell_Y, enable);}smallFixedType GetWeaponMaxVelocity( objectWindowType *d, long *life){	Handle				discreteActionData = nil,						discreteObjectData = nil;	objectActionType	*action = nil;	long				actionNum = 0, i;	baseObjectType		*object = nil;	unsigned long		objectID;		if ( life != nil) *life = 0;		if (( d->object.activateActionNum & kPeriodicActionNotMask) <= 0)		return 0;			discreteActionData = HD_Find_Discrete_Data( d->heraFile,		d->object.activateAction, -1, nil, kHera_Action_Type);		if ( discreteActionData == nil) return 0;		actionNum = HD_DiscreteData_GetElementNumber( discreteActionData,		kHera_Action_Type);		if ( actionNum < 1) return 0;		for (i = 0; i < actionNum; i++)	{		action = (objectActionType *)HD_DiscreteData_GetNthElement(			discreteActionData, kHera_Action_Type, i);				if ( action != nil)		{			if ( action->verb == kCreateObject)			{				objectID = action->argument.createObject.whichBaseType;				action = nil;								discreteObjectData = HD_Find_Discrete_Data( d->heraFile,					objectID, -1, nil, kHera_Object_Type);								if ( discreteObjectData != nil)				{					object = (baseObjectType *)HD_DiscreteData_GetNthElement(						discreteObjectData, kHera_Object_Type, 0);										if ( object != nil)					{						if ( life != nil) *life = object->initialAge;						if ( object->maxVelocity > object->initialVelocity)							return object->maxVelocity;						else							return object->initialVelocity;					}				}			}		}	}	return 0;	}static void Object_Do_Delete( objectWindowType *d, CWindowPtr whichWindow,	unsigned short modifiers, Boolean confirm){	if ((confirm) &&  (!( modifiers & cmdKey)))	{		if (!HU_Confirm_Delete("\pAre you sure you "				"want to delete this object?", modifiers))		{			return;		}	}	if ( d->discreteObjectData != nil)	{		d->heraFile->changed = true;			d->anyChanges = true;		HUI_Control_DeleteListRows(			d->master, 0, kList_Cell_X, kList_Cell_Y,			kList_ID, 1, d->whichObject);		d->whichObject = 			HUI_Control_SetListValue(				d->master, 0, kList_Cell_X, kList_Cell_Y,				kList_ID, d->whichObject);		HD_Delete_Discrete_Data( d->heraFile, d->discreteObjectData);		d->discreteObjectData = nil;		HD_Delete_Discrete_Data( d->heraFile, d->discreteObjectStringData);		d->discreteObjectStringData = nil;		Window_SetControls_FromObjectIndex( d, whichWindow, d->whichObject);	}}#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/OSErr ObjectEditor_NewWindow( heraScenarioFileType *heraFile,	long *windowID, long callerID,	long defaultSelectionID, StringPtr titlePrefix, short resRefNum,	Boolean chooseOnly, Boolean includePhysicalObjects, Boolean includeDevices,	Boolean isModal, Object_Editor_Callback_procPtr callBack){	Rect						bounds;	CWindowPtr					newWindow = nil;	Str255						title;	ControlHandle				rootControl, aControl;	huiPlainControlParamType	buttonParam, textParam, groupParam;	huiCellParamType			cellParam;	huiMasterControlParamType	masterParam;	OSStatus					err;	Handle						data = nil, strList;	objectWindowType				*d = nil;	huiPlainControlType			*hui;	short						oldResRefNum = 0, i, j;	#pragma unused ( err, textParam, aControl)		oldResRefNum = CurResFile();		// create the new window	*windowID = -1;	if ( heraFile->fileRefNum <= 0) chooseOnly = true;		data = NewHandle( sizeof( objectWindowType));	if ( data == nil) return memFullErr;		HLock( data);	d = (objectWindowType *)*data;	d->master = nil;	d->panel = nil;//	d->objectData = nil;//	d->objectNameStrings = nil;//	d->objectShortStrings = nil;//	d->objectNoteStrings = nil;	d->whichObject = 0;	d->anyChanges = false;	d->resRefNum = resRefNum;	d->windowID = -1;	d->currentPanel = 0;	d->setAttributes_WindowID = -1;	d->discreteObjectData = nil;	d->discreteObjectStringData = nil;	d->sortBy = kSortByID;	d->chooseOnly = chooseOnly;	d->includePhysicalObjects = includePhysicalObjects;	d->includeDevices = includeDevices;	d->isModal = isModal;	d->callBack = callBack;	d->huiCoordData = GetResource( 'nlHc', 128);	d->currentObjectID = defaultSelectionID;	d->callerID = callerID;	d->heraFile = heraFile;	if ( titlePrefix != nil) pstrcpy( d->titlePrefix, titlePrefix);	d->warpInFlareID =		((scenarioInfoType *)*(d->heraFile->scenarioInfo))->warpInFlareID;	d->warpOutFlareID =		((scenarioInfoType *)*(d->heraFile->scenarioInfo))->warpOutFlareID;	d->playerBodyID =		((scenarioInfoType *)*(d->heraFile->scenarioInfo))->playerBodyID;	d->energyBlobID =		((scenarioInfoType *)*(d->heraFile->scenarioInfo))->energyBlobID;	if ( d->huiCoordData == nil) 	{		err = memFullErr;		goto ObjectEditor_NewWindow_error;	} else	{//		this was a nasty fix to insert a new tab panel/*		huiCoordDataType	*c = nil;		long				k;//		short				homeResFile = HomeResFile( d->huiCoordData);				HLock( d->huiCoordData);		k = GetHandleSize( d->huiCoordData) / sizeof( huiCoordDataType);		c = (huiCoordDataType *)*d->huiCoordData;		while ( k >= 0)		{			k--;			if ( c->panel < 7) c->panel += 1;			else c->panel = 0;			c++;		}		HUnlock( d->huiCoordData);		ChangedResource( d->huiCoordData);		UpdateResFile( HomeResFile( d->huiCoordData));		*/	}	//	UseResFile( resRefNum);	if ( d->heraFile->fileRefNum > 0)		UseResFile( d->heraFile->fileRefNum);	else	{		UseResFile( gHera->default_scenarioFile_refNum);		chooseOnly = true;	}	/*	d->objectData = GetResource( 'bsob', 500);	if ( d->objectData == nil) d->objectData = NewHandle(0);	else	{		DetachResource( d->objectData);	}	if ( d->objectData == nil)	{		err = memFullErr;		goto ObjectEditor_NewWindow_error;	}	d->objectNameStrings = GetStringList( kObjectNameLongStrResID);	if ( d->objectNameStrings == nil) d->objectNameStrings = NewStringList();	else	{		DetachResource( d->objectNameStrings);	}	if ( d->objectNameStrings == nil)	{		err = memFullErr;		goto ObjectEditor_NewWindow_error;	}*///	GetIndString( title, kStrResID, 100);	if ( titlePrefix != nil)	{		pstrcpy( title, titlePrefix);		pstrcat( title, "\p: ");	} else	{		title[0] = 0;	}		if ( chooseOnly)	{		pstrcat( title, "\pChoose Object");	} else	{		pstrcat( title, "\pEdit Objects");	}		SetRect( &bounds, 64, 64, 128, 128);	if ( isModal)	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowMovableModalDialogProc, (WindowPtr)-1, false,			HandleEvent, 0,			windowID);	} else	{		newWindow = NewDispatchWindow( &bounds, title, false,			kWindowDocumentProc, (WindowPtr)-1, false,			HandleEvent, 0,			windowID);	}	if ( newWindow == nil)	{		err = memFullErr;		goto ObjectEditor_NewWindow_error;	}	SetDispatchWindowDataHandle( *windowID, data);	d->windowID = *windowID;		SetThemeWindowBackground( (WindowPtr)newWindow,		kThemeActiveDialogBackgroundBrush, true);	SetPortWindowPort( (WindowPtr)newWindow);	CreateRootControl( (WindowPtr)newWindow, &rootControl);	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kRowNum;	masterParam.colNum = kColNum;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = gHera->smallFontSize;	d->master = HUI_MasterControl_New( nil, 0, 0, 0, &masterParam);		mAssert( d->master != nil);	if ( d->master == nil)	{		err = memFullErr;		goto ObjectEditor_NewWindow_error;	}	HUI_Master_ShowLayer( d->master, 0);	d->master->tab[0][0].h = 112;	d->master->tab[0][0].hAlign = hui_halign_right;	d->master->tab[0][1].h = 112;	d->master->tab[0][1].hAlign = hui_halign_left;	// general cell set up	cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_left;	cellParam.vAlign = hui_valign_center;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	// separator	cellParam.minMaxBounds.right = kHUI_Pixel_Max;	cellParam.colSpan = 2;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_center;	SetRect( &cellParam.outSpace, 12, 2, 12, 2);	SetRect( &cellParam.inSpace, 0, 1, 0, 1);	HUI_Cell_Set( 0, kSeparator_Cell_X, kSeparator_Cell_Y, &cellParam);		// set up ok/cancel cell	cellParam.hAlign = hui_halign_right;	cellParam.baseLine = gHera->bigFontSize;	cellParam.colSpan = 2;	cellParam.rowSpan = 1;	SetRect( &cellParam.outSpace, 12, 0, 0, 0);	SetRect( &cellParam.inSpace, 0, 8, 12, 12);	HUI_Cell_Set( 0, kButton_Cell_X, kButton_Cell_Y, &cellParam);		// set up list header	d->master->rowDontExpand[kList_Header_Cell_Y] = true;	SetRect( &cellParam.outSpace, -1, -1, 3, 1);	SetRect( &cellParam.inSpace, 9, -1, 3, 3);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_left;	HUI_Cell_Set( 0, kList_Header_Cell_X, kList_Header_Cell_Y, &cellParam);	cellParam.minMaxBounds.top = 0;	// set up list cell	SetRect( &cellParam.outSpace, -1, -1, 3, 3);	SetRect( &cellParam.inSpace, -1, -1, 3, 3);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.hAlign = hui_halign_center;	HUI_Cell_Set( 0, kList_Cell_X, kList_Cell_Y, &cellParam);	cellParam.minMaxBounds.top = 0;		// set up list button cells	SetRect( &cellParam.inSpace, -1, 3, -1, -1);	SetRect( &cellParam.outSpace, -1, 3, -1, -1);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	cellParam.baseLine = gHera->smallFontSize;	cellParam.hAlign = hui_halign_center;	d->master->rowDontExpand[kList_Button_Cell_Y] = true;	HUI_Cell_Set( 0, kList_Button_Cell_X, kList_Button_Cell_Y, &cellParam);	cellParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// set up main tab cell	cellParam.hAlign = hui_halign_center;	cellParam.baseLine = gHera->smallFontSize;	cellParam.colSpan = kMain_Cell_ColSpan;	cellParam.rowSpan = kMain_Cell_RowSpan;	SetRect( &cellParam.outSpace, 3, -1, 12, -1);	SetRect( &cellParam.inSpace, 3, 12, 8, 18);	HUI_Cell_Set( 0, kMain_Cell_X, kMain_Cell_Y, &cellParam);		// set up tab group		groupParam.id = kTab_ID;	groupParam.master = d->master;	groupParam.visible = true;	groupParam.enabled = true;	groupParam.layer = 0;	groupParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;	groupParam.fontStyle.font = gHera->smallFontNum;	groupParam.fontStyle.size = gHera->smallFontSize;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;	groupParam.helpStringResID = -1;	groupParam.id = kTab_ID;	groupParam.cellx = kMain_Cell_X;	groupParam.celly = kMain_Cell_Y;	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	GetIndString( groupParam.label, kStrResID, 103); // Objects	groupParam.special.tab.strList = GetStringList( 8009);	groupParam.special.tab.tabResID = kHUI_Tab_NoTabRes_ID;	groupParam.special.tab.isLarge = false;		HUI_Tab_New( &groupParam);//	HUI_Group_New_LiteralP( &groupParam);	if ( groupParam.special.tab.strList != nil)		ReleaseResource( groupParam.special.tab.strList);	// create tab panel master	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 6, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = gHera->smallFontSize;	masterParam.rowNum = kTabPanel_RowNum;	masterParam.colNum = kTabPanel_ColNum;	masterParam.layerNum = kTabPanel_PanelNum;	d->panel = HUI_MasterControl_New( d->master, 0, kMain_Cell_X, kMain_Cell_Y,		&masterParam);	mAssert( d->panel != nil);	if ( d->panel == nil)	{		err = memFullErr;		goto ObjectEditor_NewWindow_error;	}	d->panel->tab[0][0].h = kCellTabWidth;	d->panel->tab[0][0].hAlign = hui_halign_right;	d->panel->tab[0][1].h = kCellTabWidth;//112;	d->panel->tab[0][1].hAlign = hui_halign_left;	d->panel->tab[0][2].h = kCellTabWidth * 3;//112;	d->panel->tab[0][2].hAlign = hui_halign_right;	d->panel->tab[0][3].h = kCellTabWidth * 3;//112;	d->panel->tab[0][3].hAlign = hui_halign_left;	d->panel->tab[1][0].h = kCellTabWidth;	d->panel->tab[1][0].hAlign = hui_halign_right;	d->panel->tab[1][1].h = kCellTabWidth;//112;	d->panel->tab[1][1].hAlign = hui_halign_left;	d->panel->tab[1][2].h = kCellBigTabWidth * 3;//112;	d->panel->tab[1][2].hAlign = hui_halign_right;	d->panel->tab[1][3].h = kCellBigTabWidth * 3;//112;	d->panel->tab[1][3].hAlign = hui_halign_left;	// set up action cell (single cell spans 3 columns)	cellParam.master = d->panel;	cellParam.hAlign = hui_halign_center;	cellParam.baseLine = gHera->smallFontSize;	cellParam.colSpan = 3;	cellParam.rowSpan = 1;	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	HUI_Cell_Set( kCP_Panel_Index, kTab_Cell_1_X, kTab_Cell_1_Y, &cellParam);	HUI_Cell_Set( kRP_Panel_Index, kTab_Cell_1_X, kTab_Cell_1_Y, &cellParam);	HUI_Cell_Set( kMP_Panel_Index, kTab_Cell_1_X, kTab_Cell_1_Y, &cellParam);	HUI_Cell_Set( kDP_Panel_Index, kTab_Cell_1_X, kTab_Cell_1_Y, &cellParam);	HUI_Cell_Set( kBP_Panel_Index, kTab_Cell_1_X, kTab_Cell_1_Y, &cellParam);		// set up basic cell (cell 1 spans 2, cell 3 alone)	cellParam.colSpan = 2;	HUI_Cell_Set( kBS_Panel_Index, kTab_Cell_1_X, kTab_Cell_1_Y, &cellParam);	cellParam.colSpan = 1;	HUI_Cell_Set( kBS_Panel_Index, kTab_Cell_3_X, kTab_Cell_3_Y, &cellParam);		// set up attribute cell ( lessen h space)	cellParam.colSpan = 1;	SetRect( &cellParam.outSpace, 0, 0, 0, 0);	SetRect( &cellParam.inSpace, 0, 12, 0, 0);	cellParam.vAlign = hui_valign_top;	HUI_Cell_Set( kAP_Panel_Index, kTab_Cell_1_X, kTab_Cell_1_Y, &cellParam);	HUI_Cell_Set( kAP_Panel_Index, kTab_Cell_2_X, kTab_Cell_2_Y, &cellParam);	HUI_Cell_Set( kAP_Panel_Index, kTab_Cell_3_X, kTab_Cell_3_Y, &cellParam);	cellParam.vAlign = hui_valign_center;	HUI_Cell_Set( kWP_Panel_Index, kTab_Cell_1_X, kTab_Cell_1_Y, &cellParam);	HUI_Cell_Set( kWP_Panel_Index, kTab_Cell_2_X, kTab_Cell_2_Y, &cellParam);	HUI_Cell_Set( kWP_Panel_Index, kTab_Cell_3_X, kTab_Cell_3_Y, &cellParam);		// set up buttons, general	buttonParam.master = d->master;	buttonParam.visible = true;	if ( d->chooseOnly)		buttonParam.enabled = false;	else		buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	buttonParam.fontStyle.font = gHera->smallFontNum;	buttonParam.fontStyle.size = gHera->smallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = -1;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;		// make selection list	buttonParam.id = kList_ID;	buttonParam.minMaxBounds.left = 180;	buttonParam.minMaxBounds.right = 180;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;//200;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.bottom = 200;	buttonParam.cellx = kList_Cell_X;	buttonParam.celly = kList_Cell_Y;	buttonParam.special.listBox.ldesResID = 130;	buttonParam.special.listBox.refCon = 132;	buttonParam.flags = huiControlFlag_useCellV;	buttonParam.enabled = true;	hui = HUI_ListBox_New_LiteralP( &buttonParam);/*	if ( hui != nil)	{		ListHandle	list;		Cell		cell;		long		objectNum = GetHandleSize( d->objectData) / sizeof( baseObjectType);			err = GetListBoxListHandle( hui->generic.control, &list);		if ( list != nil)		{			Str255			idString, classString, raceString, nameString;			baseObjectType	*o;			Ptr				data;			long			dataLength;						i = 1;			(*list)->selFlags = lOnlyOne;						cell.h = 0;			do			{				NumToString( i-1, idString);								o = (baseObjectType *)*d->objectData + ( i - 1);								NumToString( o->baseClass, classString);				NumToString( o->baseRace, raceString);				RetrieveIndString( d->objectNameStrings, i, nameString);				if ( nameString[0] == 0) pstrcpy( nameString, "\puntitled");				data = PsuedoColumn_Data_Make( &dataLength, i,					idString, "\p\t", classString, "\p\t", raceString, "\p\t", nameString,					"\p");									if ( data != 0)				{					LAddRow( 1, (**list).dataBounds.bottom, list );					cell.v = (**list).dataBounds.bottom - 1;//					LSetCell( (Ptr)(&s[1]), s[0], cell, list );					LSetCell( data, dataLength, cell, list );				}				i ++;				objectNum--;			} while ( objectNum > 0);		}		}*/		buttonParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;		// set up list buttons		buttonParam.id = kList_SortBy_Menu_ID - 1;	buttonParam.cellx = kList_Button_Cell_X;	buttonParam.celly = kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kStrResID, 119);	HUI_StaticText_New_LiteralP( &buttonParam);	buttonParam.id = kList_SortBy_Menu_ID;	buttonParam.cellx = kList_Button_Cell_X;	buttonParam.celly = kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	buttonParam.label[0] = 0;	strList = GetStringList( 8042);	if ( strList != nil)	{		buttonParam.special.menuStrList.strList = strList;		buttonParam.special.menuStrList.menuID = HU_GetNewMenuID();		buttonParam.minMaxBounds.right = kHUI_Pixel_Max;		buttonParam.minMaxBounds.left = 0;				HUI_PopupButton_New_StrList( &buttonParam);		ReleaseResource( strList);		buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	}	buttonParam.id = kList_Remove_Button_ID;	buttonParam.cellx = kList_Button_Cell_X;	buttonParam.celly = kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_newLine;	GetIndString( buttonParam.label, kStrResID, 101);	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.id = kList_Add_Button_ID;	buttonParam.cellx = kList_Button_Cell_X;	buttonParam.celly = kList_Button_Cell_Y;	buttonParam.flags = huiControlFlag_none;	GetIndString( buttonParam.label, kStrResID, 102);	HUI_PushButton_New_LiteralP( &buttonParam);		// set up buttons in tab	buttonParam.master = d->panel;	buttonParam.cellx = kTab_Cell_1_X;	buttonParam.celly = kTab_Cell_1_Y;	if ( d->chooseOnly)		buttonParam.enabled = false;	else		buttonParam.enabled = true;		// set up text, general		textParam.master = d->panel;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = 4;	textParam.space.right = 0;	textParam.space.top = 10;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = teJustLeft;//teJustRight;	textParam.cellx = kTab_Cell_1_X;	textParam.celly = kTab_Cell_1_Y;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;	// set up list header	textParam.space.left = 0;	textParam.master = d->master;	textParam.id = kList_Header_ID;	textParam.cellx = kList_Header_Cell_X;	textParam.celly = kList_Header_Cell_Y;	pstrcpy( textParam.label, "\pid");	textParam.minMaxBounds.left = textParam.minMaxBounds.right = 30;	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kList_Header_ID + 1;	textParam.cellx = kList_Header_Cell_X;	textParam.celly = kList_Header_Cell_Y;	pstrcpy( textParam.label, "\pclass");	textParam.minMaxBounds.left = textParam.minMaxBounds.right = 30;	HUI_StaticText_New_LiteralP( &textParam);	textParam.id = kList_Header_ID + 2;	textParam.cellx = kList_Header_Cell_X;	textParam.celly = kList_Header_Cell_Y;	pstrcpy( textParam.label, "\prace");	textParam.minMaxBounds.left = textParam.minMaxBounds.right = 30;	HUI_StaticText_New_LiteralP( &textParam);	textParam.id = kList_Header_ID + 3;	textParam.cellx = kList_Header_Cell_X;	textParam.celly = kList_Header_Cell_Y;	pstrcpy( textParam.label, "\pname");	textParam.minMaxBounds.left = textParam.minMaxBounds.right = 30;	HUI_StaticText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.space.left = 4;		// basic panel	textParam.master = d->panel;		// basic panel names	textParam.space.top = 20;	// short name	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_ShortName_ID - 1, &textParam);	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_none;	HUI_StaticText_New_LiteralP( &textParam);		HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_ShortName_ID, &textParam);	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.flags = huiControlFlag_none;	textParam.minMaxBounds.left = kEditTextHugeFieldWidth;	textParam.space.left = 8;	if ( d->chooseOnly)		HUI_StaticText_New_LiteralP( &textParam);	else		HUI_EditText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_ShortName_Len_ID, &textParam);	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.flags = huiControlFlag_none;	HUI_StaticText_New_LiteralP( &textParam);	textParam.space.left = 4;	// long name	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_LongName_ID - 1, &textParam);	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_newLine;	HUI_StaticText_New_LiteralP( &textParam);		HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_LongName_ID, &textParam);	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.flags = huiControlFlag_none;	textParam.minMaxBounds.left = kEditTextHugeFieldWidth;	textParam.space.left = 8;	if ( d->chooseOnly)		HUI_StaticText_New_LiteralP( &textParam);	else		HUI_EditText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_LongName_Len_ID, &textParam);	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.flags = huiControlFlag_none;	HUI_StaticText_New_LiteralP( &textParam);	textParam.space.left = 4;	// dev note	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_DevNote_ID - 1, &textParam);	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_newLine;	HUI_StaticText_New_LiteralP( &textParam);		HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_DevNote_ID, &textParam);	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.flags = huiControlFlag_none;	textParam.minMaxBounds.left = kEditTextHugeFieldWidth;	textParam.minMaxBounds.top = 84;	textParam.space.left = 8;	if ( d->chooseOnly)		HUI_StaticText_New_LiteralP( &textParam);	else		HUI_EditText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_DevNote_Len_ID, &textParam);	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.flags = huiControlFlag_none;	HUI_StaticText_New_LiteralP( &textParam);	textParam.space.left = 4;	// picture portrait res id	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_PictureResID_ID - 1, &textParam);	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_newLine;	HUI_StaticText_New_LiteralP( &textParam);		HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_PictureResID_ID, &textParam);	textParam.whichTabSet = 0;	textParam.whichTab = 1;	textParam.flags = huiControlFlag_none;	textParam.minMaxBounds.left = kEditTextFieldWidth;	if ( d->chooseOnly)		HUI_StaticText_New_LiteralP( &textParam);	else		HUI_EditText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	// basic panel blessings radio group	groupParam.master = d->panel;	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_Blessings_Group_ID, &groupParam);	groupParam.whichTabSet = -1;	groupParam.whichTab = -1;	groupParam.special.group.isSecondary = true;	groupParam.id = kBS_Blessings_Group_ID - 1;	HUI_Group_New_LiteralP( &groupParam);	groupParam.id = kBS_Blessings_Group_ID;	HUI_RadioGroup_New_LiteralP( &groupParam);		HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_NotBlessed_ID, &buttonParam);	buttonParam.whichTabSet = -1;	buttonParam.whichTab = -1;	buttonParam.flags = huiControlFlag_none;	HUI_RadioButton_New_LiteralP( &buttonParam);	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_WarpInFlare_ID, &buttonParam);	buttonParam.flags = huiControlFlag_newLine;	HUI_RadioButton_New_LiteralP( &buttonParam);		HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_WarpOutFlare_ID, &buttonParam);	buttonParam.flags = huiControlFlag_newLine;	HUI_RadioButton_New_LiteralP( &buttonParam);	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_PlayersBody_ID, &buttonParam);	buttonParam.flags = huiControlFlag_newLine;	HUI_RadioButton_New_LiteralP( &buttonParam);	HU_HeweyParam_SetFromHC( d->huiCoordData, kBS_EnergyBlob_ID, &buttonParam);	buttonParam.flags = huiControlFlag_newLine;	HUI_RadioButton_New_LiteralP( &buttonParam);	textParam.space.top = 10;	textParam.space.bottom = 4;	// attributes panel	// attributes flag label	for ( i = kAP_First_Bit_Menu; i <= kAP_Last_Bit_Menu; i += 4)	{		HU_HeweyParam_SetFromHC( d->huiCoordData, i-1, &textParam);		textParam.whichTabSet = 0;		textParam.whichTab = 0;		textParam.flags = huiControlFlag_none;		HUI_StaticText_New_LiteralP( &textParam);					// attributes flag  menu		HU_HeweyParam_SetFromHC( d->huiCoordData, i, &buttonParam);		if ( i == kAP_Attribute_Flags_Menu_ID)			j = 600;		else if ( i == kAP_Build_Flags_Menu_ID)			j = 640;		else if ( i == kAP_Order_Flags_Menu_ID)			j = 641;					buttonParam.special.menuStrList.strList = GetStringList( j);		buttonParam.special.menuStrList.menuID = HU_GetNewMenuID();//130 + i;		buttonParam.special.menuStrList.cicnResID = 128;		buttonParam.special.menuStrList.multiSelect = true;		buttonParam.whichTabSet = 0;		buttonParam.whichTab = 1;		buttonParam.flags = huiControlFlag_none;		buttonParam.space.left = 8;				HUI_BevelButtonMenu_New_StrList( &buttonParam);		buttonParam.whichTabSet = -1;		buttonParam.whichTab = -1;		if ( buttonParam.special.menuStrList.strList != nil)			ReleaseResource( buttonParam.special.menuStrList.strList);					// set attributes button		buttonParam.id = i + 2;		GetIndString( buttonParam.label, kStrResID, 92); // setÉ		buttonParam.space.left = 8;		buttonParam.minMaxBounds.right = kHUI_Pixel_Max;		buttonParam.minMaxBounds.left = 0;		HUI_PushButton_New_LiteralP( &buttonParam);	}	textParam.flags = huiControlFlag_newLine;	for ( i = kAP_First_List_Item; i <= kAP_Last_List_Item; i += 2)	{		HU_HeweyParam_SetFromHC( d->huiCoordData, i-1, &textParam);		textParam.minMaxBounds.left = 0;		textParam.space.top = 12;		textParam.whichTabSet = 0;		textParam.whichTab = 0;		if ( i == kAP_Skill_Denominator_ID)		{			textParam.flags = huiControlFlag_none;			textParam.whichTabSet = -1;			textParam.whichTab = -1;		}		if ( i != kAP_Calc_Warpout_Now_ID)			HUI_StaticText_New_LiteralP( &textParam);			HU_HeweyParam_SetFromHC( d->huiCoordData, i, &textParam);		textParam.minMaxBounds.left = kEditTextFieldWidth;		textParam.flags = huiControlFlag_none;		textParam.whichTabSet = 0;		textParam.whichTab = 1;		if (( i == kAP_Sprite_Layer_ID) || ( i == kAP_Long_Range_Kind_ID))		{			if ( i == kAP_Sprite_Layer_ID) j = 8011;			else if ( i == kAP_Long_Range_Kind_ID) j = 8013;			strList = GetStringList( j);			if ( strList != nil)			{				textParam.special.menuStrList.strList = strList;				textParam.special.menuStrList.menuID = HU_GetNewMenuID();//999 + i;				textParam.minMaxBounds.right = kEditTextFieldWidth * 2;				textParam.minMaxBounds.left = 0;				if ( d->chooseOnly)					textParam.enabled = false;				else					textParam.enabled = true;				HUI_PopupButton_New_StrList( &textParam);				ReleaseResource( strList);				textParam.enabled = true;				textParam.minMaxBounds.right = kHUI_Pixel_Max;			}		} else if (( i == kAP_Skill_Numerator_ID) || ( i == kAP_Skill_Denominator_ID))		{			textParam.minMaxBounds.left = kEditTextSmallFieldWidth;			if ( i == kAP_Skill_Denominator_ID)			{				textParam.whichTabSet = -1;				textParam.whichTab = -1;			}			if ( d->chooseOnly)				HUI_StaticText_New_LiteralP( &textParam);			else				HUI_EditText_New_LiteralP( &textParam);			textParam.minMaxBounds.left = 0;		} else if ( i == kAP_Calc_Warpout_Now_ID)		{			textParam.flags = huiControlFlag_newLine;			if ( d->chooseOnly)				textParam.enabled = false;			else				textParam.enabled = true;			HUI_PushButton_New_LiteralP( &textParam);			textParam.enabled = true;		} else if ( i == kAP_Shield_Color_ID)		{			// shield color menu			textParam.special.menuStrList.strList = GetStringList( 592);			textParam.special.menuStrList.menuID = HU_GetNewMenuID();//129;			HUI_PopupButton_New_StrList( &textParam);		} else		{			if ( d->chooseOnly)				HUI_StaticText_New_LiteralP( &textParam);			else				HUI_EditText_New_LiteralP( &textParam);		}		textParam.flags = huiControlFlag_newLine;	}	for ( i = 510; i <= 542; i += 16)	{		textParam.flags = huiControlFlag_none;		for ( j = i; j < ( i + 4); j += 2)		{			HU_HeweyParam_SetFromHC( d->huiCoordData, j-1, &textParam);			textParam.space.top = 12;			textParam.whichTabSet = 0;			textParam.whichTab = 0;			textParam.minMaxBounds.left = 0;			if ( i == j)				HUI_CheckBox_New_LiteralP( &textParam);			else				HUI_StaticText_New_LiteralP( &textParam);				// class edit			HU_HeweyParam_SetFromHC( d->huiCoordData, j, &textParam);			if ( j == i)				textParam.minMaxBounds.left = kEditTextFieldWidth * 2;			else				textParam.minMaxBounds.left = kEditTextFieldWidth;			textParam.flags = huiControlFlag_none;			textParam.whichTabSet = 0;			textParam.whichTab = 1;			if (( d->chooseOnly) || ( j == i))				HUI_StaticText_New_LiteralP( &textParam);			else				HUI_EditText_New_LiteralP( &textParam);			if ( j == i)			{				buttonParam.master = textParam.master;				buttonParam.cellx = textParam.cellx;				buttonParam.celly = textParam.celly;				buttonParam.layer = textParam.layer;				buttonParam.flags = huiControlFlag_newLine;				buttonParam.whichTabSet = 0;				buttonParam.whichTab = 1;				switch( i)				{					case 510:						buttonParam.id = kWP_Pulse_Choose_Button_ID;						break;										case (510 + 16):						buttonParam.id = kWP_Beam_Choose_Button_ID;						break;										case (510 + 16 + 16):						buttonParam.id = kWP_Special_Choose_Button_ID;						break;				}								GetIndString( buttonParam.label, 8010, 121);				HUI_PushButton_New_LiteralP( &buttonParam);				buttonParam.flags = huiControlFlag_none;				buttonParam.whichTabSet = -1;				buttonParam.whichTab = -1;							}			textParam.flags = huiControlFlag_newLine;		}		textParam.flags = huiControlFlag_newLine;				for ( j = (i+4); j < ( i + 16); j += 4)		{			HU_HeweyParam_SetFromHC( d->huiCoordData, j-1, &textParam);			textParam.space.top = 12;			textParam.whichTabSet = 0;			textParam.whichTab = 0;			HUI_StaticText_New_LiteralP( &textParam);				HU_HeweyParam_SetFromHC( d->huiCoordData, j, &textParam);			textParam.minMaxBounds.left = kEditTextFieldWidth;			textParam.flags = huiControlFlag_none;			textParam.whichTabSet = 0;			textParam.whichTab = 1;			if ( d->chooseOnly)				HUI_StaticText_New_LiteralP( &textParam);			else				HUI_EditText_New_LiteralP( &textParam);			HU_HeweyParam_SetFromHC( d->huiCoordData, j+1, &textParam);			textParam.space.top = 12;			textParam.whichTabSet = 0;			textParam.whichTab = 0;			textParam.flags = huiControlFlag_newLine;			HUI_StaticText_New_LiteralP( &textParam);				HU_HeweyParam_SetFromHC( d->huiCoordData, j + 2, &textParam);			textParam.minMaxBounds.left = kEditTextFieldWidth;			textParam.flags = huiControlFlag_none;			textParam.whichTabSet = 0;			textParam.whichTab = 1;			if ( d->chooseOnly)				HUI_StaticText_New_LiteralP( &textParam);			else				HUI_EditText_New_LiteralP( &textParam);						textParam.flags = huiControlFlag_newLine;		}			}		textParam.flags = huiControlFlag_none;	HU_HeweyParam_SetFromHC( d->huiCoordData, 638, &textParam);	textParam.space.top = 12;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	if ( d->chooseOnly)		textParam.enabled = false;	else		textParam.enabled = true;	HUI_CheckBox_New_LiteralP( &textParam);		textParam.enabled = true;	textParam.flags = huiControlFlag_newLine;		for ( i = kCP_First_List_Item; i < kCP_Last_List_Item; i += 4)	{		for ( j = i; j < (i + 4); j += 2)		{			if (( j == kCP_Periodic_Time_Range_ID) || ( j < ( i + 2)))			{				// label				HU_HeweyParam_SetFromHC( d->huiCoordData, j-1, &textParam);				textParam.space.top = 12;				textParam.whichTabSet = 1;				textParam.whichTab = ((j-i)/1) + 0;				textParam.space.left = 4;				if ( i == kCP_Periodic_Time_ID)					HUI_StaticText_New_LiteralP( &textParam);				else					HUI_CheckBox_New_LiteralP( &textParam);					// edit				HU_HeweyParam_SetFromHC( d->huiCoordData, j, &textParam);				textParam.flags = huiControlFlag_none;				textParam.whichTabSet = 1;				textParam.whichTab = ((j-i)/1) + 1;				textParam.space.left = 12;				if (( j != kCP_Periodic_Time_ID) && ( j != kCP_Periodic_Time_Range_ID))				{					textParam.minMaxBounds.left = kEditTextHugeFieldWidth;					HUI_StaticText_New_LiteralP( &textParam);				}				else				{					if ( d->chooseOnly)						HUI_StaticText_New_LiteralP( &textParam);					else						HUI_EditText_New_LiteralP( &textParam);				}			}				textParam.minMaxBounds.left = kEditTextFieldWidth;					}		if ( i <= kCP_Arrive_Action_Index_ID)		{			// action edit button			buttonParam.id = i + kCP_Edit_Button_Offset;			GetIndString( buttonParam.label, kStrResID, 98); // editÉ			buttonParam.layer = textParam.layer;			buttonParam.cellx = textParam.cellx;			buttonParam.celly = textParam.celly;			buttonParam.master = textParam.master;			buttonParam.space.left = 8;			buttonParam.minMaxBounds.right = kHUI_Pixel_Max;			buttonParam.minMaxBounds.left = 0;			HUI_PushButton_New_LiteralP( &buttonParam);			// action select button			buttonParam.id = i + kCP_Select_Button_Offset;			GetIndString( buttonParam.label, kStrResID, 99); // editÉ			buttonParam.space.left = 8;			buttonParam.minMaxBounds.right = kHUI_Pixel_Max;			buttonParam.minMaxBounds.left = 0;//			HUI_PushButton_New_LiteralP( &buttonParam);		}		textParam.space.left = 4;		if ( i == kCP_Arrive_Action_Index_ID)		{		// label kCP_Arrive_Action_DistanceI_ID			HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Arrive_Action_Distance_ID - 1, &textParam);			textParam.space.top = 12;			textParam.whichTabSet = 1;			textParam.whichTab = 0;			textParam.flags = huiControlFlag_newLine;			HUI_StaticText_New_LiteralP( &textParam);				// edit kCP_Arrive_Action_DistanceI_ID			HU_HeweyParam_SetFromHC( d->huiCoordData, kCP_Arrive_Action_Distance_ID, &textParam);			textParam.minMaxBounds.left = kEditTextFieldWidth;			textParam.flags = huiControlFlag_none;			textParam.whichTabSet = 1;			textParam.whichTab = 1;			if ( d->chooseOnly)				HUI_StaticText_New_LiteralP( &textParam);			else				HUI_EditText_New_LiteralP( &textParam);		}		textParam.flags = huiControlFlag_newLine;	}			// rotating shape special panel		HU_HeweyParam_SetFromHC( d->huiCoordData, kRP_First_List_Item, &textParam);		textParam.flags = huiControlFlag_none;		for ( i = kRP_First_List_Item; i <= kRP_Last_List_Item; i += 2)	{			// label			HU_HeweyParam_SetFromHC( d->huiCoordData, i-1, &textParam);			textParam.space.top = 12;			textParam.whichTabSet = 0;			textParam.whichTab = 0;			HUI_StaticText_New_LiteralP( &textParam);				// edit			HU_HeweyParam_SetFromHC( d->huiCoordData, i, &textParam);			textParam.minMaxBounds.left = kEditTextFieldWidth;			textParam.flags = huiControlFlag_none;			textParam.whichTabSet = 0;			textParam.whichTab = 1;			if ( i != kRP_Shape_Field_ID)			{				textParam.minMaxBounds.left = kEditTextFieldWidth;				if ( d->chooseOnly)					HUI_StaticText_New_LiteralP( &textParam);				else					HUI_EditText_New_LiteralP( &textParam);			} else			{				textParam.minMaxBounds.left = kEditTextHugeFieldWidth;				HUI_StaticText_New_LiteralP( &textParam);				}						if ( i == kRP_Shape_Field_ID)			{				buttonParam.layer = textParam.layer;				buttonParam.cellx = textParam.cellx;				buttonParam.celly = textParam.celly;				buttonParam.master = textParam.master;				buttonParam.id = kRP_Choose_Shape_Button;				buttonParam.whichTabSet = -1;				buttonParam.whichTab = -1;				buttonParam.flags = huiControlFlag_none;				GetIndString( buttonParam.label, kStrResID, 105);				HUI_PushButton_New_LiteralP( &buttonParam);			}		textParam.flags = huiControlFlag_newLine;			}	textParam.minMaxBounds.left = kEditTextFieldWidth;	// self animating special panel	textParam.flags = huiControlFlag_none;	for ( i = kMP_First_List_Item; i <= kMP_Last_List_Item; i += 2)	{			// label			HU_HeweyParam_SetFromHC( d->huiCoordData, i-1, &textParam);			textParam.space.top = 12;			textParam.whichTabSet = 0;			textParam.whichTab = 0;			HUI_StaticText_New_LiteralP( &textParam);				// edit			HU_HeweyParam_SetFromHC( d->huiCoordData, i, &textParam);			textParam.flags = huiControlFlag_none;			textParam.whichTabSet = 0;			textParam.whichTab = 1;			if ( i != kMP_Shape_Field)			{				textParam.minMaxBounds.left = kEditTextFieldWidth;				if ( d->chooseOnly)					HUI_StaticText_New_LiteralP( &textParam);				else					HUI_EditText_New_LiteralP( &textParam);			} else			{				textParam.minMaxBounds.left = kEditTextHugeFieldWidth;				HUI_StaticText_New_LiteralP( &textParam);					textParam.minMaxBounds.left = kEditTextFieldWidth;			}						if ( i == kMP_Shape_Field)			{				buttonParam.layer = textParam.layer;				buttonParam.cellx = textParam.cellx;				buttonParam.celly = textParam.celly;				buttonParam.master = textParam.master;				buttonParam.id = kMP_Choose_Shape_Button;				buttonParam.whichTabSet = -1;				buttonParam.whichTab = -1;				buttonParam.flags = huiControlFlag_none;				GetIndString( buttonParam.label, kStrResID, 105);				HUI_PushButton_New_LiteralP( &buttonParam);			}		textParam.flags = huiControlFlag_newLine;			}	// beam special panel	textParam.flags = huiControlFlag_none;	for ( i = kBP_First_List_Item; i <= kBP_Last_List_Item; i += 2)	{			// label			HU_HeweyParam_SetFromHC( d->huiCoordData, i-1, &textParam);			textParam.space.top = 12;			textParam.whichTabSet = 0;			textParam.whichTab = 0;			HUI_StaticText_New_LiteralP( &textParam);				// edit			HU_HeweyParam_SetFromHC( d->huiCoordData, i, &textParam);			textParam.minMaxBounds.left = kEditTextFieldWidth;			textParam.flags = huiControlFlag_none;			textParam.whichTabSet = 0;			textParam.whichTab = 1;			if ( i == kBP_Color_ID)			{				// shield color menu				textParam.special.menuStrList.strList = GetStringList( 590);				textParam.special.menuStrList.menuID = HU_GetNewMenuID();				HUI_PopupButton_New_StrList( &textParam);			} else if ( i == kBP_Kind_ID)			{				// shield color menu				textParam.special.menuStrList.strList = GetStringList( 591);				textParam.special.menuStrList.menuID = HU_GetNewMenuID();				HUI_PopupButton_New_StrList( &textParam);			} else			{				if ( d->chooseOnly)					HUI_StaticText_New_LiteralP( &textParam);				else					HUI_EditText_New_LiteralP( &textParam);			}		textParam.flags = huiControlFlag_newLine;			}	// device special panel	textParam.flags = huiControlFlag_none;	for ( i = kDP_First_List_Item; i <= kDP_Last_List_Item; i += 2)	{			// label			HU_HeweyParam_SetFromHC( d->huiCoordData, i-1, &textParam);			textParam.space.top = 12;			textParam.whichTabSet = 0;			textParam.whichTab = 0;			if (( i != kDP_Calc_Inverse_Speed_Now_ID) &&				( i != kDP_Calc_Range_Now_ID))				HUI_StaticText_New_LiteralP( &textParam);				if ( i == kDP_Usage_ID)			{				HU_HeweyParam_SetFromHC( d->huiCoordData, i, &buttonParam);								buttonParam.special.menuStrList.strList = GetStringList( 8014);				buttonParam.special.menuStrList.menuID = HU_GetNewMenuID();//130 + i;				buttonParam.special.menuStrList.cicnResID = 128;				buttonParam.special.menuStrList.multiSelect = true;				buttonParam.whichTabSet = 0;				buttonParam.whichTab = 1;				buttonParam.flags = huiControlFlag_none;				buttonParam.space.left = 8;								HUI_BevelButtonMenu_New_StrList( &buttonParam);				buttonParam.whichTabSet = -1;				buttonParam.whichTab = -1;				if ( buttonParam.special.menuStrList.strList != nil)					ReleaseResource( buttonParam.special.menuStrList.strList);									// set attributes button				buttonParam.id = kDP_Usage_Button_ID;				GetIndString( buttonParam.label, kStrResID, 92); // setÉ				buttonParam.space.left = 8;				buttonParam.minMaxBounds.right = kHUI_Pixel_Max;				buttonParam.minMaxBounds.left = 0;				HUI_PushButton_New_LiteralP( &buttonParam);			} else if (( i == kDP_Calc_Inverse_Speed_Now_ID) ||				( i == kDP_Calc_Range_Now_ID))			{				HU_HeweyParam_SetFromHC( d->huiCoordData, i, &buttonParam);				buttonParam.whichTabSet = 0;				buttonParam.whichTab = 1;				buttonParam.space.left = 8;				buttonParam.flags = huiControlFlag_newLine;								HUI_PushButton_New_LiteralP( &buttonParam);							} else			{				// edit				HU_HeweyParam_SetFromHC( d->huiCoordData, i, &textParam);				textParam.minMaxBounds.left = kEditTextFieldWidth;				textParam.flags = huiControlFlag_none;				textParam.whichTabSet = 0;				textParam.whichTab = 1;				if ( d->chooseOnly)					HUI_StaticText_New_LiteralP( &textParam);				else					HUI_EditText_New_LiteralP( &textParam);			}		textParam.flags = huiControlFlag_newLine;			}	// pulse point label/*	HU_HeweyParam_SetFromHC( d->huiCoordData, 509, &textParam);	textParam.space.top = 12;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_none;	HUI_StaticText_New_LiteralP( &textParam);		// pulse point edit	HU_HeweyParam_SetFromHC( d->huiCoordData, 510, &textParam);	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		// destroy action label	HU_HeweyParam_SetFromHC( d->huiCoordData, 809, &textParam);	textParam.space.top = 12;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_none;	HUI_StaticText_New_LiteralP( &textParam);		// destroy action edit	HU_HeweyParam_SetFromHC( d->huiCoordData, 810, &textParam);	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);		// shape offset label	HU_HeweyParam_SetFromHC( d->huiCoordData, 1109, &textParam);	textParam.space.top = 12;	textParam.whichTabSet = 0;	textParam.whichTab = 0;	textParam.flags = huiControlFlag_none;	HUI_StaticText_New_LiteralP( &textParam);		// shape offset edit	HU_HeweyParam_SetFromHC( d->huiCoordData, 1110, &textParam);	textParam.minMaxBounds.left = kEditTextFieldWidth;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 1;	HUI_EditText_New_LiteralP( &textParam);	*/	// set up separator	buttonParam.master = d->master;	buttonParam.layer = 0;	buttonParam.cellx = kSeparator_Cell_X;	buttonParam.celly = kSeparator_Cell_Y;	buttonParam.id = kSeparator_ID;	buttonParam.flags = huiControlFlag_useCellH;	buttonParam.minMaxBounds.bottom = 8;	buttonParam.space.top = 0;	buttonParam.space.left = 0;	HUI_SeparatorLine_New( &buttonParam);		// set up main buttons	strList = GetStringList( 8004);		HUI_Main_Buttons_H_Setup( d->master, 0,		kSeparator_Cell_X, kColNum, kSeparator_Cell_Y, 1,			false, strList);		ReleaseResource( strList);	ShowWindow( (WindowPtr)newWindow);	HUI_Master_Layout( d->master, (Point){0, 0}, (Point){0, 0});	for ( i = 0; i < d->panel->layerNum; i++)	{		HUI_Master_HideLayer(d->panel, i);	}		HUI_Master_ShowLayer( d->panel, 0);		GetAllData( d);		HUI_Control_GetListValue( d->master, 0, kList_Cell_X, kList_Cell_Y,										kList_ID, d->whichObject);	Window_SetControls_FromObjectIndex( d, newWindow, d->whichObject);		HUnlock( data);	UseResFile( oldResRefNum);		if ( d->isModal) gHera->modalMode++;	if ( d->discreteObjectData == nil) Enable_Editing( d, false);		return noErr;ObjectEditor_NewWindow_error:	UseResFile( oldResRefNum);	if ( d != nil)	{		if ( d->huiCoordData != nil) ReleaseResource( d->huiCoordData);/*		if ( d->objectData != nil)			DisposeHandle( d->objectData);		if ( d->objectNameStrings != nil)			DisposeHandle( d->objectNameStrings);		if ( d->objectShortStrings != nil)			DisposeHandle( d->objectShortStrings);		if ( d->objectNoteStrings != nil)			DisposeHandle( d->objectNoteStrings);*/					if ( d->master != nil)			HUI_MasterControl_Delete( d->master); // deletes sub-masters				HUnlock( data);		DisposeHandle( data);	}	if ( newWindow != nil) DisposeWindow( (WindowPtr)newWindow);	return err;}void HU_HeweyParam_SetFromHC( Handle huiCoordData, long id, huiPlainControlParamType *p){	long				max = GetHandleSize( huiCoordData) / sizeof( huiCoordDataType),						index = 0;	huiCoordDataType	*hc = (huiCoordDataType *)*huiCoordData;		while (( index < max) && ( hc->id != id)) { hc++; index++;}	mAssert( index < max);	if ( index >= max) return;	p->id = id;	p->cellx = hc->cellx;	p->celly = hc->celly;	p->layer = hc->panel;	GetIndString( p->label, hc->stringResID, hc->stringNum);	p->helpStringResID = hc->helpResID;	p->enabledOnIndex = hc->helpOnIndex;	p->enabledOffIndex = hc->helpOffIndex;	p->disabledIndex = hc->helpDisabledIndex;}