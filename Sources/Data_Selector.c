/******************************************\|**| This_File.c\******************************************/#pragma mark ¥¥INCLUDES¥¥/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Window Dispatch.h"#include "Control Utilities.h"#include "Hewey.h"#include "Hewey_Main.h"#include "Hewey_Layout.h"#include "Hewey_Utilities.h"#include "str_bp.h"#include "Set Font By String.h"#include "BP_Error.h"#include "BPMacOutput.h"#include "Assert.h"#include "Classic2Carbon_Helpers.h"#pragma mark _this library includes_/* - this project*******************************************/// ares#include "Scenario_Data.h"#include "Ares_Version.h"#include "Scenario.h"// hera utils#include "Hera_Global.h"#include "Hera_Utilities.h"#include "Hera_ResourceTracker.h"#include "Button_Window.h"// hera editors#include "Data_Selector.h"#include "Race_Editor.h"#include "Object_Editor.h"#include "Action_Editor.h"#include "Condition_Editor.h"#include "Initial_Editor.h"#include "Scenario_Editor.h"#pragma mark ¥¥DEFINITIONS¥¥/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kTabWidth						80#define	kEditText_FieldWidth_Big		240#define	kControl_H_Space				4#define	kRowNum							4#define	kGlobal_Row						0#define	kGlobal_ID_Offset				700#define	kGlobal_GroupID					(kGlobal_ID_Offset + 10)#define	kGlobal_Title_ID				(kGlobal_ID_Offset + 2)#define	kGlobal_Author_ID				(kGlobal_ID_Offset + 4)#define	kGlobal_Author_URL_ID			(kGlobal_ID_Offset + 6)#define	kGlobal_Download_URL_ID			(kGlobal_ID_Offset + 8)#define	kGlobal_Version_ID			(kGlobal_ID_Offset + 12)#define	kRace_Row						1#define	kRaceIDOffset					100#define	kRace_GroupID					(kRaceIDOffset + 1)#define	kRace_UseFactory_Radio_ID		(kRaceIDOffset + 2)#define	kRace_UseCustom_CheckBox_ID		(kRaceIDOffset + 3)#define	kRace_Edit_Button_ID			(kRaceIDOffset + 4)#define	kRace_DeleteCustom_Button_ID	(kRaceIDOffset + 5)#define	kObject_Row						2#define	kObjectIDOffset					200#define	kObject_GroupID					(kObjectIDOffset + 1)#define	kObject_UseFactory_Radio_ID		(kObjectIDOffset + 2)#define	kObject_UseCustom_CheckBox_ID	(kObjectIDOffset + 3)#define	kObject_Edit_Button_ID			(kObjectIDOffset + 4)#define	kObject_DeleteCustom_Button_ID	(kObjectIDOffset + 5)/*#define	kAction_Row						2#define	kActionIDOffset					300#define	kAction_GroupID					(kActionIDOffset + 1)#define	kAction_UseFactory_Radio_ID		(kActionIDOffset + 2)#define	kAction_UseCustom_Radio_ID		(kActionIDOffset + 3)#define	kAction_Edit_Button_ID			(kActionIDOffset + 4)#define	kAction_DeleteCustom_Button_ID	(kActionIDOffset + 5)#define	kCondition_Row						3#define	kConditionIDOffset					400#define	kCondition_GroupID					(kConditionIDOffset + 1)#define	kCondition_UseFactory_Radio_ID		(kConditionIDOffset + 2)#define	kCondition_UseCustom_Radio_ID		(kConditionIDOffset + 3)#define	kCondition_Edit_Button_ID			(kConditionIDOffset + 4)#define	kCondition_DeleteCustom_Button_ID	(kConditionIDOffset + 5)#define	kInitial_Row						4#define	kInitialIDOffset					500#define	kInitial_GroupID					(kInitialIDOffset + 1)#define	kInitial_UseFactory_Radio_ID		(kInitialIDOffset + 2)#define	kInitial_UseCustom_Radio_ID			(kInitialIDOffset + 3)#define	kInitial_Edit_Button_ID				(kInitialIDOffset + 4)#define	kInitial_DeleteCustom_Button_ID		(kInitialIDOffset + 5)*/#define	kScenario_Row						3#define	kScenarioIDOffset					600#define	kScenario_GroupID					(kScenarioIDOffset + 1)#define	kScenario_UseFactory_Radio_ID		(kScenarioIDOffset + 2)#define	kScenario_UseCustom_CheckBox_ID		(kScenarioIDOffset + 3)#define	kScenario_Edit_Button_ID			(kScenarioIDOffset + 4)#define	kScenario_DeleteCustom_Button_ID	(kScenarioIDOffset + 5)#define	kStrResID						8001#pragma mark _macros_/* - macros*******************************************/#define	mSetUpStandardAlert( m_a) \				(m_a)->movable = false;\				(m_a)->helpButton = false;\				(m_a)->filterProc = nil;\				(m_a)->defaultText = nil;\				(m_a)->cancelText = nil;\				(m_a)->otherText = nil;\				(m_a)->defaultButton = kAlertStdAlertOKButton;\				(m_a)->cancelButton = 0;\				(m_a)->position = kWindowDefaultPosition;\#pragma mark ¥¥TYPEDEFS¥¥/******************************************\|**| typedefs\******************************************/typedef struct dataSelectorWindowType{	heraScenarioFileType	*heraFile;	huiMasterControlType	*master;	long					raceWindowID;	long					objectWindowID;	long					actionWindowID;	long					scenarioWindowID;} dataSelectorWindowType;#pragma mark ¥¥EXTERNAL GLOBALS¥¥/******************************************\|**| external globals\******************************************/extern heraGlobalType	*gHera;OSErr HeraFile_SaveAs( heraScenarioFileType *sourceFile, Boolean copy,	Boolean optimized);void RemoveHeraFile( heraScenarioFileType *heraFile);#pragma mark ¥¥PRIVATE GLOBALS¥¥/******************************************\|**| private globals\******************************************/#pragma mark ¥¥PRIVATE PROTOTYPES¥¥/******************************************\|**| private function prototypes\******************************************/#pragma mark ¥¥PRIVATE FUNCTIONS¥¥/******************************************\|**| private functions\******************************************/static Boolean HandleEvent( EventRecord *, CWindowPtr, long, long);static void Data_Selector_Save( long dispatchID);static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID);static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID);static void CustomRace_CheckBox_Click( ControlHandle aControl,	dataSelectorWindowType *d);static void CustomObject_CheckBox_Click( ControlHandle aControl,	dataSelectorWindowType *d);static void CustomScenario_CheckBox_Click( ControlHandle aControl,	dataSelectorWindowType *d);static void SetScenarioInfo_FromControls( dataSelectorWindowType *d);Boolean Data_Selector_Close( CWindowPtr whichWindow, long dispatchID,		Boolean confirm);static void ScenarioEditor_CallBack( Boolean ok, long windowID);static void ObjectEditor_CallBack( long windowID, long objectChoiceID);static void RaceEditor_CallBack( Boolean ok, long windowID);#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/static Boolean HandleEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID, long command){	switch( command)	{		case kWDCloseWindowCommand:			break;				case kWDProcessEventCommand:			return( ProcessEvent( theEvent, whichWindow, dispatchID));			break;				case kWDSaveWindowCommand:			if (HU_ScenarioFiles_Equal( gHera->currentSave,				HU_HeraFile_Get_From_WindowID( dispatchID)))			{				Data_Selector_Save( dispatchID);			}			return false;			break;				case kWDProcessMenuChoiceCommand:			return( ProcessMenuChoiceCommand( (unsigned long)theEvent,				whichWindow, dispatchID));			break;				case kWDQuitCommand:			return Data_Selector_Close( whichWindow, dispatchID, true);	}	return false;}static void Data_Selector_Save( long dispatchID){	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	SignedByte						dataState;	dataSelectorWindowType			*d;	if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (dataSelectorWindowType *)*data;	SetScenarioInfo_FromControls( d);	HSetState( data, dataState);}static Boolean ProcessMenuChoiceCommand( unsigned long menuData,		CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	SignedByte						dataState;	dataSelectorWindowType			*d;	Boolean							result = false;	GrafPtr							oldPort;	short							menuID = ((menuData & 0xffff0000) >> 16),									menuItem = (menuData & 0x0000ffff);										if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (dataSelectorWindowType *)*data;	GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);	result = Generic_ProcessMenuChoiceCommand( menuData, whichWindow,												dispatchID);	if ( result)	{		goto ProcessMenuChoiceCommand_Return;	}		switch( menuID)	{		case kEditMenuID:			switch( menuItem)			{				case kEditMenuID:					result = true;					break;									case kEdit_Undo_Item:					result = true;					break;									case kEdit_Cut_Item:					result = true;					break;									case kEdit_Copy_Item:					result = true;					break;									case kEdit_Paste_Item:					result = true;					break;									case kEdit_Clear_Item:					result = true;					break;									case kEdit_Select_All_Item:					result = true;					break;									case kEdit_Add_Item:					result = true;					break;									case kEdit_Delete_Item:					result = true;					break;									case kEdit_Delete_All_Item:					result = true;					break;			}							break;		/*		case kFileMenuID:			switch( menuItem)			{				case kFile_Save_Item:					if ( d->heraFile != nil)					{						if ( d->heraFile->fileRefNum > 0)						{							SetScenarioInfo_FromControls( d);							HD_CompileDiscreteData( d->heraFile, false);						}					}						//					HD_Save( d->heraFile);					result = true;					break;								case kFile_Save_As_Item:					if ( d->heraFile != nil)					{						if ( d->heraFile->fileRefNum > 0)						{							HeraFile_SaveAs( d->heraFile, false, false);						}					}					result = true;					break;								case kFile_Save_As_Optimized_Item:					if ( d->heraFile != nil)					{						if ( d->heraFile->fileRefNum > 0)						{							HeraFile_SaveAs( d->heraFile, true, true);						}					}					result = true;					break;			}			break;*/	}	ProcessMenuChoiceCommand_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);}static Boolean ProcessEvent( EventRecord *theEvent,	CWindowPtr whichWindow, long dispatchID){	Handle							data = GetDispatchWindowDataHandle( dispatchID);	SignedByte						dataState;	Boolean							result = false;	ControlHandle					aControl, oldControl;	short							whichPart, oldValue;	WindowPtr						scratchWindow;	Point							where;	char							whichChar;	GrafPtr							oldPort;	OSStatus						err;	dataSelectorWindowType			*d;	Str255							s;		if ( data == nil) return false;	if ( theEvent == nil) return false;		dataState = HGetState( data);	HLock( data);	d = (dataSelectorWindowType *)*data;		if ( theEvent == nil) goto ProcessEvent_Return;		GetPort( &oldPort);	SetPortWindowPort( (WindowPtr)whichWindow);		switch( theEvent->what)	{		case nullEvent:			IdleControls( (WindowPtr)whichWindow);						result = true;			break;					case updateEvt:				BeginUpdate ((WindowPtr)whichWindow);/*			SetPort( (WindowPtr)whichWindow);			CalcVis( (WindowPtr)whichWindow);			UpdateControls( (WindowPtr)whichWindow, whichWindow->visRgn);*/			HU_GenericUpdateEventHandler( whichWindow);			EndUpdate ((WindowPtr)whichWindow);			result = true;			break;		case activateEvt:		{			Boolean	isActive = ((theEvent->modifiers & activeFlag) != 0);						if ( isActive)			{				if ( d->heraFile->fileRefNum > 0)					UseResFile( d->heraFile->fileRefNum);				else					UseResFile( gHera->default_scenarioFile_refNum);			}		}			// result != true so dispatch window will handle activation			// of controls etc.			break;					case mouseDown:			whichPart = FindWindow (theEvent->where, &scratchWindow);			switch( whichPart)			{				case inGrow:/*					{						Rect	growRect;						long	newSize;//						growRect = qd.screenBits.bounds;						C2C_ScreenBits_GetBounds( &growRect);						growRect.top = growRect.left = 120;						newSize = GrowWindow((WindowPtr)whichWindow,							theEvent->where ,&growRect);						if (newSize != 0)						{							SizeWindow( (WindowPtr)whichWindow, newSize & 0xffff,								(((newSize) >> 16) & 0xFFFF), true );							EraseRect(&whichWindow->portRect);							InvalRect( &whichWindow->portRect);						}					}*/					HU_GenericGrowWindow( whichWindow, theEvent->where);					result = true;					break;								case inGoAway:					if ( TrackGoAway ((WindowPtr)whichWindow, theEvent->where))					{						Data_Selector_Close( whichWindow, dispatchID, true);					}					result = true;										break;				case inContent:					where = theEvent->where;					scratchWindow = WD_FrontWindow();					if ( whichWindow != (CWindowPtr)scratchWindow)					{						goto ProcessEvent_Return;					}					SetPortWindowPort( (WindowPtr)whichWindow);					GlobalToLocal( &where);					whichPart = FindControl( where, (WindowPtr)whichWindow,						&aControl);					if ( aControl == nil)						goto ProcessEvent_Return;					if ( aControl != nil)						oldValue = GetControlValue( aControl);					err = GetKeyboardFocus( (WindowPtr)whichWindow, &oldControl);					if (( err == noErr) && ( oldControl != aControl) && ( aControl != nil))					{						SetKeyboardFocus( (WindowPtr)whichWindow, aControl, whichPart);					}					if ( whichPart != 0)					{						huiPlainControlType	*hui = (huiPlainControlType	*)CU_GetControlReference( aControl);//						whichPart = HandleControlClick ( aControl, where,//							theEvent->modifiers, nil);						if ( !ListBox_Appearance_1_0_1_Hack( aControl, where,									&whichPart))						{							whichPart = HUI_Control_Click_Handle( hui, where,								theEvent->modifiers);														}							if ( whichPart != kControlNoPart) switch( hui->generic.id)						{							case kRace_Edit_Button_ID:								if ( d->raceWindowID < 0)								{									RaceEditor_NewWindow( d->heraFile,										&d->raceWindowID,										gHera->default_scenarioFile_refNum,										dispatchID, RaceEditor_CallBack);								} else									WindowDispatch_BrindWindowIDToFront(										d->raceWindowID);								result = true;								break;														case kRace_UseCustom_CheckBox_ID:								CustomRace_CheckBox_Click( aControl,d);								result = true;								break;															case kObject_Edit_Button_ID:								if ( d->objectWindowID < 0)								{									if ( d->heraFile->fileRefNum <= 0)										pstrcpy( s, "\pFactory Scenarios");									else										pstrcpy( s, d->heraFile->fileSpec.name);																			ObjectEditor_NewWindow( d->heraFile,										&d->objectWindowID, dispatchID, -1,										s,										gHera->default_scenarioFile_refNum,										false, true, true, false,										ObjectEditor_CallBack);								} else									WindowDispatch_BrindWindowIDToFront(										d->objectWindowID);								result = true;								break;														case kObject_UseCustom_CheckBox_ID:								CustomObject_CheckBox_Click( aControl, d);								result = true;								break;								/*							case kAction_Edit_Button_ID:							{									Ptr	hack = NewPtrClear( sizeof( objectActionType));									Handle	obac;									short	oldResFile;									OSErr	err;									long	count;																		if ( hack != nil)									{										HU_UseResFile( gHera->default_scenarioFile_refNum,											&oldResFile);										obac = GetResource( 'obac', 500);										if ( obac != nil)										{											DetachResource( obac);											for ( count = 0; count < 99; count++)											{												err = HU_Handle_InsertData(													GetHandleSize( obac) /														sizeof( objectActionType),													 obac, hack, sizeof( objectActionType));											}											Resource_Replace( 'obac', 500,  obac, "\pHera Obac Data");											UpdateResFile( gHera->default_scenarioFile_refNum);										}										UseResFile( oldResFile);									}								}//								if ( d->actionWindowID < 0)//									Action_Editor_NewWindow( "\pAll Actions",//										gHera->default_scenarioFile_refNum,//										0, 99999, nil, false);								break;*/								/*							case kCondition_Edit_Button_ID:							{									Ptr	hack = NewPtrClear( sizeof( scenarioConditionType));									Handle	sncd;									short	oldResFile;									OSErr	err;									long	count;																		if ( hack != nil)									{										HU_UseResFile( gHera->default_scenarioFile_refNum,											&oldResFile);										sncd = GetResource( 'sncd', 500);										if ( sncd != nil)										{											DetachResource( sncd);											for ( count = 0; count < 99; count++)											{												err = HU_Handle_InsertData(													GetHandleSize( sncd) /														sizeof( scenarioConditionType),													 sncd, hack, sizeof( scenarioConditionType));											}											Resource_Replace( 'sncd', 500,  sncd, "\pHera sncd Data");											UpdateResFile( gHera->default_scenarioFile_refNum);										}										UseResFile( oldResFile);									}								}//								if ( d->conditionWindowID < 0)//									Condition_Editor_NewWindow( "\pAll Conditions",//										gHera->default_scenarioFile_refNum,//										0, 99999);								break;*/							/*							case kInitial_Edit_Button_ID:							{									Ptr	hack = NewPtrClear( sizeof( scenarioInitialType));									Handle	snit;									short	oldResFile;									OSErr	err;									long	count;																		if ( hack != nil)									{										HU_UseResFile( gHera->default_scenarioFile_refNum,											&oldResFile);										snit = GetResource( 'snit', 500);										if ( snit != nil)										{											DetachResource( snit);											for ( count = 0; count < 99; count++)											{												err = HU_Handle_InsertData(													GetHandleSize( snit) /														sizeof( scenarioInitialType),													snit, hack, sizeof( scenarioInitialType));											}											Resource_Replace( 'snit', 500, snit, "\pHera Snit Data");											UpdateResFile( gHera->default_scenarioFile_refNum);										}										UseResFile( oldResFile);									}								}//								Initial_Editor_NewWindow("\pAll Initial Objects",//										gHera->default_scenarioFile_refNum,//										0, 99999);*/								break;															case kScenario_Edit_Button_ID:								if ( d->scenarioWindowID < 0)								{									if ( d->heraFile->fileRefNum <= 0)										pstrcpy( s, "\pFactory Scenarios");									else										pstrcpy( s, d->heraFile->fileSpec.name);									Scenario_Editor_NewWindow( d->heraFile,										s,										gHera->default_scenarioFile_refNum,										dispatchID, ScenarioEditor_CallBack,										&d->scenarioWindowID);								} else									WindowDispatch_BrindWindowIDToFront(										d->scenarioWindowID);								result = true;								break;														case kScenario_UseCustom_CheckBox_ID:								CustomScenario_CheckBox_Click( aControl, d);								result = true;								break;															default:								break;						}					} else // not in control					{						where = theEvent->where;						GlobalToLocal( &where);					}			}			break;					case keyDown:		case autoKey:			whichChar = theEvent->message & charCodeMask;			if ((whichChar=='\r' || whichChar==0x3))			{				// ok				long			soon = TickCount()+5;				//				aControl = HUI_Control_Get( master, 0, 0, 2, 2);//				if ( aControl != nil)//				{//					DeactivateControl( aControl, 1);//					while ( TickCount() < soon){ /* do nothing */}//					DeactivateControl( aControl, 0);//					result = true;////					goto ProcessEvent_Return;//				}			} else if ((whichChar==0x1b) || ((whichChar=='.') && (theEvent->modifiers & cmdKey)))			{				// cancel				long			soon = TickCount()+5;				//				aControl = HUI_Control_Get( master, 0, 0, 2, 2);//				if ( aControl != nil)//				{//					DeactivateControl( aControl, 1);//					while ( TickCount() < soon){ /* do nothing */}//					DeactivateControl( aControl, 0);//					//					CloseDispatchWindow( dispatchID);//					result = true;//					goto ProcessEvent_Return;//				}			} else if ( whichChar == '\t')			{				if ( theEvent->modifiers & shiftKey)					ReverseKeyboardFocus( (WindowPtr)whichWindow);				else					AdvanceKeyboardFocus( (WindowPtr)whichWindow);				result = true;				break;			}						err = GetKeyboardFocus( (WindowPtr)whichWindow, &aControl);			if (( err == noErr) && ( aControl != nil))			{				whichPart = HandleControlKey( aControl,					(theEvent->message & keyCodeMask)>>16,					theEvent->message & charCodeMask, theEvent->modifiers);				{				}			}			break;	}		ProcessEvent_Return:	SetPort( oldPort);	HSetState( data, dataState);	return( result);	}static void CustomRace_CheckBox_Click( ControlHandle aControl,	dataSelectorWindowType *d){	AlertStdAlertParamRec			alertParam;	unsigned char					okButton[] = "\pOK",									cancelButton[] = "\pCancel";	short							itemHit, ownerRefNum = -1;	Handle							data;		if ( ((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags		& kScenario_Data_Flag_HasCustomRaces)	{		mSetUpStandardAlert( &alertParam);		alertParam.defaultText = okButton;		alertParam.cancelText = cancelButton;		alertParam.defaultButton =			kAlertStdAlertCancelButton;		StandardAlert( kAlertCautionAlert,			"\pDispose of Custom Races",			"\pAre you sure you want to use the "			"factory races and dispose of the "			"custom races?",			&alertParam,			&itemHit);												if ( itemHit == kAlertStdAlertOKButton)		{			SetControlValue( aControl, 0);			((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags				&= ~kScenario_Data_Flag_HasCustomRaces;							// now we've got to delete the custom race data			data = HRT_Resource_GetHandle_WithOwnerFile(				d->heraFile, 'race', 500, nil, &ownerRefNum, nil);						// if it exists in our file, kill it			if (data != nil)			{				if ( ownerRefNum == d->heraFile->fileRefNum)					HRT_DeleteResource( d->heraFile, 'race', 500);				DisposeHandle( data);			}		}	} else	{		if (( ((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags			& kScenario_Data_Flag_HasCustomObjects)			&& ( ((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags			& kScenario_Data_Flag_HasCustomScenarios))		{			mSetUpStandardAlert( &alertParam);			alertParam.defaultText = okButton;			alertParam.cancelText = cancelButton;			alertParam.defaultButton =				kAlertStdAlertCancelButton;			StandardAlert( kAlertCautionAlert,				"\pCreate Custom Races",				"\pAre you sure you want to use "				"custom races?",				&alertParam,				&itemHit);		} else		{			mSetUpStandardAlert( &alertParam);			alertParam.defaultText = okButton;			alertParam.cancelText = cancelButton;			alertParam.defaultButton =				kAlertStdAlertCancelButton;			StandardAlert( kAlertCautionAlert,				"\pCreate Custom Races",				"\pAre you sure you want to use "				"custom races?\r\r"				"Since you aren't using custom "				"objects and custom scenarios, "				"you won't be able to add or "				"remove races or change their "				"I.D.s.",				&alertParam,				&itemHit);		}				if ( itemHit == kAlertStdAlertOKButton)		{			SetControlValue( aControl, 1);			((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags				|= kScenario_Data_Flag_HasCustomRaces;		}	}}static void CustomObject_CheckBox_Click( ControlHandle aControl,	dataSelectorWindowType *d){	AlertStdAlertParamRec			alertParam;	unsigned char					okButton[] = "\pOK",									cancelButton[] = "\pCancel";	short							itemHit, ownerRefNum;	Handle							data, nextData;	long							offset, size;		if ( ((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags		& kScenario_Data_Flag_HasCustomObjects)	{		mSetUpStandardAlert( &alertParam);		alertParam.defaultText = okButton;		alertParam.cancelText = cancelButton;		alertParam.defaultButton =			kAlertStdAlertCancelButton;		StandardAlert( kAlertCautionAlert,			"\pDispose of Custom Objects",			"\pAre you sure you want to use the "			"factory objects and dispose of the "			"custom objects?",			&alertParam,			&itemHit);												if ( itemHit == kAlertStdAlertOKButton)		{			SetControlValue( aControl, 0);			((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags				&= ~kScenario_Data_Flag_HasCustomObjects;							// now we've got to delete the custom object resource (bsob)			// from the file			data = HRT_Resource_GetHandle_WithOwnerFile(				d->heraFile, 'bsob', 500, nil, &ownerRefNum, nil);						// if it exists in our file, kill it			if (data != nil)			{				if ( ownerRefNum == d->heraFile->fileRefNum)				{					BPMOWritePString("\pdeleting base object resource\r");					HRT_DeleteResource( d->heraFile, 'bsob', 500);				}				DisposeHandle( data);			}						// we've also got to delete the STR# resources			data = HRT_Resource_GetHandle_WithOwnerFile(				d->heraFile, 'STR#', 5000, nil, &ownerRefNum, nil);						// if it exists in our file, kill it			if (data != nil)			{				if ( ownerRefNum == d->heraFile->fileRefNum)				{					BPMOWritePString("\pdeleting base object string 5000\r");					HRT_DeleteResource( d->heraFile, 'STR#', 5000);				}				DisposeHandle( data);			}			data = HRT_Resource_GetHandle_WithOwnerFile(				d->heraFile, 'STR#', 5001, nil, &ownerRefNum, nil);						// if it exists in our file, kill it			if (data != nil)			{				if ( ownerRefNum == d->heraFile->fileRefNum)				{					BPMOWritePString("\pdeleting base object string 5001\r");					HRT_DeleteResource( d->heraFile, 'STR#', 5001);				}				DisposeHandle( data);			}			data = HRT_Resource_GetHandle_WithOwnerFile(				d->heraFile, 'STR#', 5002, nil, &ownerRefNum, nil);						// if it exists in our file, kill it			if (data != nil)			{				if ( ownerRefNum == d->heraFile->fileRefNum)				{					BPMOWritePString("\pdeleting base object string 5002\r");					HRT_DeleteResource( d->heraFile, 'STR#', 5002);				}				DisposeHandle( data);			}						// and we've got to delete all custom discrete object data			data = HD_DiscreteData_GetNextOfType( d->heraFile, nil,				kHera_Object_Type);			while ( data != nil)			{				nextData = HD_DiscreteData_GetNextOfType( d->heraFile, data,					kHera_Object_Type);				//				BPMOWritePString("\pdel bsob id:\t");//				BPMOWriteLong( ((heraDataHeaderType *)*data)->id);//				BPMOWritePString("\p\r");//				BPMOKeyWait();								HD_Delete_Discrete_Data( d->heraFile, data);				data = nextData;			}			// repeat deletion for discrete object string data			data = HD_DiscreteData_GetNextOfType( d->heraFile, nil,				kHera_ObjectStrings_Type);			while ( data != nil)			{				nextData = HD_DiscreteData_GetNextOfType( d->heraFile, data,					kHera_ObjectStrings_Type);								HD_Delete_Discrete_Data( d->heraFile, data);				data = nextData;			}									BPMOWritePString("\p\r\rBEGIN COPYING ORIGINAL DATA\r\r");			BPMOSetKeySkip( false);						// now we want to copy all the original discrete data to			// our heraFile in memory			data = HD_DiscreteData_GetNextOfType( &gHera->factory, nil,				kHera_Object_Type);			while ( data != nil)			{//				BPMOWritePString("\padd bsob id:\t");//				BPMOWriteLong( ((heraDataHeaderType *)*data)->id);//				BPMOWritePString("\p\r");//				BPMOKeyWait();				HD_DiscreteData_GetOffsetAndSize( data, &offset, &size);				nextData = NewHandle( size);				if ( nextData == nil)				{					BP_UserError_Literal("Factory Object Restoration Error",						"Ran out of memory while copying factory object "						"data. Operation incomplete.\r\r"						"You should probably quit without saving.");					return;				} else				{					BlockMove( *data + offset, *nextData, size);					HD_Create_Discrete_Data( d->heraFile, nextData,						0, size / HD_Get_DataSize_From_Type( kHera_Object_Type),						((heraDataHeaderType *)*data)->id, kHera_Object_Type);										DisposeHandle( nextData);				}				data = HD_DiscreteData_GetNextOfType( &gHera->factory, data,					kHera_Object_Type);			}			// repeat addtion for discrete string data			data = HD_DiscreteData_GetNextOfType( &gHera->factory, nil,				kHera_ObjectStrings_Type);			while ( data != nil)			{				HD_DiscreteData_GetOffsetAndSize( data, &offset, &size);				nextData = NewHandle( size);				if ( nextData == nil)				{					BP_UserError_Literal("Factory Object Restoration Error",						"Ran out of memory while copying factory object "						"data. Operation incomplete.\r\r"						"You should probably quit without saving.");					return;				} else				{					BlockMove( *data + offset, *nextData, size);					HD_Create_Discrete_Data( d->heraFile, nextData,						0, size / HD_Get_DataSize_From_Type( kHera_ObjectStrings_Type),						((heraDataHeaderType *)*data)->id, kHera_ObjectStrings_Type);										DisposeHandle( nextData);				}				data = HD_DiscreteData_GetNextOfType( &gHera->factory, data,					kHera_ObjectStrings_Type);			}		}	} else	{		if (( ((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags			& kScenario_Data_Flag_HasCustomScenarios))		{			mSetUpStandardAlert( &alertParam);			alertParam.defaultText = okButton;			alertParam.cancelText = cancelButton;			alertParam.defaultButton =				kAlertStdAlertCancelButton;			StandardAlert( kAlertCautionAlert,				"\pCreate Custom Objects",				"\pAre you sure you want to use "				"custom objects?",				&alertParam,				&itemHit);		} else		{			mSetUpStandardAlert( &alertParam);			alertParam.defaultText = okButton;			alertParam.cancelText = cancelButton;			alertParam.defaultButton =				kAlertStdAlertCancelButton;			StandardAlert( kAlertCautionAlert,				"\pCreate Custom Objects",				"\pAre you sure you want to use "				"custom objects?\r\r"				"Since you aren't using custom "				"scenarios, "				"you won't be able to add or "				"remove objects or change "				"their weapons or actions.",				&alertParam,				&itemHit);		}				if ( itemHit == kAlertStdAlertOKButton)		{			SetControlValue( aControl, 1);			((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags				|= kScenario_Data_Flag_HasCustomObjects;		}	}}static void CustomScenario_CheckBox_Click( ControlHandle aControl,	dataSelectorWindowType *d){	AlertStdAlertParamRec			alertParam;	unsigned char					okButton[] = "\pOK",									cancelButton[] = "\pCancel";	short							itemHit, ownerRefNum;	Handle							data;		if ( ((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags		& kScenario_Data_Flag_HasCustomScenarios)	{		// ** already has custom scenarios; delete them		mSetUpStandardAlert( &alertParam);		alertParam.defaultText = okButton;		alertParam.cancelText = cancelButton;		alertParam.defaultButton =			kAlertStdAlertCancelButton;		StandardAlert( kAlertCautionAlert,			"\pDispose of Custom Scenarios",			"\pAre you sure you want to use the "			"factory scenarios and dispose of the "			"custom scenarios?",			&alertParam,			&itemHit);												if ( itemHit == kAlertStdAlertOKButton)		{			SetControlValue( aControl, 0);			((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags				&= ~kScenario_Data_Flag_HasCustomScenarios;			// now we've got to delete the custom scenario resource (snro)			// from the file			data = HRT_Resource_GetHandle_WithOwnerFile(				d->heraFile, 'snro', 500, nil, &ownerRefNum, nil);						// if it exists in our file, kill it			if (data != nil)			{				if ( ownerRefNum == d->heraFile->fileRefNum)				{					BPMOWritePString("\pdeleting scenario resource\r");					HRT_DeleteResource( d->heraFile, 'snro', 500);				}				DisposeHandle( data);			}						// we've also got to delete the STR# resources			data = HRT_Resource_GetHandle_WithOwnerFile(				d->heraFile, 'STR#', 4600, nil, &ownerRefNum, nil);						// if it exists in our file, kill it			if (data != nil)			{				if ( ownerRefNum == d->heraFile->fileRefNum)				{					BPMOWritePString("\pdeleting chapter name string 4600\r");					HRT_DeleteResource( d->heraFile, 'STR#', 4600);				}				DisposeHandle( data);			}						// now delete scenario data in memory			if ( d->heraFile->scenarioData != nil)			{				DisposeHandle( d->heraFile->scenarioData);			}			d->heraFile->scenarioData = gHera->factory.scenarioData;			HandToHand( &d->heraFile->scenarioData);		}	} else	{		// doesn't have custom scenarios; add them		if (( ((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags			& kScenario_Data_Flag_HasCustomObjects)			)		{			mSetUpStandardAlert( &alertParam);			alertParam.defaultText = okButton;			alertParam.cancelText = cancelButton;			alertParam.defaultButton =				kAlertStdAlertCancelButton;			StandardAlert( kAlertCautionAlert,				"\pCreate Custom Scenarios",				"\pAre you sure you want to use "				"custom scenarios?",				&alertParam,				&itemHit);		} else		{			mSetUpStandardAlert( &alertParam);			alertParam.defaultText = okButton;			alertParam.cancelText = cancelButton;			alertParam.defaultButton =				kAlertStdAlertCancelButton;			StandardAlert( kAlertCautionAlert,				"\pCreate Custom Scenarios",				"\pAre you sure you want to use "				"custom scenarios?\r\r"				"Since you aren't using custom "				"objects, "				"you won't be able to add or "				"remove conditions or change their "				"actions.",				&alertParam,				&itemHit);		}				if ( itemHit == kAlertStdAlertOKButton)		{			SetControlValue( aControl, 1);			((scenarioInfoType *)*(d->heraFile->scenarioInfo))->flags				|= kScenario_Data_Flag_HasCustomScenarios;		}	}}static void SetScenarioInfo_FromControls( dataSelectorWindowType *d){	scenarioInfoType	info;	Str255				s;		BlockMove( *d->heraFile->scenarioInfo, &info, sizeof( scenarioInfoType));	HUI_Control_GetTextItemString( d->master, 0, 0, kGlobal_Row,		kGlobal_Title_ID, info.titleString);	HUI_Control_GetTextItemString( d->master, 0, 0, kGlobal_Row,		kGlobal_Download_URL_ID, info.downloadURLString);	HUI_Control_GetTextItemString( d->master, 0, 0, kGlobal_Row,		kGlobal_Author_ID, info.authorNameString);	HUI_Control_GetTextItemString( d->master, 0, 0, kGlobal_Row,		kGlobal_Author_URL_ID, info.authorURLString);	HUI_Control_GetTextItemString( d->master, 0, 0, kGlobal_Row,		kGlobal_Version_ID, s);	info.version = AresVersion_Get_FromString( s);	info.requiresAresVersion = kThis_Version_Is;	if ( !HU_Data_Is_Identical( (Ptr)&info, (Ptr)*d->heraFile->scenarioInfo,		sizeof( scenarioInfoType)))	{		d->heraFile->changed = true;	}	BlockMove( &info, *d->heraFile->scenarioInfo, sizeof( scenarioInfoType));}Boolean Data_Selector_Close( CWindowPtr whichWindow, long dispatchID,		Boolean confirm){	Str255	s;	Handle							data = GetDispatchWindowDataHandle(																dispatchID);	SignedByte						dataState;	dataSelectorWindowType			*d;#pragma unused( whichWindow)										if ( data == nil) return false;	dataState = HGetState( data);	HLock( data);	d = (dataSelectorWindowType *)*data;		SetScenarioInfo_FromControls( d);	gHera->currentSave = d->heraFile;	if ( DispatchWindowDispatchWDEvent( kWD_Close_ForQuit_Command))	{		HSetState( data, dataState);		return true; // cancelled	}	pstrcpy( s, "\pAre you sure you want to close the "				"scenario file Ò");	pstrcat( s, d->heraFile->fileSpec.name);	pstrcat( s, "\pÓ without saving?");	if (( d->heraFile->changed) ||		( d->heraFile->newResource != nil) && ( confirm))	{		if ( Button_Window_Modal( "\pClose without saving?",								s, nil, nil))		{			RemoveHeraFile( d->heraFile);			HUI_MasterControl_Delete( d->master);			CloseDispatchWindow( dispatchID);		} else		{			HSetState( data, dataState);			return true; // cancelled		}	} else	{		RemoveHeraFile( d->heraFile);		HUI_MasterControl_Delete( d->master);		CloseDispatchWindow( dispatchID);	}	return false;}static void ScenarioEditor_CallBack( Boolean ok, long windowID){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	dataSelectorWindowType			*d;#pragma unused( ok)		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (dataSelectorWindowType *)*data;		d->scenarioWindowID = -1;;		HSetState( data, dataState);	}static void ObjectEditor_CallBack( long windowID, long objectChoiceID){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	dataSelectorWindowType			*d;#pragma unused( objectChoiceID)		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (dataSelectorWindowType *)*data;		d->objectWindowID = -1;;		HSetState( data, dataState);	}static void RaceEditor_CallBack( Boolean ok, long windowID){	Handle							data = GetDispatchWindowDataHandle( windowID);	SignedByte						dataState;	dataSelectorWindowType			*d;#pragma unused( ok)		if ( data == nil) return;	dataState = HGetState( data);	HLock( data);	d = (dataSelectorWindowType *)*data;		d->raceWindowID = -1;;		HSetState( data, dataState);	}#pragma mark ¥¥PUBLIC FUNCTIONS¥¥/******************************************\|**| public functions\******************************************/OSErr DataSelect_NewWindow( heraScenarioFileType *heraFile, long *windowID, StringPtr userDataName){	Rect						bounds;	CWindowPtr					newWindow;	Str255						title, s;	ControlHandle				rootControl, aControl;	huiPlainControlParamType	buttonParam, textParam, groupParam;	huiCellParamType			cellParam;	huiMasterControlParamType	masterParam;	OSStatus					err;	Handle						data;	dataSelectorWindowType		*d;#pragma unused ( err, aControl)		// create the new window	*windowID = -1;	data = NewHandle( sizeof( dataSelectorWindowType));	if ( data == nil) return memFullErr;		HLock( data);	d = (dataSelectorWindowType *)*data;	d->raceWindowID = -1;	d->objectWindowID = -1;	d->actionWindowID = -1;	d->scenarioWindowID = -1;	d->heraFile = heraFile;		GetIndString( title, kHera_AppStrResID, 1);	if ( userDataName == nil)	{		pstrcpy( s, ((scenarioInfoType *)*(d->heraFile->scenarioInfo))->titleString);//		GetIndString( s, kHera_AppStrResID, 2);		pstrcat( title, s); 	} else	{		pstrcat( title, userDataName);	}		SetRect( &bounds, 64, 64, 128, 128);	newWindow = NewDispatchWindow( &bounds, title, false,		kWindowDocumentProc, (WindowPtr)-1, heraFile->fileRefNum >= 0,		HandleEvent, 0,		windowID);	SetDispatchWindowDataHandle( *windowID, data);		SetThemeWindowBackground( (WindowPtr)newWindow,		kThemeActiveDialogBackgroundBrush, true);	SetPortWindowPort( (WindowPtr)newWindow);	CreateRootControl( (WindowPtr)newWindow, &rootControl);	masterParam.control = &buttonParam;	masterParam.control->layer = 0;	masterParam.control->id = 0;	masterParam.control->flags = huiControlFlag_none;	SetRect( &masterParam.control->minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.window = newWindow;	masterParam.rowNum = kRowNum;	masterParam.colNum = 1;	masterParam.layerNum = 1;	SetRect( &masterParam.inSpace, 6, 6, 6, 6);	SetRect( &masterParam.outSpace, 12, 6, 6, 6);	SetRect( &masterParam.controlSpace, 6, 6, 6, 6);	SetRect( &masterParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	masterParam.baseLine = gHera->smallFontSize;	d->master = HUI_MasterControl_New( nil, 0, 0, 0, &masterParam);		mAssert( d->master != nil);	if ( d->master == nil) return memFullErr;	d->master->tab[0][0].h = 0;	d->master->tab[0][0].hAlign = hui_halign_void;	d->master->tab[0][2].h = kTabWidth;	d->master->tab[0][2].hAlign = hui_halign_right;	d->master->tab[0][3].h = kTabWidth;	d->master->tab[0][3].hAlign = hui_halign_left;		// set up scenario file info (global info) cell	cellParam.master = d->master;	cellParam.baseLine = -1;	cellParam.hAlign = hui_halign_center;	cellParam.vAlign = hui_valign_center;	cellParam.flags = huiControlFlag_none;	SetRect( &cellParam.minMaxBounds, 0, 0, kHUI_Pixel_Max, kHUI_Pixel_Max);	SetRect( &cellParam.outSpace, -1, 12, -1, -1);	SetRect( &cellParam.inSpace, 12, 12, 12, 12);	cellParam.colSpan = 1;	cellParam.rowSpan = 1;	HUI_Cell_Set( 0, 0, kGlobal_Row, &cellParam);	SetRect( &cellParam.outSpace, -1, -1, -1, 12);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	HUI_Cell_Set( 0, 0, kScenario_Row, &cellParam);//	HUI_Master_ShowLayer( d->master, 0);	// set up races group		groupParam.master = d->master;	groupParam.visible = true;	groupParam.enabled = true;	groupParam.layer = 0;	groupParam.special.group.isSecondary = false;	groupParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;	groupParam.fontStyle.font = gHera->smallFontNum;	groupParam.fontStyle.size = gHera->smallFontSize;	groupParam.fontStyle.style = gHera->smallFontBoldStyle;	groupParam.helpStringResID = -1;	groupParam.id = kRace_GroupID;	groupParam.cellx = 0;	groupParam.celly = kRace_Row;	SetRect( &cellParam.outSpace, -1, -1, -1, -1);	SetRect( &cellParam.inSpace, -1, -1, -1, -1);	GetIndString( groupParam.label, kStrResID, 3); // Races	HUI_Group_New_LiteralP( &groupParam);		// set up object group	groupParam.celly = kObject_Row;	groupParam.id = kObject_GroupID;	GetIndString( groupParam.label, kStrResID, 8); // Objects	HUI_Group_New_LiteralP( &groupParam);	/*	// set up action group	groupParam.celly = kAction_Row;	groupParam.id = kAction_GroupID;	GetIndString( groupParam.label, kStrResID, 13); // Objects	HUI_Group_New_LiteralP( &groupParam);*/		// set up conditions group/*	groupParam.celly = kCondition_Row;	groupParam.id = kCondition_GroupID;	GetIndString( groupParam.label, kStrResID, 18); // Objects	HUI_Group_New_LiteralP( &groupParam);*/		// set up Initial group/*	groupParam.celly = kInitial_Row;	groupParam.id = kInitial_GroupID;	GetIndString( groupParam.label, kStrResID, 23); // Objects	HUI_Group_New_LiteralP( &groupParam);*/			// set up info group	groupParam.celly = kGlobal_Row;	groupParam.id = kGlobal_GroupID;	GetIndString( groupParam.label, kStrResID, 38); // scenario file info	HUI_Group_New_LiteralP( &groupParam);		// set up Scenario group	groupParam.celly = kScenario_Row;	groupParam.id = kScenario_GroupID;	GetIndString( groupParam.label, kStrResID, 28); // Objects	HUI_Group_New_LiteralP( &groupParam);		// set up buttons, general	buttonParam.master = d->master;	buttonParam.visible = true;	buttonParam.enabled = true;	buttonParam.layer = 0;	buttonParam.whichTabSet = 0;	buttonParam.whichTab = 0;	buttonParam.minMaxBounds.left = 120;	buttonParam.minMaxBounds.top = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;	buttonParam.minMaxBounds.bottom = kHUI_Pixel_Max;	buttonParam.space.left = 4;	buttonParam.space.top = 8;	buttonParam.space.bottom = 4;	buttonParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	buttonParam.fontStyle.font = gHera->smallFontNum;	buttonParam.fontStyle.size = gHera->smallFontSize;	buttonParam.fontStyle.style = 0;	buttonParam.fontStyle.just = -1;	buttonParam.helpStringResID = -1;	buttonParam.enabledOnIndex = -1;	buttonParam.enabledOffIndex = -1;	buttonParam.disabledIndex = -1;		// set up text, general		textParam.master = d->master;	textParam.visible = true;	textParam.enabled = true;	textParam.layer = 0;	textParam.whichTabSet = -1;	textParam.whichTab = -1;	textParam.minMaxBounds.left = 0;	textParam.minMaxBounds.top = 0;	textParam.minMaxBounds.right = kHUI_Pixel_Max;	textParam.minMaxBounds.bottom = kHUI_Pixel_Max;	textParam.space.left = kControl_H_Space;//8;	textParam.space.top = 12;	textParam.space.bottom = 4;	textParam.flags = huiControlFlag_none;	textParam.fontStyle.flags = kControlUseFontMask | kControlUseSizeMask |		kControlUseFaceMask;// | kControlUseJustMask;	textParam.fontStyle.font = gHera->smallFontNum;	textParam.fontStyle.size = gHera->smallFontSize;	textParam.fontStyle.style = 0;	textParam.fontStyle.just = -1;	textParam.cellx = 0;	textParam.celly = 0;	textParam.helpStringResID = -1;	textParam.enabledOnIndex = -1;	textParam.enabledOffIndex = -1;	textParam.disabledIndex = -1;	// set up global data controls	textParam.cellx = 0;	textParam.celly = kGlobal_Row;		// title field	textParam.id = kGlobal_Title_ID - 1;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	GetIndString( textParam.label, kStrResID, 33);	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kGlobal_Title_ID;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 3;//	textParam.label[0] = 0;	pstrcpy( textParam.label,		((scenarioInfoType *)(*(d->heraFile->scenarioInfo)))->titleString);	textParam.minMaxBounds.left = textParam.minMaxBounds.right =		kEditText_FieldWidth_Big;	HUI_EditText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;		// version field	textParam.id = kGlobal_Version_ID - 1;	textParam.flags = huiControlFlag_newLine;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	GetIndString( textParam.label, kStrResID, 34);	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kGlobal_Version_ID;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 3;//	textParam.label[0] = 0;	String_Get_FromAresVersion( textParam.label,			((scenarioInfoType *)(*(d->heraFile->scenarioInfo)))->version);	textParam.minMaxBounds.left = textParam.minMaxBounds.right =		kEditText_FieldWidth_Big;	HUI_EditText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;		// author field	textParam.id = kGlobal_Author_ID - 1;	textParam.flags = huiControlFlag_newLine;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	GetIndString( textParam.label, kStrResID, 35);	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kGlobal_Author_ID;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 3;//	textParam.label[0] = 0;	pstrcpy( textParam.label,		((scenarioInfoType *)(*(d->heraFile->scenarioInfo)))->authorNameString);	textParam.minMaxBounds.left = textParam.minMaxBounds.right =		kEditText_FieldWidth_Big;	HUI_EditText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;		// author url field	textParam.id = kGlobal_Author_URL_ID - 1;	textParam.flags = huiControlFlag_newLine;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	GetIndString( textParam.label, kStrResID, 36);	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kGlobal_Author_URL_ID;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 3;//	textParam.label[0] = 0;	pstrcpy( textParam.label,		((scenarioInfoType *)(*(d->heraFile->scenarioInfo)))->authorURLString);	textParam.minMaxBounds.left = textParam.minMaxBounds.right =		kEditText_FieldWidth_Big;	HUI_EditText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;		// downlaod url field	textParam.id = kGlobal_Download_URL_ID - 1;	textParam.flags = huiControlFlag_newLine;	textParam.whichTabSet = 0;	textParam.whichTab = 2;	GetIndString( textParam.label, kStrResID, 37);	HUI_StaticText_New_LiteralP( &textParam);		textParam.id = kGlobal_Download_URL_ID;	textParam.flags = huiControlFlag_none;	textParam.whichTabSet = 0;	textParam.whichTab = 3;//	textParam.label[0] = 0;	pstrcpy( textParam.label,		((scenarioInfoType *)(*(d->heraFile->scenarioInfo)))->downloadURLString);	textParam.minMaxBounds.left = textParam.minMaxBounds.right =		kEditText_FieldWidth_Big;	HUI_EditText_New_LiteralP( &textParam);	textParam.minMaxBounds.left = 0;	buttonParam.minMaxBounds.right = kHUI_Pixel_Max;		// set up races controls	buttonParam.cellx = 0;	buttonParam.celly = kRace_Row;	// use factory races/*	buttonParam.id = kRace_UseFactory_Radio_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 4); // use factory races	HUI_RadioButton_New_LiteralP( &buttonParam);	*/	// use custom races	buttonParam.enabled = false;	buttonParam.id = kRace_UseCustom_CheckBox_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 5); // use factory races	HUI_CheckBox_New_LiteralP( &buttonParam);		buttonParam.enabled = true;		// edit races	buttonParam.id = kRace_Edit_Button_ID;	buttonParam.flags = (huiControlFlagType)		(/*(int)huiControlFlag_newLine | */(int)huiControlFlag_useTabMaxWidth);	GetIndString( buttonParam.label, kStrResID, 6); // use factory races	buttonParam.fontStyle.style = gHera->smallFontBoldStyle;	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.fontStyle.style = 0;	// delete custom/*	buttonParam.id = kRace_DeleteCustom_Button_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 7); // use factory races	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.fontStyle.style = 0;*/	// set up object controls	buttonParam.cellx = 0;	buttonParam.celly = kObject_Row;	// use factory object/*	buttonParam.id = kObject_UseFactory_Radio_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 9); // use factory objects	HUI_RadioButton_New_LiteralP( &buttonParam);	*/	// use custom object	buttonParam.enabled = false;	buttonParam.id = kObject_UseCustom_CheckBox_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 10); // use custom objects	HUI_CheckBox_New_LiteralP( &buttonParam);		buttonParam.enabled = true;		// edit object	buttonParam.id = kObject_Edit_Button_ID;	buttonParam.flags = (huiControlFlagType)		(/*(int)huiControlFlag_newLine | */(int)huiControlFlag_useTabMaxWidth);	GetIndString( buttonParam.label, kStrResID, 11); // edit objects	buttonParam.fontStyle.style = gHera->smallFontBoldStyle;	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.fontStyle.style = 0;	// delete object/*	buttonParam.id = kObject_DeleteCustom_Button_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 12); // delete objects	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.fontStyle.style = 0;*/		// set up action controls/*	buttonParam.cellx = 0;	buttonParam.celly = kAction_Row;	// use factory Action	buttonParam.id = kAction_UseFactory_Radio_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 14); // use factory Actions	HUI_RadioButton_New_LiteralP( &buttonParam);		// use custom Action	buttonParam.id = kAction_UseCustom_Radio_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 15); // use custom Actions	HUI_RadioButton_New_LiteralP( &buttonParam);			// edit Action	buttonParam.id = kAction_Edit_Button_ID;	buttonParam.flags = (huiControlFlagType)		((int)huiControlFlag_newLine | (int)huiControlFlag_useTabMaxWidth);	GetIndString( buttonParam.label, kStrResID, 16); // edit Actions	buttonParam.fontStyle.style = d->heraFile->smallFontBoldStyle;	HUI_PushButton_New_LiteralP( &buttonParam);		// delete Action	buttonParam.id = kAction_DeleteCustom_Button_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 17); // delete Actions	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.fontStyle.style = 0;*/	// set up condition controls/*	buttonParam.cellx = 0;	buttonParam.celly = kCondition_Row;	// use factory conditions	buttonParam.id = kCondition_UseFactory_Radio_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 19); // use factory conditions	HUI_RadioButton_New_LiteralP( &buttonParam);		// use custom condition	buttonParam.id = kCondition_UseCustom_Radio_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 20); // use custom conditions	HUI_RadioButton_New_LiteralP( &buttonParam);			// edit condition	buttonParam.id = kCondition_Edit_Button_ID;	buttonParam.flags = (huiControlFlagType)		((int)huiControlFlag_newLine | (int)huiControlFlag_useTabMaxWidth);	GetIndString( buttonParam.label, kStrResID, 21); // edit conditions	buttonParam.fontStyle.style = d->heraFile->smallFontBoldStyle;	HUI_PushButton_New_LiteralP( &buttonParam);		// delete condition	buttonParam.id = kCondition_DeleteCustom_Button_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 22); // delete conditions	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.fontStyle.style = 0;*/	// set up initial controls/*	buttonParam.cellx = 0;	buttonParam.celly = kInitial_Row;	// use factory Initials	buttonParam.id = kInitial_UseFactory_Radio_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 24); // use factory Initials	HUI_RadioButton_New_LiteralP( &buttonParam);		// use custom Initial	buttonParam.id = kInitial_UseCustom_Radio_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 25); // use custom Initials	HUI_RadioButton_New_LiteralP( &buttonParam);			// edit Initial	buttonParam.id = kInitial_Edit_Button_ID;	buttonParam.flags = (huiControlFlagType)		((int)huiControlFlag_newLine | (int)huiControlFlag_useTabMaxWidth);	GetIndString( buttonParam.label, kStrResID, 26); // edit Initials	buttonParam.fontStyle.style = d->heraFile->smallFontBoldStyle;	HUI_PushButton_New_LiteralP( &buttonParam);		// delete Initial	buttonParam.id = kInitial_DeleteCustom_Button_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 27); // delete Initials	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.fontStyle.style = 0;*/	// set up Scenario controls	buttonParam.cellx = 0;	buttonParam.celly = kScenario_Row;	// use factory Scenarios/*	buttonParam.id = kScenario_UseFactory_Radio_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 29); // use factory Scenarios	HUI_RadioButton_New_LiteralP( &buttonParam);	*/	// use custom Scenario	buttonParam.enabled = false;	buttonParam.id = kScenario_UseCustom_CheckBox_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 30); // use custom Scenarios	HUI_CheckBox_New_LiteralP( &buttonParam);		buttonParam.enabled = true;		// edit Scenario	buttonParam.id = kScenario_Edit_Button_ID;	buttonParam.flags = (huiControlFlagType)		(/*(int)huiControlFlag_newLine | */(int)huiControlFlag_useTabMaxWidth);	GetIndString( buttonParam.label, kStrResID, 31); // edit Scenarios	buttonParam.fontStyle.style = gHera->smallFontBoldStyle;	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.fontStyle.style = 0;	// delete Scenario/*	buttonParam.id = kScenario_DeleteCustom_Button_ID;	buttonParam.flags = huiControlFlag_useTabMaxWidth;	GetIndString( buttonParam.label, kStrResID, 32); // delete Scenarios	HUI_PushButton_New_LiteralP( &buttonParam);		buttonParam.fontStyle.style = 0;*/	{		scenarioInfoType	*info;				info = (scenarioInfoType *)*d->heraFile->scenarioInfo;		if ( info->flags & kScenario_Data_Flag_HasCustomObjects)			HUI_Control_SetValueShort( d->master, 0, 0, kObject_Row,				kObject_UseCustom_CheckBox_ID, true, false);		info = (scenarioInfoType *)*d->heraFile->scenarioInfo;		if ( info->flags & kScenario_Data_Flag_HasCustomRaces)			HUI_Control_SetValueShort( d->master, 0, 0, kRace_Row,				kRace_UseCustom_CheckBox_ID, true, false);		info = (scenarioInfoType *)*d->heraFile->scenarioInfo;		if ( info->flags & kScenario_Data_Flag_HasCustomScenarios)			HUI_Control_SetValueShort( d->master, 0, 0, kScenario_Row,				kScenario_UseCustom_CheckBox_ID, true, false);	}	ShowWindow( (WindowPtr)newWindow);	ActivateControl( rootControl);		HUI_Master_Layout( d->master, (Point){0, 0}, (Point){0, 0});	HUI_Master_ShowLayer( d->master, 0);	HUI_Master_ShowAllLayers_Deep( d->master);		HUnlock( data);	return noErr;}