/******************************************\|**| Hera_Data.h\******************************************/#ifndef kHera_Data_h#define kHera_Data_h#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#pragma mark _this library includes_/* - this project*******************************************/#include "Space Object.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#define	kHera_Action_Type					'obac'#define	kHera_Object_Type					'bsob'#define	kHera_Initial_Type					'snit'#define	kHera_Condition_Type				'sncd'#define	kHera_Scenario_Type					'snro'#define	kHera_BriefPoint_Type				'snbf'#define	kHera_ObjectStrings_Type			'bsos'#define	kHera_DestroyActionMask				kDestroyActionNotMask#define	kHera_ExpireActionMask				0xffffffff#define	kHera_CreateActionMask				0xffffffff#define	kHera_CollideActionMask				0xffffffff#define	kHera_ActivateActionMask			kPeriodicActionNotMask#define	kHera_ArriveActionMask				0xffffffff#pragma mark _macros_/* - macros*******************************************/#define	mHD_SetActionNum( m_actionNum, m_actionNumValue, m_actionMask) m_actionNum = (m_actionNum & ~(m_actionMask)) | (m_actionNumValue & (m_actionMask))#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/enum { hera_data_byIndex = 0, hera_data_byID = 1, hera_data_byHandle = 2};typedef struct heraDataReferenceType{	OSType				dataType;	long				referenceType;	union	{		long				index;		long				id;		Handle				heraData;	} data;} heraDataReferenceType;typedef struct heraDataHeaderType{	Handle				next;	Handle				previous;	OSType				dataType;	long				id;	long				realIndex;	long				num;	long				referenceNum;	unsigned long		flags;} heraDataHeaderType;typedef struct heraBaseObjectStringsType{	unsigned char		shortName[kObjectShortNameLength+1];	unsigned char		longName[kObjectNameLength+1];	Str255				devNote;} heraBaseObjectStringsType;/* heraDataChangesType	for keeping track of additions/deletions from data; when user adds or removes data	from a list (like initial objects) that is referenced by index elsewhere, record	it in a linked list of heraDataChangesType. When changes are finalized (user hits ok)	walk through the list and make changes to index values as needed.*/typedef struct heraDataChangesType{	long				index;	long				number;	long				action;	// -1 = remove, 1 = add	heraDataChangesType	*next;} heraDataChangesType;typedef void(*Hera_Data_ObjectWalker_Callback_procPtr)( Handle, Handle, unsigned long);#pragma mark 본PUBLIC PROTOTYPES본/******************************************\|**| public function prototypes\******************************************/OSErr HD_InitDiscreteData( heraScenarioFileType *heraFile);OSErr HD_CompileDiscreteData( heraScenarioFileType *heraFile, Boolean optimize);Handle HD_Find_Discrete_Data( heraScenarioFileType *heraFile, long id, long num, Boolean *idFound, OSType dataType);Handle HD_Create_Discrete_Data( heraScenarioFileType *heraFile, Handle source, long index, long number, long id, OSType type);void HD_Delete_Discrete_Data( heraScenarioFileType *heraFile, Handle data);void HD_Delete_Discrete_Data_All( heraScenarioFileType *heraFile);long HD_AppendDiscrete( heraScenarioFileType *heraFile, Handle originalData, long id, OSType dataType);long HD_Get_DataSize_From_Type( OSType type);long HD_Get_NextID_From_Type( heraScenarioFileType *heraFile, OSType type);OSErr HD_Add_Reference( Handle data, OSType dataType, long referenceType, unsigned long refID);void HD_DiscreteData_GetOffsetAndSize( Handle data, long *offset, long *size);void *HD_DiscreteData_GetNthElement( Handle data, OSType type, long n);long HD_DiscreteData_GetElementNumber( Handle data, OSType type);void *HD_DiscreteData_GetNthElementCopy( Handle data, OSType type, long n);void HD_DiscreteData_SetNthElementFromCopy( Handle data, OSType type, long n,	void *newElement);OSErr HD_DiscreteData_Replace( Handle data, Handle replacementData, OSType dataType);OSErr HD_DiscreteData_Replace_Compare( Handle data, Handle replacementData,	OSType dataType, Boolean *different);Handle HD_DiscreteData_GetNextOfType( heraScenarioFileType *heraFile, Handle data, OSType type);long HD_ScenarioIndex_GetFromChapterNumber( Handle scenarioData, long chapter);long HD_ChapterNumber_GetFromScenarioIndex( Handle scenarioData, long index);Boolean HD_IsScenarioNetworkable( Handle scenarioData, long index);Boolean HD_IsRaceLegalForScenarioPlayer( heraScenarioFileType *heraFile,  Handle scenarioData, long scenarioIndex,	long race, long player);long HD_RaceIndex_GetFrom_RaceID( heraScenarioFileType *heraFile, long raceID);long HD_RaceID_GetFrom_RaceIndex( heraScenarioFileType *heraFile, long raceIndex);heraDataChangesType *HD_DataChanges_Add( heraDataChangesType *head, long index,	long number, long action);heraDataChangesType *HD_DataChanges_GetLast( heraDataChangesType *head);void HD_DataChanges_DeleteAll( heraDataChangesType *head);void HD_DiscreteData_SetAllFlags( heraScenarioFileType *heraFile,	OSType type, unsigned long onFlags, unsigned long offFlags);void HD_DiscreteData_ClearAllRealIndexes( heraScenarioFileType *heraFile,	OSType type);void HD_ObjectWalker( heraScenarioFileType *heraFile,	long objectID, unsigned long userData,	Hera_Data_ObjectWalker_Callback_procPtr callBack);void HD_ObjectWalker_ActionWalker( heraScenarioFileType *heraFile,	Handle discreteData, unsigned long userData,	Hera_Data_ObjectWalker_Callback_procPtr callBack);Boolean HD_Object_Compare( heraScenarioFileType *sourceHeraFile,	Handle sourceObjectData, heraScenarioFileType *destHeraFile,	Handle destObjectData);Boolean HD_Action_Compare( heraScenarioFileType *sourceHeraFile, 	Handle sourceActionData, heraScenarioFileType *destHeraFile, 	Handle destActionData);Boolean HD_Objects_Essentially_Identical( baseObjectType *aBase,	baseObjectType *bBase);Boolean HD_Actions_Essentially_Identical( objectActionType *aAction,	objectActionType *bAction);long HD_Object_Copy( heraScenarioFileType *sourceFile, Handle sourceObjectData,	heraScenarioFileType *destFile);long HD_Action_Copy( heraScenarioFileType *sourceFile, Handle sourceActionData,	heraScenarioFileType *destFile);void HD_Scenario_Copy( heraScenarioFileType *sourceFile, Handle sourceScenarioData,	long sourceIndex, heraScenarioFileType *destFile, Handle destScenarioData,	long destIndex);#endif kHera_Data_h